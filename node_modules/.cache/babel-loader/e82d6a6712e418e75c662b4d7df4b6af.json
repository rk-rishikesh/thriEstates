{"ast":null,"code":"import { Signer as Signer$1, ethers, BigNumber, Contract } from 'ethers';\nimport { decodeNonce, computeMetaTxnHash, fromTransactionish, readSequenceNonce, appendNonce, digestOfTransactionsNonce, sequenceTxAbiEncode } from '@0xsequence/transactions';\nimport { isUsableConfig, sortConfig, addressOf, imageHash, isDecodedSigner, encodeSignature, joinSignatures, compareAddr, decodeSignature, isDecodedFullSigner, recoverEOASigner, SequenceUtilsFinder, isConfigEqual, isDecodedEOASigner, isDecodedAddress } from '@0xsequence/config';\nimport { ChainId, sequenceContext, isJsonRpcProvider, JsonRpcSender, getChainId, mainnetNetworks, ensureValidNetworks, sortNetworks } from '@0xsequence/network';\nimport { Provider, JsonRpcProvider } from '@ethersproject/providers';\nimport { Interface } from '@ethersproject/abi';\nimport { walletContracts } from '@0xsequence/abi';\nimport { encodeTypedDataDigest, subDigestOf, packMessageData } from '@0xsequence/utils';\nimport fetchPonyfill from 'fetch-ponyfill';\nimport { GuarddService } from '@0xsequence/guard';\nimport { resolveProperties } from '@ethersproject/properties';\nimport { isRelayer, isRpcRelayerOptions, RpcRelayer } from '@0xsequence/relayer';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nclass Signer extends Signer$1 {\n  static isSequenceSigner(cand) {\n    return isSequenceSigner(cand);\n  }\n\n}\n\nfunction isSequenceSigner(signer) {\n  const cand = signer;\n  return cand && cand.updateConfig !== undefined && cand.publishConfig !== undefined && cand.getWalletContext !== undefined && cand.getWalletConfig !== undefined;\n} // TODO: move to error.ts, along with others..\n\n\nclass InvalidSigner extends Error {}\n\nclass NotEnoughSigners extends Error {}\n\nclass RemoteSigner extends Signer$1 {\n  signMessage(message, chainId) {\n    return this.signMessageWithData(message);\n  }\n\n  sendTransaction(_) {\n    throw new Error('sendTransaction method is not supported in RemoteSigner');\n  }\n\n  signTransaction(_) {\n    throw new Error('signTransaction method is not supported in RemoteSigner');\n  }\n\n  connect(_) {\n    throw new Error('connect method is not supported in RemoteSigner');\n  }\n\n  static signMessageWithData(signer, message, data, chainId) {\n    if (this.isRemoteSigner(signer)) {\n      return signer.signMessageWithData(message, data, chainId);\n    }\n\n    return signer.signMessage(message);\n  }\n\n  static isRemoteSigner(signer) {\n    return signer.signMessageWithData !== undefined;\n  }\n\n}\n\nclass GuardRemoteSigner extends RemoteSigner {\n  constructor(address, hostname) {\n    let isSequence = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let defaultChainId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ChainId.MAINNET;\n    super();\n    this.isSequence = isSequence;\n    this.defaultChainId = defaultChainId;\n    this._guardd = void 0;\n    this._address = void 0;\n    this._guardd = new GuarddService(hostname, fetchPonyfill().fetch);\n    this._address = address;\n  }\n\n  async signMessageWithData(message, auxData, chainId) {\n    const request = {\n      msg: ethers.utils.hexlify(message),\n      auxData: ethers.utils.hexlify(auxData ? auxData : []),\n      chainId: chainId ? BigNumber.from(chainId).toNumber() : this.defaultChainId\n    };\n    const res = await this._guardd.sign({\n      request: request\n    }); // TODO: The guardd service doesn't include the EIP2126 signature type on it's reponse\n    // maybe it should be more explicit and include it? the EIP2126 is only required for non-sequence signatures\n\n    return this.isSequence ? res.sig : res.sig + '02';\n  }\n\n  async getAddress() {\n    return this._address;\n  }\n\n}\n\nclass LocalRemoteSigner extends RemoteSigner {\n  constructor(signer) {\n    super();\n    this._signer = void 0;\n    this._signer = signer;\n  }\n\n  signMessageWithData(message, _) {\n    return this._signer.signMessage(message);\n  }\n\n  getAddress() {\n    return this._signer.getAddress();\n  }\n\n}\n\nasync function resolveArrayProperties(object) {\n  if (Array.isArray(object)) {\n    // T must include array type\n    return Promise.all(object.map(o => resolveProperties(o)));\n  }\n\n  return resolveProperties(object);\n}\n\nasync function findLatestLog(provider, filter) {\n  const toBlock = filter.toBlock === 'latest' ? await provider.getBlockNumber() : filter.toBlock;\n  const fromBlock = filter.fromBlock;\n\n  try {\n    const logs = await provider.getLogs(_extends({}, filter, {\n      toBlock: toBlock\n    }));\n    return logs.length === 0 ? undefined : logs[logs.length - 1];\n  } catch (e) {\n    // TODO Don't assume all errors are bad\n    const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock);\n    const nhalf = await findLatestLog(provider, _extends({}, filter, {\n      fromBlock: pivot,\n      toBlock: toBlock\n    }));\n    if (nhalf !== undefined) return nhalf;\n    return findLatestLog(provider, _extends({}, filter, {\n      fromBlock: fromBlock,\n      toBlock: pivot\n    }));\n  }\n} //\n// Wallet allows managing the account/wallet sub-keys, wallet address, signing\n// messages, signing transactions and updating/deploying the wallet config on a specific chain.\n//\n// Wallet instances represent a wallet at a particular config-state, in someways, the Wallet\n// instance is immutable, and if you update the config, then you'll need to call useConfig()\n// to instantiate a new Wallet instance with the updated config.\n\n\nclass Wallet extends Signer {\n  // provider is an Ethereum Json RPC provider that is connected to a particular network (aka chain)\n  // and access to the signer for signing transactions.\n  // sender is a minimal Json RPC sender interface. It's here for convenience for other web3\n  // interfaces to use.\n  // relayer dispatches transactions to an Ethereum node directly\n  // or through a remote transaction Web Service.\n  // chainId is the node network id, used for memoization\n  constructor(options) {\n    super();\n    this.context = void 0;\n    this.config = void 0;\n    this._signers = void 0;\n    this.provider = void 0;\n    this.sender = void 0;\n    this.relayer = void 0;\n    this.chainId = void 0;\n    const {\n      config,\n      context,\n      strict\n    } = options;\n\n    if (context) {\n      this.context = _extends({}, context);\n    } else {\n      // default context is to use @0xsequence/network deployed context\n      this.context = _extends({}, sequenceContext);\n    }\n\n    if (strict === true) {\n      this.context.nonStrict = undefined;\n    } else if (strict === false) {\n      this.context.nonStrict = true;\n    }\n\n    if (!this.context.nonStrict && !isUsableConfig(config)) {\n      throw new Error('wallet config is not usable (strict mode)');\n    }\n\n    this.config = sortConfig(config);\n\n    for (var _len = arguments.length, signers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      signers[_key - 1] = arguments[_key];\n    }\n\n    this._signers = signers.map(s => Signer$1.isSigner(s) ? s : new ethers.Wallet(s)); // cache wallet config for future imageHash lookups\n\n    this.imageHash;\n  } // useConfig creates a new Wallet instance with the provided config, and uses the current provider\n  // and relayer. It's common to initialize a counter-factual / undeployed wallet by initializing\n  // it with the Wallet's init config, then calling useConfig() with the most-up-to-date config,\n  // ie. new Wallet({ config: initConfig }).useConfig(latestConfig).useSigners(signers)\n\n\n  useConfig(config, strict) {\n    return new Wallet({\n      config,\n      context: this.context,\n      strict\n    }, ...this._signers).setProvider(this.provider).setRelayer(this.relayer);\n  }\n\n  useSigners() {\n    for (var _len2 = arguments.length, signers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      signers[_key2] = arguments[_key2];\n    }\n\n    return new Wallet({\n      config: this.config,\n      context: this.context\n    }, ...signers).setProvider(this.provider).setRelayer(this.relayer);\n  } // connect is a short-hand to create an Account instance and set the provider and relayer.\n  //\n  // The connect method is defined on the AbstractSigner as connect(Provider): AbstractSigner\n\n\n  connect(provider, relayer) {\n    if (isJsonRpcProvider(provider)) {\n      return new Wallet({\n        config: this.config,\n        context: this.context\n      }, ...this._signers).setProvider(provider).setRelayer(relayer);\n    } else {\n      throw new Error('Wallet provider argument is expected to be a JsonRpcProvider');\n    }\n  } // setProvider assigns a json-rpc provider to this wallet instance\n\n\n  setProvider(provider) {\n    if (provider === undefined) return this;\n\n    if (Provider.isProvider(provider)) {\n      this.provider = provider;\n      this.sender = new JsonRpcSender(provider);\n    } else {\n      const jsonProvider = new JsonRpcProvider(provider);\n      this.provider = jsonProvider;\n      this.sender = new JsonRpcSender(jsonProvider);\n    }\n\n    this.chainId = undefined; // reset chainId value\n\n    return this;\n  } // setRelayer assigns a Sequence transaction relayer to this wallet instance\n\n\n  setRelayer(relayer) {\n    if (relayer === undefined) return this;\n    this.relayer = relayer;\n    return this;\n  }\n\n  async getProvider(chainId) {\n    if (chainId) await this.getChainIdNumber(chainId);\n    return this.provider;\n  }\n\n  async getRelayer(chainId) {\n    if (chainId) await this.getChainIdNumber(chainId);\n    return this.relayer;\n  }\n\n  async getWalletContext() {\n    return this.context;\n  }\n\n  async getWalletConfig(chainId) {\n    chainId = await this.getChainIdNumber(chainId);\n\n    const config = _extends({}, this.config, {\n      chainId\n    });\n\n    return [config];\n  }\n\n  async getWalletState(_) {\n    const [address, chainId, isDeployed] = await Promise.all([this.getAddress(), this.getChainId(), this.isDeployed()]);\n    const state = {\n      context: this.context,\n      config: this.config,\n      address: address,\n      chainId: chainId,\n      deployed: isDeployed,\n      imageHash: this.imageHash,\n      lastImageHash: isDeployed ? await fetchImageHash(this) : undefined\n    }; // TODO: set published boolean by checking if we have the latest logs\n    // that compute to the same hash as in lastImageHash\n\n    return [state];\n  } // connected reports if json-rpc provider has been connected\n\n\n  get connected() {\n    return this.sender !== undefined;\n  } // address returns the address of the wallet account address\n\n\n  get address() {\n    return addressOf(this.config, this.context);\n  } // imageHash is the unique hash of the WalletConfig\n\n\n  get imageHash() {\n    return imageHash(this.config);\n  } // getAddress returns the address of the wallet account address\n  //\n  // The getAddress method is defined on the AbstractSigner\n\n\n  async getAddress() {\n    return this.address;\n  } // getSigners returns the list of public account addresses to the currently connected\n  // signer objects for this wallet. Note: for a complete list of configured signers\n  // on the wallet, query getWalletConfig()\n\n\n  async getSigners() {\n    if (!this._signers || this._signers.length === 0) {\n      return [];\n    }\n\n    return Promise.all(this._signers.map(s => s.getAddress().then(s => ethers.utils.getAddress(s))));\n  } // chainId returns the network connected to this wallet instance\n\n\n  async getChainId() {\n    if (this.chainId) return this.chainId;\n\n    if (!this.provider) {\n      throw new Error('provider is not set, first connect a provider');\n    }\n\n    this.chainId = (await this.provider.getNetwork()).chainId;\n    return this.chainId;\n  }\n\n  async getNetworks() {\n    const chainId = await this.getChainId();\n    return [{\n      chainId: chainId,\n      name: '',\n      rpcUrl: ''\n    }];\n  } // getNonce returns the transaction nonce for this wallet, via the relayer\n\n\n  async getNonce(blockTag, space) {\n    return this.relayer.getNonce(this.config, this.context, space, blockTag);\n  } // getTransactionCount returns the number of transactions (aka nonce)\n  //\n  // getTransactionCount method is defined on the AbstractSigner\n\n\n  async getTransactionCount(blockTag) {\n    const encodedNonce = await this.getNonce(blockTag, 0);\n    const [_, decodedNonce] = decodeNonce(encodedNonce);\n    return ethers.BigNumber.from(decodedNonce).toNumber();\n  } // sendTransaction will dispatch the transaction to the relayer for submission to the network.\n\n\n  async sendTransaction(transaction, chainId, allSigners, quote, callback) {\n    const signedTxs = await this.signTransactions(transaction, chainId, allSigners);\n\n    if (callback) {\n      const address = addressOf(signedTxs.config, signedTxs.context);\n      const metaTxnHash = computeMetaTxnHash(address, signedTxs.chainId, ...signedTxs.transactions);\n      callback(signedTxs, metaTxnHash);\n    }\n\n    return this.relayer.relay(signedTxs, quote);\n  } // sendTransactionBatch is a sugar for better readability, but is the same as sendTransaction\n\n\n  async sendTransactionBatch(transactions, chainId) {\n    let allSigners = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let quote = arguments.length > 3 ? arguments[3] : undefined;\n    let callback = arguments.length > 4 ? arguments[4] : undefined;\n    return this.sendTransaction(transactions, chainId, allSigners, quote, callback);\n  } // signTransactions will sign a Sequence transaction with the wallet signers\n  //\n  // NOTE: the txs argument of type Transactionish can accept one or many transactions.\n\n\n  async signTransactions(txs, chainId, allSigners) {\n    const signChainId = await this.getChainIdNumber(chainId);\n    const transaction = await resolveArrayProperties(txs);\n\n    if (!this.provider) {\n      throw new Error('missing provider');\n    }\n\n    if (!this.relayer) {\n      throw new Error('missing relayer');\n    } // Convert Transactionish into Sequence transactions\n\n\n    let stx = await fromTransactionish(this.context, this.address, transaction); // If a transaction has 0 gasLimit and not revertOnError\n    // compute all new gas limits\n\n    if (stx.find(a => !a.revertOnError && ethers.BigNumber.from(a.gasLimit || 0).eq(ethers.constants.Zero))) {\n      stx = await this.relayer.estimateGasLimits(this.config, this.context, ...stx);\n    } // If provided nonce append it to all other transactions\n    // otherwise get next nonce for this wallet\n\n\n    const providedNonce = readSequenceNonce(...stx);\n    const nonce = providedNonce ? providedNonce : await this.getNonce();\n    stx = appendNonce(stx, nonce); // Get transactions digest\n\n    const digest = digestOfTransactionsNonce(nonce, ...stx); // Bundle with signature\n\n    return {\n      digest: digest,\n      chainId: signChainId,\n      context: this.context,\n      config: this.config,\n      transactions: stx,\n      nonce,\n      signature: await this.sign(digest, true, chainId, allSigners)\n    };\n  }\n\n  async sendSignedTransactions(signedTxs, chainId, quote) {\n    if (!this.relayer) {\n      throw new Error('relayer is not set, first connect a relayer');\n    }\n\n    await this.getChainIdNumber(chainId);\n    return this.relayer.relay(signedTxs, quote);\n  } // signMessage will sign a message for a particular chainId with the wallet signers\n  //\n  // NOTE: signMessage(message: Bytes | string): Promise<string> is defined on AbstractSigner\n\n\n  async signMessage(message, chainId, allSigners) {\n    let isDigest = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const data = typeof message === 'string' && !message.startsWith('0x') ? ethers.utils.toUtf8Bytes(message) : message;\n    return this.sign(data, isDigest, chainId, allSigners);\n  }\n\n  async signTypedData(domain, types, message, chainId, allSigners) {\n    const signChainId = await this.getChainIdNumber(chainId);\n    const domainChainId = domain.chainId ? BigNumber.from(domain.chainId).toNumber() : undefined;\n\n    if (domainChainId && domainChainId !== signChainId) {\n      throw new Error(`signTypedData: domain.chainId (${domain.chainId}) is expected to be ${signChainId}`);\n    }\n\n    const hash = encodeTypedDataDigest({\n      domain,\n      types,\n      message\n    });\n    return this.sign(hash, true, signChainId, allSigners);\n  }\n\n  async _signTypedData(domain, types, message, chainId, allSigners) {\n    return this.signTypedData(domain, types, message, chainId, allSigners);\n  }\n\n  async subDigest(digest, chainId) {\n    const solvedChainId = await this.getChainIdNumber(chainId);\n    return ethers.utils.arrayify(subDigestOf(this.address, solvedChainId, digest));\n  } // sign is a helper method to sign a payload with the wallet signers\n\n\n  async sign(msg) {\n    let isDigest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let chainId = arguments.length > 2 ? arguments[2] : undefined;\n    let allSigners = arguments.length > 3 ? arguments[3] : undefined;\n\n    var _this = this;\n\n    const signChainId = await this.getChainIdNumber(chainId);\n    const digest = isDigest ? msg : ethers.utils.keccak256(msg); // Generate sub-digest\n\n    const subDigest = await this.subDigest(digest, chainId); // Sign sub-digest using a set of signers and some optional data\n\n    const signWith = async function signWith(signers, auxData) {\n      const signersAddr = await Promise.all(signers.map(s => s.getAddress()));\n      const parts = await Promise.all(_this.config.signers.map(async function (s) {\n        try {\n          const signer = signers[signersAddr.indexOf(s.address)]; // Is not a signer, return config entry as-is\n\n          if (!signer) {\n            return s;\n          } // Is another Sequence wallet as signer, sign and append '03' (ERC1271 type)\n\n\n          if (isSequenceSigner(signer)) {\n            if (signer === _this) throw Error(\"Can't sign transactions for self\");\n            const signature = (await signer.signMessage(subDigest, signChainId, allSigners, true)) + '03';\n            return _extends({}, s, {\n              signature: signature\n            });\n          } // Is remote signer, call and deduce signature type\n\n\n          if (RemoteSigner.isRemoteSigner(signer)) {\n            const signature = await signer.signMessageWithData(subDigest, auxData, signChainId);\n\n            try {\n              // Check if signature can be recovered as EOA signature\n              const isEOASignature = recoverEOASigner(subDigest, {\n                weight: s.weight,\n                signature: signature\n              }) === s.address;\n\n              if (isEOASignature) {\n                // Exclude address on EOA signatures\n                return {\n                  weight: s.weight,\n                  signature: signature\n                };\n              }\n            } catch (_unused) {} // Prepare signature for full encoding\n\n\n            return _extends({}, s, {\n              signature: signature\n            });\n          } // Is EOA signer\n\n\n          return {\n            weight: s.weight,\n            signature: (await signer.signMessage(subDigest)) + '02'\n          };\n        } catch (err) {\n          if (allSigners) {\n            throw err;\n          } else {\n            console.warn(`Skipped signer ${s.address}`);\n            return s;\n          }\n        }\n      }));\n      return {\n        threshold: _this.config.threshold,\n        signers: parts\n      };\n    }; // Sign message first using localSigners\n\n\n    const localSigners = this._signers.filter(s => !RemoteSigner.isRemoteSigner(s));\n\n    const localSignature = await signWith(localSigners, this.packMsgAndSig(digest, [], signChainId)); // Skip remote signers if we already meet threshold\n\n    const totalWeight = localSignature.signers.filter(isDecodedSigner).reduce((totalWeight, signer) => totalWeight + signer.weight, 0);\n\n    if (totalWeight >= this.config.threshold) {\n      return encodeSignature(localSignature);\n    } // include local signatures for remote signers\n\n\n    const remoteSigners = this._signers.filter(s => RemoteSigner.isRemoteSigner(s));\n\n    const remoteSignature = await signWith(remoteSigners, this.packMsgAndSig(digest, encodeSignature(localSignature), signChainId)); // Aggregate both local and remote signatures\n\n    return encodeSignature(joinSignatures(localSignature, remoteSignature));\n  } // signWeight will return the total weight of all signers available based on the config\n\n\n  async signWeight() {\n    const signers = await this.getSigners();\n    return signers.reduce((p, s) => {\n      const sconfig = this.config.signers.find(c => c.address === s);\n      if (!sconfig) return p;\n      return p.add(sconfig.weight);\n    }, ethers.constants.Zero);\n  }\n\n  async isDeployed(chainId) {\n    await this.getChainIdNumber(chainId);\n    const walletCode = await this.provider.getCode(this.address);\n    return !!walletCode && walletCode !== '0x';\n  } // updateConfig will build an updated config transaction and send it to the Ethereum\n  // network via the relayer. Note, the updated wallet config is stored as an image hash,\n  // unlike `publishConfig` which will store the entire WalletConfig object in logs.\n\n\n  async updateConfig(config, nonce) {\n    let publish = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let indexed = arguments.length > 3 ? arguments[3] : undefined;\n    let quote = arguments.length > 4 ? arguments[4] : undefined;\n    let callback = arguments.length > 5 ? arguments[5] : undefined;\n    if (!config) config = this.config;\n    const [txs, n] = await Promise.all([this.buildUpdateConfigTransaction(config, publish, indexed), nonce != null ? nonce : this.getNonce()]);\n    return [_extends({\n      address: this.address\n    }, config), await this.sendTransaction(appendNonce(txs, n), undefined, undefined, quote, callback)];\n  } // publishConfig will publish the current wallet config to the network via the relayer.\n  // Publishing the config will also store the entire object of signers.\n\n\n  async publishConfig(indexed, nonce) {\n    let requireFreshSigners = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let quote = arguments.length > 3 ? arguments[3] : undefined;\n    let callback = arguments.length > 4 ? arguments[4] : undefined;\n    return this.sendTransaction(this.config.address ? this.buildPublishConfigTransaction(this.config, indexed, nonce) : await this.buildPublishSignersTransaction(indexed, nonce, requireFreshSigners), undefined, undefined, quote, callback);\n  } // buildUpdateConfigTransaction creates a transaction to update the imageHash of the wallet's config\n  // on chain. Note, the transaction is not sent to the network by this method.\n  //\n  // The `publish` argument when true will also store the contents of the WalletConfig to a chain's logs.\n\n\n  async buildUpdateConfigTransaction(config) {\n    let publish = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let indexed = arguments.length > 2 ? arguments[2] : undefined;\n\n    var _this2 = this;\n\n    if (!this.context.nonStrict && !isUsableConfig(config)) throw new Error('wallet config is not usable (strict mode)');\n    const isUpgradable = await async function () {\n      try {\n        const implementation = await _this2.provider.getStorageAt(_this2.address, ethers.utils.defaultAbiCoder.encode(['address'], [_this2.address]));\n        return compareAddr(implementation, _this2.context.mainModuleUpgradable) === 0;\n      } catch (_unused2) {\n        return false;\n      }\n    }();\n    const walletInterface = new Interface(walletContracts.mainModule.abi); // empirically, this seems to work for the tests:\n    // const gasLimit = 100000 + 1800 * config.signers.length\n    //\n    // but we're going to play it safe with this instead:\n\n    const gasLimit = 2 * (100000 + 1800 * config.signers.length);\n    const preTransaction = isUpgradable ? [] : [{\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: this.address,\n      value: ethers.constants.Zero,\n      data: walletInterface.encodeFunctionData(walletInterface.getFunction('updateImplementation'), [this.context.mainModuleUpgradable])\n    }];\n    const mainModuleInterface = new Interface(walletContracts.mainModuleUpgradable.abi);\n    const transaction = {\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: this.address,\n      value: ethers.constants.Zero,\n      data: mainModuleInterface.encodeFunctionData(mainModuleInterface.getFunction('updateImageHash'), [imageHash(config)])\n    };\n    const postTransaction = publish ? await this.buildPublishConfigTransaction(config, indexed) : [];\n    const transactions = [...preTransaction, transaction, ...postTransaction]; // If update config reguires a single transaction\n    // skip nested selfExecute bundle\n\n    if (transactions.length === 1) {\n      return transactions;\n    }\n\n    return [{\n      delegateCall: false,\n      revertOnError: false,\n      gasLimit: gasLimit,\n      to: this.address,\n      value: ethers.constants.Zero,\n      data: walletInterface.encodeFunctionData(walletInterface.getFunction('selfExecute'), [sequenceTxAbiEncode(transactions)])\n    }];\n  }\n\n  buildPublishConfigTransaction(config) {\n    let indexed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let nonce = arguments.length > 2 ? arguments[2] : undefined;\n    const sequenceUtilsInterface = new Interface(walletContracts.sequenceUtils.abi);\n    return [{\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: this.context.sequenceUtils,\n      value: ethers.constants.Zero,\n      nonce: nonce,\n      data: sequenceUtilsInterface.encodeFunctionData(sequenceUtilsInterface.getFunction('publishConfig'), [this.address, config.threshold, sortConfig(config).signers.map(s => ({\n        weight: s.weight,\n        signer: s.address\n      })), indexed])\n    }];\n  }\n\n  async buildPublishSignersTransaction() {\n    let indexed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let nonce = arguments.length > 1 ? arguments[1] : undefined;\n    let requireFreshSigners = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    var _this$context$libs;\n\n    const sequenceUtilsInterface = new Interface(walletContracts.sequenceUtils.abi);\n    const requireFreshSignersInterface = new Interface(walletContracts.requireFreshSigner.abi);\n    const message = ethers.utils.randomBytes(32);\n    const signature = await this.signMessage(message, this.chainId, false); // TODO: This is only required because RequireUtils doesn't support dynamic signatures\n    // remove this filtering of dynamic once a new version of RequireUtils is deployed\n\n    const decodedSignature = decodeSignature(signature);\n    const filteredSignature = encodeSignature({\n      threshold: decodedSignature.threshold,\n      signers: decodedSignature.signers.map((s, i) => {\n        if (isDecodedFullSigner(s)) {\n          const a = this.config.signers[i];\n          return {\n            weight: a.weight,\n            address: a.address\n          };\n        }\n\n        return s;\n      })\n    });\n    const contextRequireFreshSigner = (_this$context$libs = this.context.libs) == null ? void 0 : _this$context$libs.requireFreshSigner;\n\n    if (requireFreshSigners.length > 0 && contextRequireFreshSigner === undefined) {\n      throw Error('requireFreshSigners missing library');\n    }\n\n    return [...requireFreshSigners.map(signer => ({\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: contextRequireFreshSigner,\n      value: ethers.constants.Zero,\n      nonce: nonce,\n      data: requireFreshSignersInterface.encodeFunctionData(requireFreshSignersInterface.getFunction('requireFreshSigner'), [signer])\n    })), {\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: this.context.sequenceUtils,\n      value: ethers.constants.Zero,\n      nonce: nonce,\n      data: sequenceUtilsInterface.encodeFunctionData(sequenceUtilsInterface.getFunction('publishInitialSigners'), [this.address, ethers.utils.keccak256(message), this.config.signers.length, filteredSignature, indexed])\n    }];\n  } // getChainIdFromArgument will return the chainId of the argument, as well as ensure\n  // we're not providing an invalid chainId that isn't connected to this wallet.\n\n\n  async getChainIdNumber(chainId) {\n    if (!chainId) {\n      // it's valid for chainId argument to be undefined, in which case\n      // we will use the connected value\n      return await this.getChainId();\n    }\n\n    const id = getChainId(chainId);\n\n    if (this.context.nonStrict) {\n      // in non-strict mode, just return the chainId from argument\n      return id;\n    }\n\n    const connectedChainId = await this.getChainId();\n\n    if (connectedChainId !== id) {\n      throw new Error(`the specified chainId ${id} does not match the wallet's connected chainId ${connectedChainId}`);\n    }\n\n    return connectedChainId;\n  } // packMsgAndSig is used by RemoteSigners to include details as a string blob of data.\n\n\n  packMsgAndSig(msg, sig, chainId) {\n    return ethers.utils.defaultAbiCoder.encode(['address', 'uint256', 'bytes', 'bytes'], [this.address, chainId, msg, sig]);\n  }\n\n  signTransaction(_) {\n    throw new Error('signTransaction method is not supported in Wallet, please use signTransactions(...)');\n  } // singleOwner will create a Wallet instance with a single signer (ie. from a single EOA account)\n\n\n  static async singleOwner(owner, context) {\n    const signer = Signer$1.isSigner(owner) ? owner : new ethers.Wallet(owner);\n    const config = {\n      threshold: 1,\n      signers: [{\n        weight: 1,\n        address: ethers.utils.getAddress(await signer.getAddress())\n      }]\n    };\n    return new Wallet({\n      config,\n      context\n    }, signer);\n  }\n\n  async hasEnoughSigners(chainId) {\n    if (chainId) await this.getChainIdNumber(chainId);\n    return (await this.signWeight()).gte(this.config.threshold);\n  }\n\n} // Account is an interface to a multi-network smart contract wallet.\n\n\nclass Account extends Signer {\n  // provider points at the main chain for compatability with the Signer.\n  // Use getProvider(chainId) to get the provider for the respective network.\n  // memoized value\n  constructor(options) {\n    super();\n    this.options = void 0;\n    this._wallets = void 0;\n    this._signers = void 0;\n    this.provider = void 0;\n    this._chainId = void 0;\n    this.options = options;\n\n    for (var _len3 = arguments.length, signers = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      signers[_key3 - 1] = arguments[_key3];\n    }\n\n    this._signers = signers; // Use deployed wallet context by default if not provided\n\n    if (!options.context) this.options.context = _extends({}, sequenceContext); // Network config, defaults will be used if none are provided\n\n    if (this.options.networks) {\n      this.setNetworks(this.options.networks);\n    } else {\n      this.setNetworks([...mainnetNetworks]);\n    }\n  }\n\n  useSigners() {\n    for (var _len4 = arguments.length, signers = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      signers[_key4] = arguments[_key4];\n    }\n\n    this._signers = signers;\n\n    this._wallets.forEach(w => {\n      w.wallet = w.wallet.useSigners(...signers);\n    });\n\n    return this;\n  }\n\n  async getWalletContext() {\n    return this.options.context;\n  }\n\n  getConfigFinder() {\n    if (this.options.configFinder) return this.options.configFinder;\n    return new SequenceUtilsFinder(this.authWallet().wallet.provider);\n  } // getWalletConfig builds a list of WalletConfigs across all networks.\n  // This is useful to shows all keys/devices connected to a wallet across networks.\n\n\n  async getWalletConfig(chainId) {\n    let wallets = [];\n\n    if (chainId) {\n      const v = this.getWalletByNetwork(chainId);\n\n      if (v) {\n        wallets.push(v);\n      }\n    } else {\n      wallets = this._wallets;\n    }\n\n    return (await Promise.all(wallets.map(w => w.wallet.getWalletConfig()))).flat();\n  }\n\n  async getWalletState(chainId) {\n    let wallets = [];\n\n    if (chainId) {\n      const v = this.getWalletByNetwork(chainId);\n\n      if (v) {\n        wallets.push(v);\n      }\n    } else {\n      wallets = this._wallets;\n    }\n\n    const configsPromise = Promise.all(wallets.map(w => this.getConfigFinder().findCurrentConfig({\n      address: w.wallet.address,\n      provider: w.wallet.provider,\n      context: w.wallet.context,\n      knownConfigs: [w.wallet.config]\n    })));\n    const states = (await Promise.all(wallets.map(w => w.wallet.getWalletState()))).flat(); // fetch the current config for the AuthChain, as it will be available\n\n    const idx = states.findIndex(s => s.chainId === this.getAuthChainId());\n\n    if (idx >= 0) {\n      states[idx].config = await this.currentConfig(wallets[idx].wallet);\n    }\n\n    const configs = await configsPromise;\n    return states.map((s, i) => {\n      var _configs$i;\n\n      return _extends({}, s, {\n        config: (_configs$i = configs[i]) == null ? void 0 : _configs$i.config\n      });\n    });\n  } // address getter\n\n\n  get address() {\n    return this._wallets[0].wallet.address;\n  } // getAddress returns the address of the wallet -- note the account address is the same\n  // across all wallets on all different networks\n\n\n  getAddress() {\n    return this._wallets[0].wallet.getAddress();\n  } // getSigners returns the multi-sig signers with permission to control the wallet\n\n\n  async getSigners() {\n    return this._wallets[0].wallet.getSigners();\n  }\n\n  async getProvider(chainId) {\n    var _this$mainWallet, _this$_wallets$find;\n\n    if (!chainId) return (_this$mainWallet = this.mainWallet()) == null ? void 0 : _this$mainWallet.wallet.getProvider();\n    return (_this$_wallets$find = this._wallets.find(w => w.network.chainId === chainId)) == null ? void 0 : _this$_wallets$find.wallet.getProvider();\n  }\n\n  async getRelayer(chainId) {\n    var _this$mainWallet2, _this$_wallets$find2;\n\n    if (!chainId) return (_this$mainWallet2 = this.mainWallet()) == null ? void 0 : _this$mainWallet2.wallet.getRelayer();\n    return (_this$_wallets$find2 = this._wallets.find(w => w.network.chainId === chainId)) == null ? void 0 : _this$_wallets$find2.wallet.getRelayer();\n  }\n\n  async getNetworks() {\n    return this.options.networks;\n  } // NOTE: this is copied over on top of ethers, and is memoized\n\n\n  async getChainId() {\n    if (this._chainId) return this._chainId;\n    const network = await this.provider.getNetwork();\n    this._chainId = network.chainId;\n    return this._chainId;\n  }\n\n  getAuthChainId() {\n    try {\n      return this.options.networks.find(network => network.isAuthChain).chainId;\n    } catch (_unused) {\n      throw new Error('no auth network');\n    }\n  }\n\n  async signMessage(message, target) {\n    let allSigners = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let isDigest = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    var _this = this;\n\n    let {\n      wallet\n    } = await async function () {\n      // eslint-disable-line\n      if (!target) {\n        return _this.mainWallet();\n      }\n\n      if (target.address) {\n        const chainId = await target.getChainId();\n        return _this.getWalletByNetwork(chainId);\n      }\n\n      return _this.getWalletByNetwork(target);\n    }(); // Fetch the latest config of the wallet.\n    //\n    // We skip this step if wallet is authWallet. The assumption is that authWallet\n    // will already have the latest config, but lets confirm that.\n    // TODO: instead, memoize the currentConfig, as below will break\n    // if we skip\n    // if (!network.isAuthChain) {\n\n    let thisConfig = await this.currentConfig(wallet);\n    thisConfig = thisConfig ? thisConfig : this._wallets[0].wallet.config;\n    wallet = wallet.useConfig(thisConfig); // }\n    // See if wallet and available signers set has enough signer power,\n    // but if allSigners is false, we allow partial signing\n\n    const weight = await wallet.signWeight();\n\n    if (weight.lt(wallet.config.threshold) && allSigners !== false) {\n      throw new NotEnoughSigners(`Sign message - wallet combined weight ${weight.toString()} below required ${wallet.config.threshold.toString()}`);\n    }\n\n    return wallet.signMessage(message, undefined, allSigners, isDigest);\n  } // TODO: should allSigners default to false here..?\n\n\n  async signAuthMessage(message) {\n    let allSigners = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let isDigest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    var _this$authWallet;\n\n    return this.signMessage(message, (_this$authWallet = this.authWallet()) == null ? void 0 : _this$authWallet.wallet, allSigners, isDigest);\n  }\n\n  async signTypedData(domain, types, message, chainId) {\n    let allSigners = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    const digest = encodeTypedDataDigest({\n      domain,\n      types,\n      message\n    });\n    return this.signMessage(digest, wallet, allSigners, true);\n  }\n\n  async _signTypedData(domain, types, message, chainId) {\n    let allSigners = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    return this.signTypedData(domain, types, message, chainId, allSigners);\n  }\n\n  async hasEnoughSigners(chainId) {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    const thisConfig = await this.currentConfig(wallet);\n    return wallet.useConfig(thisConfig).hasEnoughSigners();\n  }\n\n  async getFeeOptions(transaction, chainId) {\n    let allSigners = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    const context = this.options.context;\n\n    if (!context) {\n      throw new Error(`missing wallet context`);\n    } // TODO: can we avoid calling `this.currentConfig(wallet)` everytime here.. this is an expensive\n    // operations and we shouldn't be doing it so liberally. What is the minimum information we require here..?\n    // and what is the config used for, and how can we optimize..?\n    // TODO: prependConfigUpdate also looks like its calling currentConfig() again, so we're doubling this.\n    // A few thoughts.. first off, we must add some kind of memoization for this, but with great care, because\n    // the config might change. This make me think we need some king of \"ConfigSource\" class, or \"ConfigXXX\" (name?),\n    // which we can ask to give us a wallet config. This config would also be used when we update/change a config,\n    // such that it can memoize, but also since its the sole interface, it will also properly expire or update the config\n    // in cache as necessary. Further to this, I think we need to only get config details for what is required, and try\n    // to optimize by using imageHashes of the config everywhere, as this is a much more inexpensive value to fetch.\n\n\n    const [config, updatedTransaction] = await Promise.all([this.currentConfig(wallet), this.prependConfigUpdate(transaction, chainId, allSigners, true)]);\n\n    if (!config) {\n      throw new Error(`missing current config for chain ${chainId}`);\n    }\n\n    const finalTransactions = await fromTransactionish(context, this.address, updatedTransaction);\n    return wallet.relayer.getFeeOptions(config, context, ...finalTransactions);\n  }\n\n  async sendTransaction(dtransactionish, chainId) {\n    let allSigners = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let quote = arguments.length > 3 ? arguments[3] : undefined;\n    let callback = arguments.length > 4 ? arguments[4] : undefined;\n    const signedTxs = await this.signTransactions(dtransactionish, chainId, allSigners);\n\n    if (callback) {\n      const address = addressOf(signedTxs.config, signedTxs.context);\n      const metaTxnHash = computeMetaTxnHash(address, signedTxs.chainId, ...signedTxs.transactions);\n      callback(signedTxs, metaTxnHash);\n    }\n\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    return wallet.sendSignedTransactions(signedTxs, chainId, quote);\n  }\n\n  async sendTransactionBatch(transactions, chainId) {\n    let allSigners = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let quote = arguments.length > 3 ? arguments[3] : undefined;\n    let callback = arguments.length > 4 ? arguments[4] : undefined;\n    return this.sendTransaction(transactions, chainId, allSigners, quote, callback);\n  }\n\n  async signTransactions(dtransactionish, chainId, allSigners) {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    let currentConfig = await this.currentConfig(wallet);\n\n    if (!currentConfig) {\n      currentConfig = await this.currentConfig();\n\n      if (!currentConfig) {\n        throw new Error('missing auth chain config');\n      }\n    }\n\n    const transactions = await this.prependConfigUpdate(dtransactionish, chainId, allSigners);\n    return wallet.useConfig(currentConfig).signTransactions(transactions);\n  }\n\n  async prependConfigUpdate(dtransactionish, chainId, allSigners, skipThresholdCheck) {\n    const transaction = await resolveArrayProperties(dtransactionish);\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet; // TODO: Skip this step if wallet is authWallet\n\n    const [thisConfig, lastConfig] = await Promise.all([this.currentConfig(wallet), this.currentConfig()]); // We have to skip the threshold check during fee estimation because we\n    // might not have the necessary signers until the wallet actually signs the\n    // transactions.\n    //\n    // By design, the Torus login key only exists in memory in Sequence wallet\n    // and cannot generally be assumed to be available. However the Torus login\n    // key might be required in order to transact on other non-auth chains,\n    // because the wallet config might not recognize the current session's\n    // signing key. In these cases, the Torus key is retrieved when the user\n    // confirms the transaction, which happens after fee estimation. So the\n    // wallet might not meet the threshold during fee estimation despite\n    // meeting it at confirmation time.\n\n    if (!skipThresholdCheck) {\n      // See if wallet has enough signer power\n      const weight = await wallet.useConfig(thisConfig).signWeight();\n\n      if (weight.lt(thisConfig.threshold) && allSigners) {\n        throw new NotEnoughSigners(`wallet combined weight ${weight.toString()} below required threshold ${thisConfig.threshold.toString()}`);\n      }\n    } // If the wallet is updated, just sign as-is\n\n\n    if ((await wallet.isDeployed()) && isConfigEqual(lastConfig, thisConfig)) {\n      return transaction;\n    } // Bundle with configuration update\n\n\n    const transactionParts = (() => {\n      if (Array.isArray(transaction)) {\n        return transaction;\n      } else {\n        return [transaction];\n      }\n    })();\n\n    return [...(await wallet.buildUpdateConfigTransaction(lastConfig, false)), ...transactionParts];\n  }\n\n  async sendSignedTransactions(signedTxs, chainId, quote) {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    return wallet.sendSignedTransactions(signedTxs, undefined, quote);\n  } // updateConfig will build an updated config transaction, update the imageHash on-chain and also publish\n  // the wallet config to the authChain. Other chains are lazy-updated on-demand as batched transactions.\n\n\n  async updateConfig(newConfig, index, quote, callback) {\n    const authWallet = this.authWallet().wallet;\n\n    if (!newConfig) {\n      newConfig = authWallet.config;\n    } else {\n      // ensure its normalized\n      newConfig = sortConfig(newConfig);\n    } // The config is the default config, see if the wallet has been deployed\n\n\n    if (isConfigEqual(authWallet.config, newConfig)) {\n      if (!(await this.isDeployed())) {\n        // Deploy the wallet and publish initial configuration\n        return await authWallet.updateConfig(newConfig, undefined, true, index, quote, callback);\n      }\n    } // Get latest config, update only if neccesary\n\n\n    const lastConfig = await this.currentConfig();\n\n    if (isConfigEqual(lastConfig, newConfig)) {\n      return [_extends({}, lastConfig, {\n        address: this.address\n      }), undefined];\n    } // Update to new configuration on the authWallet. Other networks will be lazily updated\n    // once used. The wallet config is also auto-published to the authChain.\n\n\n    const [_, tx] = await authWallet.useConfig(lastConfig).updateConfig(newConfig, undefined, true, index, quote, callback);\n    return [_extends({}, newConfig, {\n      address: this.address\n    }), tx];\n  } // publishConfig will publish the wallet config to the network via the relayer. Publishing\n  // the config will also store the entire object of signers.\n\n\n  publishConfig(indexed) {\n    let requireFreshSigners = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let quote = arguments.length > 2 ? arguments[2] : undefined;\n    let callback = arguments.length > 3 ? arguments[3] : undefined;\n    return this.authWallet().wallet.publishConfig(indexed, undefined, requireFreshSigners, quote, callback);\n  }\n\n  async isDeployed(target) {\n    const wallet = (() => {\n      if (!target) return this.authWallet().wallet;\n\n      if (target.address) {\n        return target;\n      }\n\n      return this.getWalletByNetwork(target).wallet;\n    })();\n\n    return wallet.isDeployed();\n  } // TODO: Split this to it's own class \"configProvider\" or something\n  // this process can be done in different ways (caching, api, utils, etc)\n\n\n  async currentConfig(target) {\n    const wallet = (() => {\n      if (!target) return this.authWallet().wallet;\n\n      if (target.address) {\n        return target;\n      }\n\n      return this.getWalletByNetwork(target).wallet;\n    })();\n\n    return (await this.getConfigFinder().findCurrentConfig({\n      address: this.address,\n      provider: wallet.provider,\n      context: wallet.context,\n      knownConfigs: [wallet.config]\n    })).config;\n  }\n\n  getWallets() {\n    return this._wallets;\n  }\n\n  getWalletByNetwork(chainId) {\n    const networkId = getChainId(chainId);\n\n    const network = this._wallets.find(w => w.network.chainId === networkId);\n\n    if (!network) {\n      throw new Error(`network ${chainId} not found in wallets list`);\n    }\n\n    return network;\n  } // mainWallet is the DefaultChain wallet\n\n\n  mainWallet() {\n    const found = this._wallets.find(w => w.network.isDefaultChain);\n\n    if (!found) {\n      throw new Error('mainWallet not found');\n    }\n\n    return found;\n  } // authWallet is the AuthChain wallet\n\n\n  authWallet() {\n    const found = this._wallets.find(w => w.network.isAuthChain);\n\n    if (!found) {\n      throw new Error('authChain wallet not found');\n    }\n\n    return found;\n  }\n\n  setNetworks(mainnetNetworks) {\n    let testnetNetworks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let defaultChainId = arguments.length > 2 ? arguments[2] : undefined;\n    let networks = [];\n    this._chainId = undefined; // clear memoized value\n    // find chain between mainnet and testnet network groups, and set that network group.\n    // otherwise use mainnetNetworks without changes\n\n    if (defaultChainId) {\n      // force-convert to a number in case someone sends a number in a string like \"1\"\n      const defaultChainIdNum = parseInt(defaultChainId);\n      const foundMainnetNetwork = mainnetNetworks.find(n => n.name === defaultChainId || n.chainId === defaultChainIdNum);\n      const foundTestnetNetwork = testnetNetworks.find(n => n.name === defaultChainId || n.chainId === defaultChainIdNum);\n\n      if (foundMainnetNetwork || foundTestnetNetwork) {\n        if (foundMainnetNetwork) {\n          mainnetNetworks.forEach(n => n.isDefaultChain = false);\n          foundMainnetNetwork.isDefaultChain = true;\n          networks = mainnetNetworks;\n        } else if (foundTestnetNetwork) {\n          testnetNetworks.forEach(n => n.isDefaultChain = false);\n          foundTestnetNetwork.isDefaultChain = true;\n          networks = testnetNetworks;\n        }\n      } else {\n        throw new Error(`unable to set default network as chain '${defaultChainId}' does not exist`);\n      }\n    } else {\n      networks = mainnetNetworks;\n    } // assign while validating network list\n    // TODO - we should remove sortNetworks in the future but this is a breaking change\n\n\n    this.options.networks = ensureValidNetworks(sortNetworks(networks)); // Account/wallet instances using the initial configuration and network list\n    //\n    // TODO: we can make an optimization where if mainnetNetworks and testnetNetworks lists\n    // haven't changed between calls, and only the defaultChainId, as well, the group between\n    // mainnet vs testnet has not changed either -- aka just defaultChainId within a group,\n    // then we can avoid rebuilding all of these objects and instead just sort them\n\n    this._wallets = this.options.networks.map(network => {\n      const wallet = new Wallet({\n        config: this.options.initialConfig,\n        context: this.options.context\n      }, ...this._signers);\n\n      if (network.provider) {\n        wallet.setProvider(network.provider);\n      } else if (network.rpcUrl && network.rpcUrl !== '') {\n        wallet.setProvider(network.rpcUrl);\n      } else {\n        throw new Error(`network config is missing provider settings for chainId ${network.chainId}`);\n      }\n\n      if (isRelayer(network.relayer)) {\n        wallet.setRelayer(network.relayer);\n      } else if (isRpcRelayerOptions(network.relayer)) {\n        wallet.setRelayer(new RpcRelayer(_extends({\n          provider: wallet.provider\n        }, network.relayer)));\n      } else {\n        throw new Error(`network config is missing relayer settings for chainId ${network.chainId}`);\n      }\n\n      if (network.isDefaultChain) {\n        this._chainId = network.chainId;\n        this.provider = wallet.provider;\n      }\n\n      return {\n        network: network,\n        wallet: wallet\n      };\n    }); // return the default chain id as number\n\n    return this.options.networks.find(network => network.isDefaultChain).chainId;\n  }\n\n  connect(_) {\n    throw new Error('connect method is not supported in MultiWallet');\n  }\n\n  signTransaction(_) {\n    throw new Error('signTransaction method is not supported in MultiWallet, please use signTransactions(...)');\n  }\n\n}\n\nasync function isValidSignature(address, digest, sig, provider, walletContext, chainId) {\n  // Check if valid EOA signature\n  //\n  // TODO: the EOA check here assume its being passed a digest, but its not a correct assumption\n  // as often the message signing is of a string of text and not a digest.\n  if (isValidEIP712Signature(address, digest, sig) || isValidEthSignSignature(address, digest, sig)) return true; // Check if valid deployed smart wallet (via erc1271 check)\n\n  const erc1271Check = await isValidContractWalletSignature(address, digest, sig, provider);\n\n  if (erc1271Check === undefined) {\n    // If validity of wallet signature can't be determined\n    // it could be a signature of a non-deployed sequence wallet\n    return isValidSequenceUndeployedWalletSignature(address, digest, sig, walletContext, provider, chainId);\n  }\n\n  return erc1271Check;\n}\n\nfunction isValidEIP712Signature(address, digest, sig) {\n  try {\n    return compareAddr(ethers.utils.recoverAddress(digest, ethers.utils.splitSignature(sig)), address) === 0;\n  } catch (_unused) {\n    return false;\n  }\n}\n\nfunction isValidEthSignSignature(address, digest, sig) {\n  try {\n    const subDigest = ethers.utils.keccak256(ethers.utils.solidityPack(['string', 'bytes32'], ['\\x19Ethereum Signed Message:\\n32', digest]));\n    return compareAddr(ethers.utils.recoverAddress(subDigest, ethers.utils.splitSignature(sig)), address) === 0;\n  } catch (_unused2) {\n    return false;\n  }\n} // Check if valid Smart Contract Wallet signature, via ERC1271\n\n\nasync function isValidContractWalletSignature(address, digest, sig, provider) {\n  if (!provider) return undefined;\n\n  try {\n    if ((await provider.getCode(address)) === '0x') {\n      // Signature validity can't be determined\n      return undefined;\n    }\n\n    const wallet = new ethers.Contract(address, walletContracts.erc1271.abi, provider);\n    const response = await wallet.isValidSignature(digest, sig);\n    return walletContracts.erc1271.returns.isValidSignatureBytes32 === response;\n  } catch (_unused3) {\n    return false;\n  }\n}\n\nasync function isValidSequenceUndeployedWalletSignature(address, digest, sig, walletContext, provider, chainId) {\n  if (!provider && !chainId) return undefined; // Signature validity can't be determined\n\n  if (!walletContext) return undefined; // Signature validity can't be determined\n\n  try {\n    const cid = chainId ? chainId : (await provider.getNetwork()).chainId;\n    const signature = decodeSignature(sig);\n    const subDigest = ethers.utils.arrayify(ethers.utils.keccak256(packMessageData(address, cid, digest)));\n    const config = await recoverConfigFromDigest(subDigest, signature, provider, walletContext, chainId, true);\n    const weight = signature.signers.reduce((v, s) => isDecodedEOASigner(s) || isDecodedFullSigner(s) ? v + s.weight : v, 0);\n    return compareAddr(addressOf(config, walletContext), address) === 0 && weight >= signature.threshold;\n  } catch (_unused4) {\n    return false;\n  }\n}\n\nconst fetchImageHash = async signer => {\n  const address = await signer.getAddress();\n  const walletContract = new Contract(address, walletContracts.mainModuleUpgradable.abi, await signer.getProvider());\n  const currentImageHash = await walletContract.functions.imageHash.call([]).catch(() => []);\n  return currentImageHash && currentImageHash.length > 0 ? currentImageHash[0] : '';\n}; // recoverConfig decodes a WalletConfig from the subDigest and signature combo. Note: the subDigest argument\n// is an encoding format of the original message, encoded by:\n//\n// subDigest = packMessageData(wallet.address, chainId, ethers.utils.keccak256(message))\n\n\nconst recoverConfig = async (subDigest, signature, provider, context, chainId, walletSignersValidation) => {\n  const digest = ethers.utils.arrayify(ethers.utils.keccak256(subDigest));\n  return recoverConfigFromDigest(digest, signature, provider, context, chainId, walletSignersValidation);\n}; // recoverConfigFromDigest decodes a WalletConfig from a digest and signature combo. Note: the digest\n// is the keccak256 of the subDigest, see `recoverConfig` method.\n\n\nconst recoverConfigFromDigest = async (digest, signature, provider, context, chainId, walletSignersValidation) => {\n  const decoded = signature.threshold !== undefined ? signature : decodeSignature(signature);\n  const signers = await Promise.all(decoded.signers.map(async s => {\n    if (isDecodedEOASigner(s)) {\n      return {\n        weight: s.weight,\n        address: recoverEOASigner(digest, s)\n      };\n    } else if (isDecodedAddress(s)) {\n      return {\n        weight: s.weight,\n        address: ethers.utils.getAddress(s.address)\n      };\n    } else if (isDecodedFullSigner(s)) {\n      if (walletSignersValidation) {\n        if (!(await isValidSignature(s.address, ethers.utils.arrayify(digest), ethers.utils.hexlify(s.signature), provider, context, chainId))) throw Error('Invalid signature');\n      }\n\n      return {\n        weight: s.weight,\n        address: s.address\n      };\n    } else {\n      throw Error('Uknown signature type');\n    }\n  }));\n  return {\n    threshold: decoded.threshold,\n    signers: signers\n  };\n};\n\nexport { Account, GuardRemoteSigner, InvalidSigner, LocalRemoteSigner, NotEnoughSigners, RemoteSigner, Signer, Wallet, fetchImageHash, findLatestLog, isSequenceSigner, isValidContractWalletSignature, isValidEIP712Signature, isValidEthSignSignature, isValidSequenceUndeployedWalletSignature, isValidSignature, recoverConfig, recoverConfigFromDigest, resolveArrayProperties };","map":{"version":3,"names":["Signer","Signer$1","ethers","BigNumber","Contract","decodeNonce","computeMetaTxnHash","fromTransactionish","readSequenceNonce","appendNonce","digestOfTransactionsNonce","sequenceTxAbiEncode","isUsableConfig","sortConfig","addressOf","imageHash","isDecodedSigner","encodeSignature","joinSignatures","compareAddr","decodeSignature","isDecodedFullSigner","recoverEOASigner","SequenceUtilsFinder","isConfigEqual","isDecodedEOASigner","isDecodedAddress","ChainId","sequenceContext","isJsonRpcProvider","JsonRpcSender","getChainId","mainnetNetworks","ensureValidNetworks","sortNetworks","Provider","JsonRpcProvider","Interface","walletContracts","encodeTypedDataDigest","subDigestOf","packMessageData","fetchPonyfill","GuarddService","resolveProperties","isRelayer","isRpcRelayerOptions","RpcRelayer","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","isSequenceSigner","cand","signer","updateConfig","undefined","publishConfig","getWalletContext","getWalletConfig","InvalidSigner","Error","NotEnoughSigners","RemoteSigner","signMessage","message","chainId","signMessageWithData","sendTransaction","_","signTransaction","connect","data","isRemoteSigner","GuardRemoteSigner","constructor","address","hostname","isSequence","defaultChainId","MAINNET","_guardd","_address","fetch","auxData","request","msg","utils","hexlify","from","toNumber","res","sign","sig","getAddress","LocalRemoteSigner","_signer","resolveArrayProperties","object","Array","isArray","Promise","all","map","o","findLatestLog","provider","filter","toBlock","getBlockNumber","fromBlock","logs","getLogs","e","pivot","Math","floor","nhalf","Wallet","options","context","config","_signers","sender","relayer","strict","nonStrict","signers","s","isSigner","useConfig","setProvider","setRelayer","useSigners","isProvider","jsonProvider","getProvider","getChainIdNumber","getRelayer","getWalletState","isDeployed","state","deployed","lastImageHash","fetchImageHash","connected","getSigners","then","getNetwork","getNetworks","name","rpcUrl","getNonce","blockTag","space","getTransactionCount","encodedNonce","decodedNonce","transaction","allSigners","quote","callback","signedTxs","signTransactions","metaTxnHash","transactions","relay","sendTransactionBatch","txs","signChainId","stx","find","a","revertOnError","gasLimit","eq","constants","Zero","estimateGasLimits","providedNonce","nonce","digest","signature","sendSignedTransactions","isDigest","startsWith","toUtf8Bytes","signTypedData","domain","types","domainChainId","hash","_signTypedData","subDigest","solvedChainId","arrayify","_this","keccak256","signWith","signersAddr","parts","indexOf","isEOASignature","weight","_unused","err","console","warn","threshold","localSigners","localSignature","packMsgAndSig","totalWeight","reduce","remoteSigners","remoteSignature","signWeight","p","sconfig","c","add","walletCode","getCode","publish","indexed","n","buildUpdateConfigTransaction","requireFreshSigners","buildPublishConfigTransaction","buildPublishSignersTransaction","_this2","isUpgradable","implementation","getStorageAt","defaultAbiCoder","encode","mainModuleUpgradable","_unused2","walletInterface","mainModule","abi","preTransaction","delegateCall","to","value","encodeFunctionData","getFunction","mainModuleInterface","postTransaction","sequenceUtilsInterface","sequenceUtils","_this$context$libs","requireFreshSignersInterface","requireFreshSigner","randomBytes","decodedSignature","filteredSignature","contextRequireFreshSigner","libs","id","connectedChainId","singleOwner","owner","hasEnoughSigners","gte","Account","_wallets","_chainId","networks","setNetworks","forEach","w","wallet","getConfigFinder","configFinder","authWallet","wallets","v","getWalletByNetwork","push","flat","configsPromise","findCurrentConfig","knownConfigs","states","idx","findIndex","getAuthChainId","currentConfig","configs","_configs$i","_this$mainWallet","_this$_wallets$find","mainWallet","network","_this$mainWallet2","_this$_wallets$find2","isAuthChain","thisConfig","lt","toString","signAuthMessage","_this$authWallet","getFeeOptions","updatedTransaction","prependConfigUpdate","finalTransactions","dtransactionish","skipThresholdCheck","lastConfig","transactionParts","newConfig","index","tx","getWallets","networkId","found","isDefaultChain","testnetNetworks","defaultChainIdNum","parseInt","foundMainnetNetwork","foundTestnetNetwork","initialConfig","isValidSignature","walletContext","isValidEIP712Signature","isValidEthSignSignature","erc1271Check","isValidContractWalletSignature","isValidSequenceUndeployedWalletSignature","recoverAddress","splitSignature","solidityPack","erc1271","response","returns","isValidSignatureBytes32","_unused3","cid","recoverConfigFromDigest","_unused4","walletContract","currentImageHash","functions","catch","recoverConfig","walletSignersValidation","decoded"],"sources":["C:/Users/rishi/contract-poc/ThriEstate/Brandvilla/node_modules/@0xsequence/wallet/dist/0xsequence-wallet.esm.js"],"sourcesContent":["import { Signer as Signer$1, ethers, BigNumber, Contract } from 'ethers';\nimport { decodeNonce, computeMetaTxnHash, fromTransactionish, readSequenceNonce, appendNonce, digestOfTransactionsNonce, sequenceTxAbiEncode } from '@0xsequence/transactions';\nimport { isUsableConfig, sortConfig, addressOf, imageHash, isDecodedSigner, encodeSignature, joinSignatures, compareAddr, decodeSignature, isDecodedFullSigner, recoverEOASigner, SequenceUtilsFinder, isConfigEqual, isDecodedEOASigner, isDecodedAddress } from '@0xsequence/config';\nimport { ChainId, sequenceContext, isJsonRpcProvider, JsonRpcSender, getChainId, mainnetNetworks, ensureValidNetworks, sortNetworks } from '@0xsequence/network';\nimport { Provider, JsonRpcProvider } from '@ethersproject/providers';\nimport { Interface } from '@ethersproject/abi';\nimport { walletContracts } from '@0xsequence/abi';\nimport { encodeTypedDataDigest, subDigestOf, packMessageData } from '@0xsequence/utils';\nimport fetchPonyfill from 'fetch-ponyfill';\nimport { GuarddService } from '@0xsequence/guard';\nimport { resolveProperties } from '@ethersproject/properties';\nimport { isRelayer, isRpcRelayerOptions, RpcRelayer } from '@0xsequence/relayer';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nclass Signer extends Signer$1 {\n  static isSequenceSigner(cand) {\n    return isSequenceSigner(cand);\n  }\n\n}\nfunction isSequenceSigner(signer) {\n  const cand = signer;\n  return cand && cand.updateConfig !== undefined && cand.publishConfig !== undefined && cand.getWalletContext !== undefined && cand.getWalletConfig !== undefined;\n} // TODO: move to error.ts, along with others..\n\nclass InvalidSigner extends Error {}\nclass NotEnoughSigners extends Error {}\n\nclass RemoteSigner extends Signer$1 {\n  signMessage(message, chainId) {\n    return this.signMessageWithData(message);\n  }\n\n  sendTransaction(_) {\n    throw new Error('sendTransaction method is not supported in RemoteSigner');\n  }\n\n  signTransaction(_) {\n    throw new Error('signTransaction method is not supported in RemoteSigner');\n  }\n\n  connect(_) {\n    throw new Error('connect method is not supported in RemoteSigner');\n  }\n\n  static signMessageWithData(signer, message, data, chainId) {\n    if (this.isRemoteSigner(signer)) {\n      return signer.signMessageWithData(message, data, chainId);\n    }\n\n    return signer.signMessage(message);\n  }\n\n  static isRemoteSigner(signer) {\n    return signer.signMessageWithData !== undefined;\n  }\n\n}\n\nclass GuardRemoteSigner extends RemoteSigner {\n  constructor(address, hostname, isSequence = false, defaultChainId = ChainId.MAINNET) {\n    super();\n    this.isSequence = isSequence;\n    this.defaultChainId = defaultChainId;\n    this._guardd = void 0;\n    this._address = void 0;\n    this._guardd = new GuarddService(hostname, fetchPonyfill().fetch);\n    this._address = address;\n  }\n\n  async signMessageWithData(message, auxData, chainId) {\n    const request = {\n      msg: ethers.utils.hexlify(message),\n      auxData: ethers.utils.hexlify(auxData ? auxData : []),\n      chainId: chainId ? BigNumber.from(chainId).toNumber() : this.defaultChainId\n    };\n    const res = await this._guardd.sign({\n      request: request\n    }); // TODO: The guardd service doesn't include the EIP2126 signature type on it's reponse\n    // maybe it should be more explicit and include it? the EIP2126 is only required for non-sequence signatures\n\n    return this.isSequence ? res.sig : res.sig + '02';\n  }\n\n  async getAddress() {\n    return this._address;\n  }\n\n}\n\nclass LocalRemoteSigner extends RemoteSigner {\n  constructor(signer) {\n    super();\n    this._signer = void 0;\n    this._signer = signer;\n  }\n\n  signMessageWithData(message, _) {\n    return this._signer.signMessage(message);\n  }\n\n  getAddress() {\n    return this._signer.getAddress();\n  }\n\n}\n\nasync function resolveArrayProperties(object) {\n  if (Array.isArray(object)) {\n    // T must include array type\n    return Promise.all(object.map(o => resolveProperties(o)));\n  }\n\n  return resolveProperties(object);\n}\nasync function findLatestLog(provider, filter) {\n  const toBlock = filter.toBlock === 'latest' ? await provider.getBlockNumber() : filter.toBlock;\n  const fromBlock = filter.fromBlock;\n\n  try {\n    const logs = await provider.getLogs(_extends({}, filter, {\n      toBlock: toBlock\n    }));\n    return logs.length === 0 ? undefined : logs[logs.length - 1];\n  } catch (e) {\n    // TODO Don't assume all errors are bad\n    const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock);\n    const nhalf = await findLatestLog(provider, _extends({}, filter, {\n      fromBlock: pivot,\n      toBlock: toBlock\n    }));\n    if (nhalf !== undefined) return nhalf;\n    return findLatestLog(provider, _extends({}, filter, {\n      fromBlock: fromBlock,\n      toBlock: pivot\n    }));\n  }\n}\n\n//\n// Wallet allows managing the account/wallet sub-keys, wallet address, signing\n// messages, signing transactions and updating/deploying the wallet config on a specific chain.\n//\n// Wallet instances represent a wallet at a particular config-state, in someways, the Wallet\n// instance is immutable, and if you update the config, then you'll need to call useConfig()\n// to instantiate a new Wallet instance with the updated config.\n\nclass Wallet extends Signer {\n  // provider is an Ethereum Json RPC provider that is connected to a particular network (aka chain)\n  // and access to the signer for signing transactions.\n  // sender is a minimal Json RPC sender interface. It's here for convenience for other web3\n  // interfaces to use.\n  // relayer dispatches transactions to an Ethereum node directly\n  // or through a remote transaction Web Service.\n  // chainId is the node network id, used for memoization\n  constructor(options, ...signers) {\n    super();\n    this.context = void 0;\n    this.config = void 0;\n    this._signers = void 0;\n    this.provider = void 0;\n    this.sender = void 0;\n    this.relayer = void 0;\n    this.chainId = void 0;\n    const {\n      config,\n      context,\n      strict\n    } = options;\n\n    if (context) {\n      this.context = _extends({}, context);\n    } else {\n      // default context is to use @0xsequence/network deployed context\n      this.context = _extends({}, sequenceContext);\n    }\n\n    if (strict === true) {\n      this.context.nonStrict = undefined;\n    } else if (strict === false) {\n      this.context.nonStrict = true;\n    }\n\n    if (!this.context.nonStrict && !isUsableConfig(config)) {\n      throw new Error('wallet config is not usable (strict mode)');\n    }\n\n    this.config = sortConfig(config);\n    this._signers = signers.map(s => Signer$1.isSigner(s) ? s : new ethers.Wallet(s)); // cache wallet config for future imageHash lookups\n\n    this.imageHash;\n  } // useConfig creates a new Wallet instance with the provided config, and uses the current provider\n  // and relayer. It's common to initialize a counter-factual / undeployed wallet by initializing\n  // it with the Wallet's init config, then calling useConfig() with the most-up-to-date config,\n  // ie. new Wallet({ config: initConfig }).useConfig(latestConfig).useSigners(signers)\n\n\n  useConfig(config, strict) {\n    return new Wallet({\n      config,\n      context: this.context,\n      strict\n    }, ...this._signers).setProvider(this.provider).setRelayer(this.relayer);\n  }\n\n  useSigners(...signers) {\n    return new Wallet({\n      config: this.config,\n      context: this.context\n    }, ...signers).setProvider(this.provider).setRelayer(this.relayer);\n  } // connect is a short-hand to create an Account instance and set the provider and relayer.\n  //\n  // The connect method is defined on the AbstractSigner as connect(Provider): AbstractSigner\n\n\n  connect(provider, relayer) {\n    if (isJsonRpcProvider(provider)) {\n      return new Wallet({\n        config: this.config,\n        context: this.context\n      }, ...this._signers).setProvider(provider).setRelayer(relayer);\n    } else {\n      throw new Error('Wallet provider argument is expected to be a JsonRpcProvider');\n    }\n  } // setProvider assigns a json-rpc provider to this wallet instance\n\n\n  setProvider(provider) {\n    if (provider === undefined) return this;\n\n    if (Provider.isProvider(provider)) {\n      this.provider = provider;\n      this.sender = new JsonRpcSender(provider);\n    } else {\n      const jsonProvider = new JsonRpcProvider(provider);\n      this.provider = jsonProvider;\n      this.sender = new JsonRpcSender(jsonProvider);\n    }\n\n    this.chainId = undefined; // reset chainId value\n\n    return this;\n  } // setRelayer assigns a Sequence transaction relayer to this wallet instance\n\n\n  setRelayer(relayer) {\n    if (relayer === undefined) return this;\n    this.relayer = relayer;\n    return this;\n  }\n\n  async getProvider(chainId) {\n    if (chainId) await this.getChainIdNumber(chainId);\n    return this.provider;\n  }\n\n  async getRelayer(chainId) {\n    if (chainId) await this.getChainIdNumber(chainId);\n    return this.relayer;\n  }\n\n  async getWalletContext() {\n    return this.context;\n  }\n\n  async getWalletConfig(chainId) {\n    chainId = await this.getChainIdNumber(chainId);\n\n    const config = _extends({}, this.config, {\n      chainId\n    });\n\n    return [config];\n  }\n\n  async getWalletState(_) {\n    const [address, chainId, isDeployed] = await Promise.all([this.getAddress(), this.getChainId(), this.isDeployed()]);\n    const state = {\n      context: this.context,\n      config: this.config,\n      address: address,\n      chainId: chainId,\n      deployed: isDeployed,\n      imageHash: this.imageHash,\n      lastImageHash: isDeployed ? await fetchImageHash(this) : undefined\n    }; // TODO: set published boolean by checking if we have the latest logs\n    // that compute to the same hash as in lastImageHash\n\n    return [state];\n  } // connected reports if json-rpc provider has been connected\n\n\n  get connected() {\n    return this.sender !== undefined;\n  } // address returns the address of the wallet account address\n\n\n  get address() {\n    return addressOf(this.config, this.context);\n  } // imageHash is the unique hash of the WalletConfig\n\n\n  get imageHash() {\n    return imageHash(this.config);\n  } // getAddress returns the address of the wallet account address\n  //\n  // The getAddress method is defined on the AbstractSigner\n\n\n  async getAddress() {\n    return this.address;\n  } // getSigners returns the list of public account addresses to the currently connected\n  // signer objects for this wallet. Note: for a complete list of configured signers\n  // on the wallet, query getWalletConfig()\n\n\n  async getSigners() {\n    if (!this._signers || this._signers.length === 0) {\n      return [];\n    }\n\n    return Promise.all(this._signers.map(s => s.getAddress().then(s => ethers.utils.getAddress(s))));\n  } // chainId returns the network connected to this wallet instance\n\n\n  async getChainId() {\n    if (this.chainId) return this.chainId;\n\n    if (!this.provider) {\n      throw new Error('provider is not set, first connect a provider');\n    }\n\n    this.chainId = (await this.provider.getNetwork()).chainId;\n    return this.chainId;\n  }\n\n  async getNetworks() {\n    const chainId = await this.getChainId();\n    return [{\n      chainId: chainId,\n      name: '',\n      rpcUrl: ''\n    }];\n  } // getNonce returns the transaction nonce for this wallet, via the relayer\n\n\n  async getNonce(blockTag, space) {\n    return this.relayer.getNonce(this.config, this.context, space, blockTag);\n  } // getTransactionCount returns the number of transactions (aka nonce)\n  //\n  // getTransactionCount method is defined on the AbstractSigner\n\n\n  async getTransactionCount(blockTag) {\n    const encodedNonce = await this.getNonce(blockTag, 0);\n    const [_, decodedNonce] = decodeNonce(encodedNonce);\n    return ethers.BigNumber.from(decodedNonce).toNumber();\n  } // sendTransaction will dispatch the transaction to the relayer for submission to the network.\n\n\n  async sendTransaction(transaction, chainId, allSigners, quote, callback) {\n    const signedTxs = await this.signTransactions(transaction, chainId, allSigners);\n\n    if (callback) {\n      const address = addressOf(signedTxs.config, signedTxs.context);\n      const metaTxnHash = computeMetaTxnHash(address, signedTxs.chainId, ...signedTxs.transactions);\n      callback(signedTxs, metaTxnHash);\n    }\n\n    return this.relayer.relay(signedTxs, quote);\n  } // sendTransactionBatch is a sugar for better readability, but is the same as sendTransaction\n\n\n  async sendTransactionBatch(transactions, chainId, allSigners = true, quote, callback) {\n    return this.sendTransaction(transactions, chainId, allSigners, quote, callback);\n  } // signTransactions will sign a Sequence transaction with the wallet signers\n  //\n  // NOTE: the txs argument of type Transactionish can accept one or many transactions.\n\n\n  async signTransactions(txs, chainId, allSigners) {\n    const signChainId = await this.getChainIdNumber(chainId);\n    const transaction = await resolveArrayProperties(txs);\n\n    if (!this.provider) {\n      throw new Error('missing provider');\n    }\n\n    if (!this.relayer) {\n      throw new Error('missing relayer');\n    } // Convert Transactionish into Sequence transactions\n\n\n    let stx = await fromTransactionish(this.context, this.address, transaction); // If a transaction has 0 gasLimit and not revertOnError\n    // compute all new gas limits\n\n    if (stx.find(a => !a.revertOnError && ethers.BigNumber.from(a.gasLimit || 0).eq(ethers.constants.Zero))) {\n      stx = await this.relayer.estimateGasLimits(this.config, this.context, ...stx);\n    } // If provided nonce append it to all other transactions\n    // otherwise get next nonce for this wallet\n\n\n    const providedNonce = readSequenceNonce(...stx);\n    const nonce = providedNonce ? providedNonce : await this.getNonce();\n    stx = appendNonce(stx, nonce); // Get transactions digest\n\n    const digest = digestOfTransactionsNonce(nonce, ...stx); // Bundle with signature\n\n    return {\n      digest: digest,\n      chainId: signChainId,\n      context: this.context,\n      config: this.config,\n      transactions: stx,\n      nonce,\n      signature: await this.sign(digest, true, chainId, allSigners)\n    };\n  }\n\n  async sendSignedTransactions(signedTxs, chainId, quote) {\n    if (!this.relayer) {\n      throw new Error('relayer is not set, first connect a relayer');\n    }\n\n    await this.getChainIdNumber(chainId);\n    return this.relayer.relay(signedTxs, quote);\n  } // signMessage will sign a message for a particular chainId with the wallet signers\n  //\n  // NOTE: signMessage(message: Bytes | string): Promise<string> is defined on AbstractSigner\n\n\n  async signMessage(message, chainId, allSigners, isDigest = false) {\n    const data = typeof message === 'string' && !message.startsWith('0x') ? ethers.utils.toUtf8Bytes(message) : message;\n    return this.sign(data, isDigest, chainId, allSigners);\n  }\n\n  async signTypedData(domain, types, message, chainId, allSigners) {\n    const signChainId = await this.getChainIdNumber(chainId);\n    const domainChainId = domain.chainId ? BigNumber.from(domain.chainId).toNumber() : undefined;\n\n    if (domainChainId && domainChainId !== signChainId) {\n      throw new Error(`signTypedData: domain.chainId (${domain.chainId}) is expected to be ${signChainId}`);\n    }\n\n    const hash = encodeTypedDataDigest({\n      domain,\n      types,\n      message\n    });\n    return this.sign(hash, true, signChainId, allSigners);\n  }\n\n  async _signTypedData(domain, types, message, chainId, allSigners) {\n    return this.signTypedData(domain, types, message, chainId, allSigners);\n  }\n\n  async subDigest(digest, chainId) {\n    const solvedChainId = await this.getChainIdNumber(chainId);\n    return ethers.utils.arrayify(subDigestOf(this.address, solvedChainId, digest));\n  } // sign is a helper method to sign a payload with the wallet signers\n\n\n  async sign(msg, isDigest = true, chainId, allSigners) {\n    var _this = this;\n\n    const signChainId = await this.getChainIdNumber(chainId);\n    const digest = isDigest ? msg : ethers.utils.keccak256(msg); // Generate sub-digest\n\n    const subDigest = await this.subDigest(digest, chainId); // Sign sub-digest using a set of signers and some optional data\n\n    const signWith = async function signWith(signers, auxData) {\n      const signersAddr = await Promise.all(signers.map(s => s.getAddress()));\n      const parts = await Promise.all(_this.config.signers.map(async function (s) {\n        try {\n          const signer = signers[signersAddr.indexOf(s.address)]; // Is not a signer, return config entry as-is\n\n          if (!signer) {\n            return s;\n          } // Is another Sequence wallet as signer, sign and append '03' (ERC1271 type)\n\n\n          if (isSequenceSigner(signer)) {\n            if (signer === _this) throw Error(\"Can't sign transactions for self\");\n            const signature = (await signer.signMessage(subDigest, signChainId, allSigners, true)) + '03';\n            return _extends({}, s, {\n              signature: signature\n            });\n          } // Is remote signer, call and deduce signature type\n\n\n          if (RemoteSigner.isRemoteSigner(signer)) {\n            const signature = await signer.signMessageWithData(subDigest, auxData, signChainId);\n\n            try {\n              // Check if signature can be recovered as EOA signature\n              const isEOASignature = recoverEOASigner(subDigest, {\n                weight: s.weight,\n                signature: signature\n              }) === s.address;\n\n              if (isEOASignature) {\n                // Exclude address on EOA signatures\n                return {\n                  weight: s.weight,\n                  signature: signature\n                };\n              }\n            } catch (_unused) {} // Prepare signature for full encoding\n\n\n            return _extends({}, s, {\n              signature: signature\n            });\n          } // Is EOA signer\n\n\n          return {\n            weight: s.weight,\n            signature: (await signer.signMessage(subDigest)) + '02'\n          };\n        } catch (err) {\n          if (allSigners) {\n            throw err;\n          } else {\n            console.warn(`Skipped signer ${s.address}`);\n            return s;\n          }\n        }\n      }));\n      return {\n        threshold: _this.config.threshold,\n        signers: parts\n      };\n    }; // Sign message first using localSigners\n\n\n    const localSigners = this._signers.filter(s => !RemoteSigner.isRemoteSigner(s));\n\n    const localSignature = await signWith(localSigners, this.packMsgAndSig(digest, [], signChainId)); // Skip remote signers if we already meet threshold\n\n    const totalWeight = localSignature.signers.filter(isDecodedSigner).reduce((totalWeight, signer) => totalWeight + signer.weight, 0);\n\n    if (totalWeight >= this.config.threshold) {\n      return encodeSignature(localSignature);\n    } // include local signatures for remote signers\n\n\n    const remoteSigners = this._signers.filter(s => RemoteSigner.isRemoteSigner(s));\n\n    const remoteSignature = await signWith(remoteSigners, this.packMsgAndSig(digest, encodeSignature(localSignature), signChainId)); // Aggregate both local and remote signatures\n\n    return encodeSignature(joinSignatures(localSignature, remoteSignature));\n  } // signWeight will return the total weight of all signers available based on the config\n\n\n  async signWeight() {\n    const signers = await this.getSigners();\n    return signers.reduce((p, s) => {\n      const sconfig = this.config.signers.find(c => c.address === s);\n      if (!sconfig) return p;\n      return p.add(sconfig.weight);\n    }, ethers.constants.Zero);\n  }\n\n  async isDeployed(chainId) {\n    await this.getChainIdNumber(chainId);\n    const walletCode = await this.provider.getCode(this.address);\n    return !!walletCode && walletCode !== '0x';\n  } // updateConfig will build an updated config transaction and send it to the Ethereum\n  // network via the relayer. Note, the updated wallet config is stored as an image hash,\n  // unlike `publishConfig` which will store the entire WalletConfig object in logs.\n\n\n  async updateConfig(config, nonce, publish = false, indexed, quote, callback) {\n    if (!config) config = this.config;\n    const [txs, n] = await Promise.all([this.buildUpdateConfigTransaction(config, publish, indexed), nonce != null ? nonce : this.getNonce()]);\n    return [_extends({\n      address: this.address\n    }, config), await this.sendTransaction(appendNonce(txs, n), undefined, undefined, quote, callback)];\n  } // publishConfig will publish the current wallet config to the network via the relayer.\n  // Publishing the config will also store the entire object of signers.\n\n\n  async publishConfig(indexed, nonce, requireFreshSigners = [], quote, callback) {\n    return this.sendTransaction(this.config.address ? this.buildPublishConfigTransaction(this.config, indexed, nonce) : await this.buildPublishSignersTransaction(indexed, nonce, requireFreshSigners), undefined, undefined, quote, callback);\n  } // buildUpdateConfigTransaction creates a transaction to update the imageHash of the wallet's config\n  // on chain. Note, the transaction is not sent to the network by this method.\n  //\n  // The `publish` argument when true will also store the contents of the WalletConfig to a chain's logs.\n\n\n  async buildUpdateConfigTransaction(config, publish = false, indexed) {\n    var _this2 = this;\n\n    if (!this.context.nonStrict && !isUsableConfig(config)) throw new Error('wallet config is not usable (strict mode)');\n    const isUpgradable = await async function () {\n      try {\n        const implementation = await _this2.provider.getStorageAt(_this2.address, ethers.utils.defaultAbiCoder.encode(['address'], [_this2.address]));\n        return compareAddr(implementation, _this2.context.mainModuleUpgradable) === 0;\n      } catch (_unused2) {\n        return false;\n      }\n    }();\n    const walletInterface = new Interface(walletContracts.mainModule.abi); // empirically, this seems to work for the tests:\n    // const gasLimit = 100000 + 1800 * config.signers.length\n    //\n    // but we're going to play it safe with this instead:\n\n    const gasLimit = 2 * (100000 + 1800 * config.signers.length);\n    const preTransaction = isUpgradable ? [] : [{\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: this.address,\n      value: ethers.constants.Zero,\n      data: walletInterface.encodeFunctionData(walletInterface.getFunction('updateImplementation'), [this.context.mainModuleUpgradable])\n    }];\n    const mainModuleInterface = new Interface(walletContracts.mainModuleUpgradable.abi);\n    const transaction = {\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: this.address,\n      value: ethers.constants.Zero,\n      data: mainModuleInterface.encodeFunctionData(mainModuleInterface.getFunction('updateImageHash'), [imageHash(config)])\n    };\n    const postTransaction = publish ? await this.buildPublishConfigTransaction(config, indexed) : [];\n    const transactions = [...preTransaction, transaction, ...postTransaction]; // If update config reguires a single transaction\n    // skip nested selfExecute bundle\n\n    if (transactions.length === 1) {\n      return transactions;\n    }\n\n    return [{\n      delegateCall: false,\n      revertOnError: false,\n      gasLimit: gasLimit,\n      to: this.address,\n      value: ethers.constants.Zero,\n      data: walletInterface.encodeFunctionData(walletInterface.getFunction('selfExecute'), [sequenceTxAbiEncode(transactions)])\n    }];\n  }\n\n  buildPublishConfigTransaction(config, indexed = true, nonce) {\n    const sequenceUtilsInterface = new Interface(walletContracts.sequenceUtils.abi);\n    return [{\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: this.context.sequenceUtils,\n      value: ethers.constants.Zero,\n      nonce: nonce,\n      data: sequenceUtilsInterface.encodeFunctionData(sequenceUtilsInterface.getFunction('publishConfig'), [this.address, config.threshold, sortConfig(config).signers.map(s => ({\n        weight: s.weight,\n        signer: s.address\n      })), indexed])\n    }];\n  }\n\n  async buildPublishSignersTransaction(indexed = true, nonce, requireFreshSigners = []) {\n    var _this$context$libs;\n\n    const sequenceUtilsInterface = new Interface(walletContracts.sequenceUtils.abi);\n    const requireFreshSignersInterface = new Interface(walletContracts.requireFreshSigner.abi);\n    const message = ethers.utils.randomBytes(32);\n    const signature = await this.signMessage(message, this.chainId, false); // TODO: This is only required because RequireUtils doesn't support dynamic signatures\n    // remove this filtering of dynamic once a new version of RequireUtils is deployed\n\n    const decodedSignature = decodeSignature(signature);\n    const filteredSignature = encodeSignature({\n      threshold: decodedSignature.threshold,\n      signers: decodedSignature.signers.map((s, i) => {\n        if (isDecodedFullSigner(s)) {\n          const a = this.config.signers[i];\n          return {\n            weight: a.weight,\n            address: a.address\n          };\n        }\n\n        return s;\n      })\n    });\n    const contextRequireFreshSigner = (_this$context$libs = this.context.libs) == null ? void 0 : _this$context$libs.requireFreshSigner;\n\n    if (requireFreshSigners.length > 0 && contextRequireFreshSigner === undefined) {\n      throw Error('requireFreshSigners missing library');\n    }\n\n    return [...requireFreshSigners.map(signer => ({\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: contextRequireFreshSigner,\n      value: ethers.constants.Zero,\n      nonce: nonce,\n      data: requireFreshSignersInterface.encodeFunctionData(requireFreshSignersInterface.getFunction('requireFreshSigner'), [signer])\n    })), {\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: this.context.sequenceUtils,\n      value: ethers.constants.Zero,\n      nonce: nonce,\n      data: sequenceUtilsInterface.encodeFunctionData(sequenceUtilsInterface.getFunction('publishInitialSigners'), [this.address, ethers.utils.keccak256(message), this.config.signers.length, filteredSignature, indexed])\n    }];\n  } // getChainIdFromArgument will return the chainId of the argument, as well as ensure\n  // we're not providing an invalid chainId that isn't connected to this wallet.\n\n\n  async getChainIdNumber(chainId) {\n    if (!chainId) {\n      // it's valid for chainId argument to be undefined, in which case\n      // we will use the connected value\n      return await this.getChainId();\n    }\n\n    const id = getChainId(chainId);\n\n    if (this.context.nonStrict) {\n      // in non-strict mode, just return the chainId from argument\n      return id;\n    }\n\n    const connectedChainId = await this.getChainId();\n\n    if (connectedChainId !== id) {\n      throw new Error(`the specified chainId ${id} does not match the wallet's connected chainId ${connectedChainId}`);\n    }\n\n    return connectedChainId;\n  } // packMsgAndSig is used by RemoteSigners to include details as a string blob of data.\n\n\n  packMsgAndSig(msg, sig, chainId) {\n    return ethers.utils.defaultAbiCoder.encode(['address', 'uint256', 'bytes', 'bytes'], [this.address, chainId, msg, sig]);\n  }\n\n  signTransaction(_) {\n    throw new Error('signTransaction method is not supported in Wallet, please use signTransactions(...)');\n  } // singleOwner will create a Wallet instance with a single signer (ie. from a single EOA account)\n\n\n  static async singleOwner(owner, context) {\n    const signer = Signer$1.isSigner(owner) ? owner : new ethers.Wallet(owner);\n    const config = {\n      threshold: 1,\n      signers: [{\n        weight: 1,\n        address: ethers.utils.getAddress(await signer.getAddress())\n      }]\n    };\n    return new Wallet({\n      config,\n      context\n    }, signer);\n  }\n\n  async hasEnoughSigners(chainId) {\n    if (chainId) await this.getChainIdNumber(chainId);\n    return (await this.signWeight()).gte(this.config.threshold);\n  }\n\n}\n\n// Account is an interface to a multi-network smart contract wallet.\nclass Account extends Signer {\n  // provider points at the main chain for compatability with the Signer.\n  // Use getProvider(chainId) to get the provider for the respective network.\n  // memoized value\n  constructor(options, ...signers) {\n    super();\n    this.options = void 0;\n    this._wallets = void 0;\n    this._signers = void 0;\n    this.provider = void 0;\n    this._chainId = void 0;\n    this.options = options;\n    this._signers = signers; // Use deployed wallet context by default if not provided\n\n    if (!options.context) this.options.context = _extends({}, sequenceContext); // Network config, defaults will be used if none are provided\n\n    if (this.options.networks) {\n      this.setNetworks(this.options.networks);\n    } else {\n      this.setNetworks([...mainnetNetworks]);\n    }\n  }\n\n  useSigners(...signers) {\n    this._signers = signers;\n\n    this._wallets.forEach(w => {\n      w.wallet = w.wallet.useSigners(...signers);\n    });\n\n    return this;\n  }\n\n  async getWalletContext() {\n    return this.options.context;\n  }\n\n  getConfigFinder() {\n    if (this.options.configFinder) return this.options.configFinder;\n    return new SequenceUtilsFinder(this.authWallet().wallet.provider);\n  } // getWalletConfig builds a list of WalletConfigs across all networks.\n  // This is useful to shows all keys/devices connected to a wallet across networks.\n\n\n  async getWalletConfig(chainId) {\n    let wallets = [];\n\n    if (chainId) {\n      const v = this.getWalletByNetwork(chainId);\n\n      if (v) {\n        wallets.push(v);\n      }\n    } else {\n      wallets = this._wallets;\n    }\n\n    return (await Promise.all(wallets.map(w => w.wallet.getWalletConfig()))).flat();\n  }\n\n  async getWalletState(chainId) {\n    let wallets = [];\n\n    if (chainId) {\n      const v = this.getWalletByNetwork(chainId);\n\n      if (v) {\n        wallets.push(v);\n      }\n    } else {\n      wallets = this._wallets;\n    }\n\n    const configsPromise = Promise.all(wallets.map(w => this.getConfigFinder().findCurrentConfig({\n      address: w.wallet.address,\n      provider: w.wallet.provider,\n      context: w.wallet.context,\n      knownConfigs: [w.wallet.config]\n    })));\n    const states = (await Promise.all(wallets.map(w => w.wallet.getWalletState()))).flat(); // fetch the current config for the AuthChain, as it will be available\n\n    const idx = states.findIndex(s => s.chainId === this.getAuthChainId());\n\n    if (idx >= 0) {\n      states[idx].config = await this.currentConfig(wallets[idx].wallet);\n    }\n\n    const configs = await configsPromise;\n    return states.map((s, i) => {\n      var _configs$i;\n\n      return _extends({}, s, {\n        config: (_configs$i = configs[i]) == null ? void 0 : _configs$i.config\n      });\n    });\n  } // address getter\n\n\n  get address() {\n    return this._wallets[0].wallet.address;\n  } // getAddress returns the address of the wallet -- note the account address is the same\n  // across all wallets on all different networks\n\n\n  getAddress() {\n    return this._wallets[0].wallet.getAddress();\n  } // getSigners returns the multi-sig signers with permission to control the wallet\n\n\n  async getSigners() {\n    return this._wallets[0].wallet.getSigners();\n  }\n\n  async getProvider(chainId) {\n    var _this$mainWallet, _this$_wallets$find;\n\n    if (!chainId) return (_this$mainWallet = this.mainWallet()) == null ? void 0 : _this$mainWallet.wallet.getProvider();\n    return (_this$_wallets$find = this._wallets.find(w => w.network.chainId === chainId)) == null ? void 0 : _this$_wallets$find.wallet.getProvider();\n  }\n\n  async getRelayer(chainId) {\n    var _this$mainWallet2, _this$_wallets$find2;\n\n    if (!chainId) return (_this$mainWallet2 = this.mainWallet()) == null ? void 0 : _this$mainWallet2.wallet.getRelayer();\n    return (_this$_wallets$find2 = this._wallets.find(w => w.network.chainId === chainId)) == null ? void 0 : _this$_wallets$find2.wallet.getRelayer();\n  }\n\n  async getNetworks() {\n    return this.options.networks;\n  } // NOTE: this is copied over on top of ethers, and is memoized\n\n\n  async getChainId() {\n    if (this._chainId) return this._chainId;\n    const network = await this.provider.getNetwork();\n    this._chainId = network.chainId;\n    return this._chainId;\n  }\n\n  getAuthChainId() {\n    try {\n      return this.options.networks.find(network => network.isAuthChain).chainId;\n    } catch (_unused) {\n      throw new Error('no auth network');\n    }\n  }\n\n  async signMessage(message, target, allSigners = true, isDigest = false) {\n    var _this = this;\n\n    let {\n      wallet\n    } = await async function () {\n      // eslint-disable-line\n      if (!target) {\n        return _this.mainWallet();\n      }\n\n      if (target.address) {\n        const chainId = await target.getChainId();\n        return _this.getWalletByNetwork(chainId);\n      }\n\n      return _this.getWalletByNetwork(target);\n    }(); // Fetch the latest config of the wallet.\n    //\n    // We skip this step if wallet is authWallet. The assumption is that authWallet\n    // will already have the latest config, but lets confirm that.\n    // TODO: instead, memoize the currentConfig, as below will break\n    // if we skip\n    // if (!network.isAuthChain) {\n\n    let thisConfig = await this.currentConfig(wallet);\n    thisConfig = thisConfig ? thisConfig : this._wallets[0].wallet.config;\n    wallet = wallet.useConfig(thisConfig); // }\n    // See if wallet and available signers set has enough signer power,\n    // but if allSigners is false, we allow partial signing\n\n    const weight = await wallet.signWeight();\n\n    if (weight.lt(wallet.config.threshold) && allSigners !== false) {\n      throw new NotEnoughSigners(`Sign message - wallet combined weight ${weight.toString()} below required ${wallet.config.threshold.toString()}`);\n    }\n\n    return wallet.signMessage(message, undefined, allSigners, isDigest);\n  } // TODO: should allSigners default to false here..?\n\n\n  async signAuthMessage(message, allSigners = true, isDigest = false) {\n    var _this$authWallet;\n\n    return this.signMessage(message, (_this$authWallet = this.authWallet()) == null ? void 0 : _this$authWallet.wallet, allSigners, isDigest);\n  }\n\n  async signTypedData(domain, types, message, chainId, allSigners = true) {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    const digest = encodeTypedDataDigest({\n      domain,\n      types,\n      message\n    });\n    return this.signMessage(digest, wallet, allSigners, true);\n  }\n\n  async _signTypedData(domain, types, message, chainId, allSigners = true) {\n    return this.signTypedData(domain, types, message, chainId, allSigners);\n  }\n\n  async hasEnoughSigners(chainId) {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    const thisConfig = await this.currentConfig(wallet);\n    return wallet.useConfig(thisConfig).hasEnoughSigners();\n  }\n\n  async getFeeOptions(transaction, chainId, allSigners = true) {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    const context = this.options.context;\n\n    if (!context) {\n      throw new Error(`missing wallet context`);\n    } // TODO: can we avoid calling `this.currentConfig(wallet)` everytime here.. this is an expensive\n    // operations and we shouldn't be doing it so liberally. What is the minimum information we require here..?\n    // and what is the config used for, and how can we optimize..?\n    // TODO: prependConfigUpdate also looks like its calling currentConfig() again, so we're doubling this.\n    // A few thoughts.. first off, we must add some kind of memoization for this, but with great care, because\n    // the config might change. This make me think we need some king of \"ConfigSource\" class, or \"ConfigXXX\" (name?),\n    // which we can ask to give us a wallet config. This config would also be used when we update/change a config,\n    // such that it can memoize, but also since its the sole interface, it will also properly expire or update the config\n    // in cache as necessary. Further to this, I think we need to only get config details for what is required, and try\n    // to optimize by using imageHashes of the config everywhere, as this is a much more inexpensive value to fetch.\n\n\n    const [config, updatedTransaction] = await Promise.all([this.currentConfig(wallet), this.prependConfigUpdate(transaction, chainId, allSigners, true)]);\n\n    if (!config) {\n      throw new Error(`missing current config for chain ${chainId}`);\n    }\n\n    const finalTransactions = await fromTransactionish(context, this.address, updatedTransaction);\n    return wallet.relayer.getFeeOptions(config, context, ...finalTransactions);\n  }\n\n  async sendTransaction(dtransactionish, chainId, allSigners = true, quote, callback) {\n    const signedTxs = await this.signTransactions(dtransactionish, chainId, allSigners);\n\n    if (callback) {\n      const address = addressOf(signedTxs.config, signedTxs.context);\n      const metaTxnHash = computeMetaTxnHash(address, signedTxs.chainId, ...signedTxs.transactions);\n      callback(signedTxs, metaTxnHash);\n    }\n\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    return wallet.sendSignedTransactions(signedTxs, chainId, quote);\n  }\n\n  async sendTransactionBatch(transactions, chainId, allSigners = true, quote, callback) {\n    return this.sendTransaction(transactions, chainId, allSigners, quote, callback);\n  }\n\n  async signTransactions(dtransactionish, chainId, allSigners) {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    let currentConfig = await this.currentConfig(wallet);\n\n    if (!currentConfig) {\n      currentConfig = await this.currentConfig();\n\n      if (!currentConfig) {\n        throw new Error('missing auth chain config');\n      }\n    }\n\n    const transactions = await this.prependConfigUpdate(dtransactionish, chainId, allSigners);\n    return wallet.useConfig(currentConfig).signTransactions(transactions);\n  }\n\n  async prependConfigUpdate(dtransactionish, chainId, allSigners, skipThresholdCheck) {\n    const transaction = await resolveArrayProperties(dtransactionish);\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet; // TODO: Skip this step if wallet is authWallet\n\n    const [thisConfig, lastConfig] = await Promise.all([this.currentConfig(wallet), this.currentConfig()]); // We have to skip the threshold check during fee estimation because we\n    // might not have the necessary signers until the wallet actually signs the\n    // transactions.\n    //\n    // By design, the Torus login key only exists in memory in Sequence wallet\n    // and cannot generally be assumed to be available. However the Torus login\n    // key might be required in order to transact on other non-auth chains,\n    // because the wallet config might not recognize the current session's\n    // signing key. In these cases, the Torus key is retrieved when the user\n    // confirms the transaction, which happens after fee estimation. So the\n    // wallet might not meet the threshold during fee estimation despite\n    // meeting it at confirmation time.\n\n    if (!skipThresholdCheck) {\n      // See if wallet has enough signer power\n      const weight = await wallet.useConfig(thisConfig).signWeight();\n\n      if (weight.lt(thisConfig.threshold) && allSigners) {\n        throw new NotEnoughSigners(`wallet combined weight ${weight.toString()} below required threshold ${thisConfig.threshold.toString()}`);\n      }\n    } // If the wallet is updated, just sign as-is\n\n\n    if ((await wallet.isDeployed()) && isConfigEqual(lastConfig, thisConfig)) {\n      return transaction;\n    } // Bundle with configuration update\n\n\n    const transactionParts = (() => {\n      if (Array.isArray(transaction)) {\n        return transaction;\n      } else {\n        return [transaction];\n      }\n    })();\n\n    return [...(await wallet.buildUpdateConfigTransaction(lastConfig, false)), ...transactionParts];\n  }\n\n  async sendSignedTransactions(signedTxs, chainId, quote) {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    return wallet.sendSignedTransactions(signedTxs, undefined, quote);\n  } // updateConfig will build an updated config transaction, update the imageHash on-chain and also publish\n  // the wallet config to the authChain. Other chains are lazy-updated on-demand as batched transactions.\n\n\n  async updateConfig(newConfig, index, quote, callback) {\n    const authWallet = this.authWallet().wallet;\n\n    if (!newConfig) {\n      newConfig = authWallet.config;\n    } else {\n      // ensure its normalized\n      newConfig = sortConfig(newConfig);\n    } // The config is the default config, see if the wallet has been deployed\n\n\n    if (isConfigEqual(authWallet.config, newConfig)) {\n      if (!(await this.isDeployed())) {\n        // Deploy the wallet and publish initial configuration\n        return await authWallet.updateConfig(newConfig, undefined, true, index, quote, callback);\n      }\n    } // Get latest config, update only if neccesary\n\n\n    const lastConfig = await this.currentConfig();\n\n    if (isConfigEqual(lastConfig, newConfig)) {\n      return [_extends({}, lastConfig, {\n        address: this.address\n      }), undefined];\n    } // Update to new configuration on the authWallet. Other networks will be lazily updated\n    // once used. The wallet config is also auto-published to the authChain.\n\n\n    const [_, tx] = await authWallet.useConfig(lastConfig).updateConfig(newConfig, undefined, true, index, quote, callback);\n    return [_extends({}, newConfig, {\n      address: this.address\n    }), tx];\n  } // publishConfig will publish the wallet config to the network via the relayer. Publishing\n  // the config will also store the entire object of signers.\n\n\n  publishConfig(indexed, requireFreshSigners = [], quote, callback) {\n    return this.authWallet().wallet.publishConfig(indexed, undefined, requireFreshSigners, quote, callback);\n  }\n\n  async isDeployed(target) {\n    const wallet = (() => {\n      if (!target) return this.authWallet().wallet;\n\n      if (target.address) {\n        return target;\n      }\n\n      return this.getWalletByNetwork(target).wallet;\n    })();\n\n    return wallet.isDeployed();\n  } // TODO: Split this to it's own class \"configProvider\" or something\n  // this process can be done in different ways (caching, api, utils, etc)\n\n\n  async currentConfig(target) {\n    const wallet = (() => {\n      if (!target) return this.authWallet().wallet;\n\n      if (target.address) {\n        return target;\n      }\n\n      return this.getWalletByNetwork(target).wallet;\n    })();\n\n    return (await this.getConfigFinder().findCurrentConfig({\n      address: this.address,\n      provider: wallet.provider,\n      context: wallet.context,\n      knownConfigs: [wallet.config]\n    })).config;\n  }\n\n  getWallets() {\n    return this._wallets;\n  }\n\n  getWalletByNetwork(chainId) {\n    const networkId = getChainId(chainId);\n\n    const network = this._wallets.find(w => w.network.chainId === networkId);\n\n    if (!network) {\n      throw new Error(`network ${chainId} not found in wallets list`);\n    }\n\n    return network;\n  } // mainWallet is the DefaultChain wallet\n\n\n  mainWallet() {\n    const found = this._wallets.find(w => w.network.isDefaultChain);\n\n    if (!found) {\n      throw new Error('mainWallet not found');\n    }\n\n    return found;\n  } // authWallet is the AuthChain wallet\n\n\n  authWallet() {\n    const found = this._wallets.find(w => w.network.isAuthChain);\n\n    if (!found) {\n      throw new Error('authChain wallet not found');\n    }\n\n    return found;\n  }\n\n  setNetworks(mainnetNetworks, testnetNetworks = [], defaultChainId) {\n    let networks = [];\n    this._chainId = undefined; // clear memoized value\n    // find chain between mainnet and testnet network groups, and set that network group.\n    // otherwise use mainnetNetworks without changes\n\n    if (defaultChainId) {\n      // force-convert to a number in case someone sends a number in a string like \"1\"\n      const defaultChainIdNum = parseInt(defaultChainId);\n      const foundMainnetNetwork = mainnetNetworks.find(n => n.name === defaultChainId || n.chainId === defaultChainIdNum);\n      const foundTestnetNetwork = testnetNetworks.find(n => n.name === defaultChainId || n.chainId === defaultChainIdNum);\n\n      if (foundMainnetNetwork || foundTestnetNetwork) {\n        if (foundMainnetNetwork) {\n          mainnetNetworks.forEach(n => n.isDefaultChain = false);\n          foundMainnetNetwork.isDefaultChain = true;\n          networks = mainnetNetworks;\n        } else if (foundTestnetNetwork) {\n          testnetNetworks.forEach(n => n.isDefaultChain = false);\n          foundTestnetNetwork.isDefaultChain = true;\n          networks = testnetNetworks;\n        }\n      } else {\n        throw new Error(`unable to set default network as chain '${defaultChainId}' does not exist`);\n      }\n    } else {\n      networks = mainnetNetworks;\n    } // assign while validating network list\n    // TODO - we should remove sortNetworks in the future but this is a breaking change\n\n\n    this.options.networks = ensureValidNetworks(sortNetworks(networks)); // Account/wallet instances using the initial configuration and network list\n    //\n    // TODO: we can make an optimization where if mainnetNetworks and testnetNetworks lists\n    // haven't changed between calls, and only the defaultChainId, as well, the group between\n    // mainnet vs testnet has not changed either -- aka just defaultChainId within a group,\n    // then we can avoid rebuilding all of these objects and instead just sort them\n\n    this._wallets = this.options.networks.map(network => {\n      const wallet = new Wallet({\n        config: this.options.initialConfig,\n        context: this.options.context\n      }, ...this._signers);\n\n      if (network.provider) {\n        wallet.setProvider(network.provider);\n      } else if (network.rpcUrl && network.rpcUrl !== '') {\n        wallet.setProvider(network.rpcUrl);\n      } else {\n        throw new Error(`network config is missing provider settings for chainId ${network.chainId}`);\n      }\n\n      if (isRelayer(network.relayer)) {\n        wallet.setRelayer(network.relayer);\n      } else if (isRpcRelayerOptions(network.relayer)) {\n        wallet.setRelayer(new RpcRelayer(_extends({\n          provider: wallet.provider\n        }, network.relayer)));\n      } else {\n        throw new Error(`network config is missing relayer settings for chainId ${network.chainId}`);\n      }\n\n      if (network.isDefaultChain) {\n        this._chainId = network.chainId;\n        this.provider = wallet.provider;\n      }\n\n      return {\n        network: network,\n        wallet: wallet\n      };\n    }); // return the default chain id as number\n\n    return this.options.networks.find(network => network.isDefaultChain).chainId;\n  }\n\n  connect(_) {\n    throw new Error('connect method is not supported in MultiWallet');\n  }\n\n  signTransaction(_) {\n    throw new Error('signTransaction method is not supported in MultiWallet, please use signTransactions(...)');\n  }\n\n}\n\nasync function isValidSignature(address, digest, sig, provider, walletContext, chainId) {\n  // Check if valid EOA signature\n  //\n  // TODO: the EOA check here assume its being passed a digest, but its not a correct assumption\n  // as often the message signing is of a string of text and not a digest.\n  if (isValidEIP712Signature(address, digest, sig) || isValidEthSignSignature(address, digest, sig)) return true; // Check if valid deployed smart wallet (via erc1271 check)\n\n  const erc1271Check = await isValidContractWalletSignature(address, digest, sig, provider);\n\n  if (erc1271Check === undefined) {\n    // If validity of wallet signature can't be determined\n    // it could be a signature of a non-deployed sequence wallet\n    return isValidSequenceUndeployedWalletSignature(address, digest, sig, walletContext, provider, chainId);\n  }\n\n  return erc1271Check;\n}\nfunction isValidEIP712Signature(address, digest, sig) {\n  try {\n    return compareAddr(ethers.utils.recoverAddress(digest, ethers.utils.splitSignature(sig)), address) === 0;\n  } catch (_unused) {\n    return false;\n  }\n}\nfunction isValidEthSignSignature(address, digest, sig) {\n  try {\n    const subDigest = ethers.utils.keccak256(ethers.utils.solidityPack(['string', 'bytes32'], ['\\x19Ethereum Signed Message:\\n32', digest]));\n    return compareAddr(ethers.utils.recoverAddress(subDigest, ethers.utils.splitSignature(sig)), address) === 0;\n  } catch (_unused2) {\n    return false;\n  }\n} // Check if valid Smart Contract Wallet signature, via ERC1271\n\nasync function isValidContractWalletSignature(address, digest, sig, provider) {\n  if (!provider) return undefined;\n\n  try {\n    if ((await provider.getCode(address)) === '0x') {\n      // Signature validity can't be determined\n      return undefined;\n    }\n\n    const wallet = new ethers.Contract(address, walletContracts.erc1271.abi, provider);\n    const response = await wallet.isValidSignature(digest, sig);\n    return walletContracts.erc1271.returns.isValidSignatureBytes32 === response;\n  } catch (_unused3) {\n    return false;\n  }\n}\nasync function isValidSequenceUndeployedWalletSignature(address, digest, sig, walletContext, provider, chainId) {\n  if (!provider && !chainId) return undefined; // Signature validity can't be determined\n\n  if (!walletContext) return undefined; // Signature validity can't be determined\n\n  try {\n    const cid = chainId ? chainId : (await provider.getNetwork()).chainId;\n    const signature = decodeSignature(sig);\n    const subDigest = ethers.utils.arrayify(ethers.utils.keccak256(packMessageData(address, cid, digest)));\n    const config = await recoverConfigFromDigest(subDigest, signature, provider, walletContext, chainId, true);\n    const weight = signature.signers.reduce((v, s) => isDecodedEOASigner(s) || isDecodedFullSigner(s) ? v + s.weight : v, 0);\n    return compareAddr(addressOf(config, walletContext), address) === 0 && weight >= signature.threshold;\n  } catch (_unused4) {\n    return false;\n  }\n}\n\nconst fetchImageHash = async signer => {\n  const address = await signer.getAddress();\n  const walletContract = new Contract(address, walletContracts.mainModuleUpgradable.abi, await signer.getProvider());\n  const currentImageHash = await walletContract.functions.imageHash.call([]).catch(() => []);\n  return currentImageHash && currentImageHash.length > 0 ? currentImageHash[0] : '';\n}; // recoverConfig decodes a WalletConfig from the subDigest and signature combo. Note: the subDigest argument\n// is an encoding format of the original message, encoded by:\n//\n// subDigest = packMessageData(wallet.address, chainId, ethers.utils.keccak256(message))\n\nconst recoverConfig = async (subDigest, signature, provider, context, chainId, walletSignersValidation) => {\n  const digest = ethers.utils.arrayify(ethers.utils.keccak256(subDigest));\n  return recoverConfigFromDigest(digest, signature, provider, context, chainId, walletSignersValidation);\n}; // recoverConfigFromDigest decodes a WalletConfig from a digest and signature combo. Note: the digest\n// is the keccak256 of the subDigest, see `recoverConfig` method.\n\nconst recoverConfigFromDigest = async (digest, signature, provider, context, chainId, walletSignersValidation) => {\n  const decoded = signature.threshold !== undefined ? signature : decodeSignature(signature);\n  const signers = await Promise.all(decoded.signers.map(async s => {\n    if (isDecodedEOASigner(s)) {\n      return {\n        weight: s.weight,\n        address: recoverEOASigner(digest, s)\n      };\n    } else if (isDecodedAddress(s)) {\n      return {\n        weight: s.weight,\n        address: ethers.utils.getAddress(s.address)\n      };\n    } else if (isDecodedFullSigner(s)) {\n      if (walletSignersValidation) {\n        if (!(await isValidSignature(s.address, ethers.utils.arrayify(digest), ethers.utils.hexlify(s.signature), provider, context, chainId))) throw Error('Invalid signature');\n      }\n\n      return {\n        weight: s.weight,\n        address: s.address\n      };\n    } else {\n      throw Error('Uknown signature type');\n    }\n  }));\n  return {\n    threshold: decoded.threshold,\n    signers: signers\n  };\n};\n\nexport { Account, GuardRemoteSigner, InvalidSigner, LocalRemoteSigner, NotEnoughSigners, RemoteSigner, Signer, Wallet, fetchImageHash, findLatestLog, isSequenceSigner, isValidContractWalletSignature, isValidEIP712Signature, isValidEthSignSignature, isValidSequenceUndeployedWalletSignature, isValidSignature, recoverConfig, recoverConfigFromDigest, resolveArrayProperties };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}