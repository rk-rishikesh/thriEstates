{"ast":null,"code":"import { ethers } from 'ethers';\nimport { Proof, ETHAuth, IsValidSignatureBytes32MagicValue } from '@0xsequence/ethauth';\nimport { SequenceAPIClient } from '@0xsequence/api';\nimport { SequenceUtilsFinder, decodeSignature, isDecodedSigner, editConfig, genConfig } from '@0xsequence/config';\nimport { SequenceIndexerClient } from '@0xsequence/indexer';\nimport { SequenceMetadataClient } from '@0xsequence/metadata';\nimport { findNetworkConfig, getAuthNetwork, sequenceContext } from '@0xsequence/network';\nimport { jwtDecodeClaims } from '@0xsequence/utils';\nimport { Account, isValidSequenceUndeployedWalletSignature } from '@0xsequence/wallet';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n} // Default session expiration of ETHAuth token (1 week)\n\n\nconst DEFAULT_SESSION_EXPIRATION = 60 * 60 * 24 * 7; // Long session expiration of ETHAuth token (~1 year)\n\nconst LONG_SESSION_EXPIRATION = 3e7;\nconst EXPIRATION_JWT_MARGIN = 60; // seconds\n\nclass Session {\n  // proof strings are indexed by account address and app name, see getProofStringKey()\n  constructor(sequenceApiUrl, sequenceMetadataUrl, networks, config, context, account, metadata, authProvider, jwt) {\n    this.sequenceApiUrl = sequenceApiUrl;\n    this.sequenceMetadataUrl = sequenceMetadataUrl;\n    this.networks = networks;\n    this.config = config;\n    this.context = context;\n    this.account = account;\n    this.metadata = metadata;\n    this.authProvider = authProvider;\n    this._initialAuthRequest = void 0;\n    this._jwt = void 0;\n    this.proofStrings = new Map();\n    this.onAuthCallbacks = [];\n    this.apiClient = void 0;\n    this.metadataClient = void 0;\n    this.indexerClients = new Map();\n\n    if (jwt) {\n      var _jwt$expiration;\n\n      this._jwt = {\n        token: Promise.resolve(jwt.token),\n        expiration: (_jwt$expiration = jwt.expiration) != null ? _jwt$expiration : getJWTExpiration(jwt.token)\n      };\n    }\n  }\n\n  get name() {\n    return this.metadata.name;\n  }\n\n  get expiration() {\n    return this.metadata.expiration ? Math.max(this.metadata.expiration, 120) : DEFAULT_SESSION_EXPIRATION;\n  }\n\n  onAuth(cb) {\n    this.onAuthCallbacks.push(cb);\n  }\n\n  setAccount(account) {\n    this.account = account;\n  }\n\n  setConfig(config) {\n    this.config = config;\n  }\n\n  async auth() {\n    let maxTries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n    const url = this.sequenceApiUrl;\n    if (!url) throw Error('No sequence api url');\n    let jwtAuth;\n\n    for (let i = 0;; i++) {\n      try {\n        jwtAuth = (await this.getJWT(true)).token;\n        break;\n      } catch (error) {\n        if (i === maxTries - 1) {\n          console.error(`couldn't authenticate after ${maxTries} attempts`, error);\n          throw error;\n        }\n      }\n    }\n\n    return new SequenceAPIClient(url, jwtAuth);\n  }\n\n  get isTestnetMode() {\n    if (!this.networks || this.networks.length === 0) return;\n    return !!this.networks[0].testnet;\n  }\n\n  async getAPIClient() {\n    let tryAuth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    if (!this.apiClient) {\n      const url = this.sequenceApiUrl;\n      if (!url) throw Error('No chaind url');\n      const jwtAuth = (await this.getJWT(tryAuth)).token;\n      this.apiClient = new SequenceAPIClient(url, jwtAuth);\n    }\n\n    return this.apiClient;\n  }\n\n  getMetadataClient() {\n    if (!this.metadataClient) {\n      this.metadataClient = new SequenceMetadataClient(this.sequenceMetadataUrl);\n    }\n\n    return this.metadataClient;\n  }\n\n  async getIndexerClient(chainId) {\n    const network = findNetworkConfig(this.networks, chainId);\n\n    if (!network) {\n      throw Error(`No network for chain ${chainId}`);\n    }\n\n    const jwtAuth = (await this.getJWT(true)).token;\n\n    if (!this.indexerClients.has(network.chainId)) {\n      if (network.indexer) {\n        this.indexerClients.set(network.chainId, network.indexer);\n      } else if (network.indexerUrl) {\n        this.indexerClients.set(network.chainId, new SequenceIndexerClient(network.indexerUrl, jwtAuth));\n      } else {\n        throw Error(`No indexer url for chain ${chainId}`);\n      }\n    }\n\n    return this.indexerClients.get(network.chainId);\n  }\n\n  async getJWT(tryAuth) {\n    var _this = this;\n\n    const url = this.sequenceApiUrl;\n    if (!url) throw Error('No chaind url'); // check if we already have or are waiting for a token\n\n    if (this._jwt) {\n      const _jwt = this._jwt;\n\n      const _token = await _jwt.token;\n\n      if (this.now() < _jwt.expiration) {\n        return {\n          token: _token,\n          expiration: _jwt.expiration\n        };\n      } // token expired, delete it and get a new one\n\n\n      this._jwt = undefined;\n    }\n\n    if (!tryAuth) {\n      throw new Error('no auth token in memory');\n    }\n\n    const proofStringKey = this.getProofStringKey();\n    const {\n      proofString,\n      expiration\n    } = this.getProofString(proofStringKey);\n    const jwt = {\n      token: proofString.then(async function (proofString) {\n        const api = new SequenceAPIClient(url);\n        const authResp = await api.getAuthToken({\n          ewtString: proofString,\n          testnetMode: _this.isTestnetMode\n        });\n\n        if ((authResp == null ? void 0 : authResp.status) === true && authResp.jwtToken.length !== 0) {\n          return authResp.jwtToken;\n        } else {\n          if (!(await _this.isProofStringValid(proofString))) {\n            _this.proofStrings.delete(proofStringKey);\n          }\n\n          throw new Error('no auth token from server');\n        }\n      }).catch(reason => {\n        this._jwt = undefined;\n        throw reason;\n      }),\n      expiration\n    };\n    this._jwt = jwt;\n    jwt.token.then(() => {\n      this.onAuthCallbacks.forEach(cb => {\n        try {\n          cb({\n            status: 'fulfilled',\n            value: undefined\n          });\n        } catch (_unused) {}\n      });\n    }).catch(reason => {\n      this.onAuthCallbacks.forEach(cb => {\n        try {\n          cb({\n            status: 'rejected',\n            reason\n          });\n        } catch (_unused2) {}\n      });\n    });\n    const token = await jwt.token;\n    return {\n      token,\n      expiration\n    };\n  }\n\n  getProofString(key) {\n    // check if we already have or are waiting for a proof string\n    if (this.proofStrings.has(key)) {\n      const _proofString = this.proofStrings.get(key);\n\n      if (this.now() < _proofString.expiration) {\n        return _proofString;\n      } // proof string expired, delete it and make a new one\n\n\n      this.proofStrings.delete(key);\n    }\n\n    const proof = new Proof({\n      address: this.account.address\n    });\n    proof.claims.app = this.name;\n    proof.setExpiryIn(this.expiration);\n    const ethAuth = new ETHAuth();\n    const configFinder = new SequenceUtilsFinder(this.authProvider);\n    const authWallet = this.account.authWallet();\n    const expiration = this.now() + this.expiration - EXPIRATION_JWT_MARGIN;\n    const proofString = {\n      // Fetch latest config\n      // TODO: Should only search for latest config if necessary to be more efficient.\n      //       Perhaps compare local config hash with on-chain hash before doing\n      //       the search through the logs. Should do this accross sequence.js\n      proofString: configFinder.findCurrentConfig({\n        address: authWallet.wallet.address,\n        provider: this.authProvider,\n        context: authWallet.wallet.context,\n        knownConfigs: [authWallet.wallet.config]\n      }).then(val => {\n        if (!val.config) throw Error(\"Can't find latest config\");\n        return authWallet.wallet.useConfig(val.config).sign(proof.messageDigest()).then(signature => {\n          const decodedSignature = decodeSignature(signature);\n          const totalWeight = decodedSignature.signers.filter(isDecodedSigner).reduce((totalWeight, signer) => totalWeight + signer.weight, 0);\n\n          if (totalWeight < decodedSignature.threshold) {\n            throw Error(`insufficient signing power, need ${decodedSignature.threshold}, have ${totalWeight}`);\n          }\n\n          proof.signature = signature;\n          return ethAuth.encodeProof(proof, true);\n        });\n      }).catch(reason => {\n        this.proofStrings.delete(key);\n        throw reason;\n      }),\n      expiration\n    };\n    this.proofStrings.set(key, proofString);\n    return proofString;\n  }\n\n  getProofStringKey() {\n    return `${this.account.address} - ${this.name}`;\n  }\n\n  async isProofStringValid(proofString) {\n    try {\n      const ethAuth = new ETHAuth();\n      ethAuth.provider = this.authProvider;\n      await ethAuth.decodeProof(proofString);\n      return true;\n    } catch (_unused3) {\n      return false;\n    }\n  }\n\n  async dump() {\n    let jwt;\n\n    if (this._jwt) {\n      try {\n        const expiration = this._jwt.expiration;\n        jwt = {\n          token: await this._jwt.token,\n          expiration\n        };\n      } catch (_unused4) {}\n    }\n\n    return {\n      config: this.config,\n      context: this.context,\n      metadata: this.metadata,\n      jwt\n    };\n  }\n\n  now() {\n    return Math.floor(new Date().getTime() / 1000);\n  }\n\n  static async open(args) {\n    const {\n      sequenceApiUrl,\n      sequenceMetadataUrl,\n      context,\n      networks,\n      referenceSigner,\n      signers,\n      threshold,\n      deepSearch,\n      knownConfigs,\n      noIndex,\n      metadata\n    } = args;\n    const authProvider = getAuthProvider(networks);\n    const configFinder = args.configFinder ? args.configFinder : new SequenceUtilsFinder(authProvider);\n    const solvedSigners = Promise.all(signers.map(async function (s) {\n      return _extends({}, s, {\n        address: typeof s.signer === 'string' ? s.signer : await s.signer.getAddress()\n      });\n    }));\n    const fullSigners = signers.filter(s => typeof s.signer !== 'string').map(s => s.signer);\n    const existingWallet = (await configFinder.findLastWalletOfInitialSigner({\n      signer: referenceSigner,\n      context: context,\n      provider: authProvider,\n      requireIndex: deepSearch ? false : true\n    })).wallet;\n\n    if (existingWallet) {\n      // existing account\n      // Find prev configuration\n      const config = (await configFinder.findCurrentConfig({\n        address: existingWallet,\n        provider: authProvider,\n        context: context,\n        knownConfigs\n      })).config;\n      if (!config) throw Error('Wallet config not found'); // Load prev account\n\n      const account = new Account({\n        initialConfig: config,\n        networks: networks,\n        context: context\n      }, ...fullSigners);\n      const session = new Session(sequenceApiUrl, sequenceMetadataUrl, networks, config, context, account, metadata, authProvider); // Update wallet config on-chain on the authChain\n\n      const [newConfig] = await account.updateConfig(editConfig(config, {\n        threshold,\n        set: await solvedSigners\n      }), noIndex ? false : true); // Session is ready, lets update\n\n      session.setConfig(newConfig);\n      session.setAccount(new Account({\n        initialConfig: newConfig,\n        networks: networks,\n        context: context\n      }, ...fullSigners));\n\n      if (sequenceApiUrl) {\n        // Fire JWT requests after updating config\n        session._initialAuthRequest = session.auth();\n      } else {\n        session._initialAuthRequest = Promise.reject('no sequence api url');\n      }\n\n      return session;\n    } else {\n      // fresh account\n      const config = genConfig(threshold, await solvedSigners);\n      const account = new Account({\n        initialConfig: config,\n        networks: networks,\n        context: context\n      }, ...fullSigners); // send referenceSigner as \"requireFreshSigners\"\n      // this ensures the user doesn't end up with multiple accounts if there is a race condition during login\n\n      await account.publishConfig(noIndex ? false : true, [referenceSigner]);\n      const session = new Session(sequenceApiUrl, sequenceMetadataUrl, networks, config, context, account, metadata, authProvider);\n\n      if (sequenceApiUrl) {\n        // Fire JWT requests when opening session\n        session._initialAuthRequest = session.auth();\n      } else {\n        session._initialAuthRequest = Promise.reject('no sequence api url');\n      }\n\n      return session;\n    }\n  }\n\n  static load(args) {\n    const {\n      sequenceApiUrl,\n      sequenceMetadataUrl,\n      dump,\n      signers,\n      networks\n    } = args;\n    return new Session(sequenceApiUrl, sequenceMetadataUrl, networks, dump.config, dump.context, new Account({\n      initialConfig: dump.config,\n      context: dump.context,\n      networks: networks\n    }, ...signers), dump.metadata, getAuthProvider(networks), dump.jwt);\n  }\n\n}\n\nfunction getAuthProvider(networks) {\n  var _authChain$provider;\n\n  const authChain = getAuthNetwork(networks);\n  if (!authChain) throw Error('Auth chain not found');\n  return (_authChain$provider = authChain.provider) != null ? _authChain$provider : new ethers.providers.JsonRpcProvider(authChain.rpcUrl);\n}\n\nfunction getJWTExpiration(jwt) {\n  return jwtDecodeClaims(jwt).exp;\n} // signAuthorization will perform an EIP712 typed-data message signing of ETHAuth domain via the provided\n// Signer and authorization options.\n\n\nconst signAuthorization = async (signer, options) => {\n  const chainId = await signer.getChainId();\n  const address = ethers.utils.getAddress(await signer.getAddress());\n\n  if (!address || address === '' || address === '0x') {\n    throw ErrAccountIsRequired;\n  }\n\n  const proof = new Proof();\n  proof.address = address;\n\n  if (!options || !options.app || options.app === '') {\n    throw new AuthError('authorization options requires app to be set');\n  }\n\n  proof.claims.app = options.app;\n  proof.claims.ogn = options.origin;\n  proof.setExpiryIn(options.expiry ? Math.max(options.expiry, 200) : DEFAULT_SESSION_EXPIRATION);\n  const typedData = proof.messageTypedData();\n  proof.signature = await signer.signTypedData(typedData.domain, typedData.types, typedData.message, chainId);\n  const ethAuth = new ETHAuth();\n  const proofString = await ethAuth.encodeProof(proof, true);\n  return {\n    typedData,\n    proofString\n  };\n}; // TODO: review......\n\n\nclass AuthError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'AuthError';\n  }\n\n}\n\nconst ErrAccountIsRequired = new AuthError('auth error: account address is empty');\n\nconst ValidateSequenceDeployedWalletProof = async (provider, chainId, proof) => {\n  if (!provider || provider === undefined || chainId === undefined) {\n    return {\n      isValid: false\n    };\n  } // Compute eip712 message digest from the proof claims\n\n\n  const digest = proof.messageDigest(); // Early check to ensure the contract wallet has been deployed\n\n  const walletCode = await provider.getCode(proof.address);\n\n  if (walletCode === '0x' || walletCode.length <= 2) {\n    throw new Error('ValidateSequenceDeployedWalletProof failed. unable to fetch wallet contract code');\n  } // Call EIP-1271 IsValidSignature(bytes32, bytes) method on the deployed wallet. Note: for undeployed\n  // wallets, you will need to implement your own ValidatorFunc with the additional context.\n\n\n  const abi = ['function isValidSignature(bytes32, bytes) public view returns (bytes4)'];\n  const contract = new ethers.Contract(proof.address, abi, provider); // hash the message digest as required by isValidSignature\n\n  const isValidSignature = await contract.isValidSignature(digest, ethers.utils.arrayify(proof.signature));\n\n  if (isValidSignature === IsValidSignatureBytes32MagicValue) {\n    return {\n      isValid: true\n    };\n  } else {\n    return {\n      isValid: false\n    };\n  }\n};\n\nconst ValidateSequenceUndeployedWalletProof = context => {\n  return async (provider, chainId, proof) => {\n    if (!provider || provider === undefined || chainId === undefined) {\n      return {\n        isValid: false\n      };\n    } // The contract must not be deployed\n\n\n    const walletCode = ethers.utils.arrayify(await provider.getCode(proof.address));\n    if (walletCode.length !== 0) return {\n      isValid: false\n    }; // Compute eip712 message digest from the proof claims\n\n    const message = proof.messageDigest(); // hash the message digest as required by isValidSignature\n\n    const digest = ethers.utils.arrayify(ethers.utils.keccak256(message));\n    const isValid = await isValidSequenceUndeployedWalletSignature(proof.address, digest, proof.signature, context ? context : sequenceContext, provider, chainId);\n    return {\n      isValid: !!isValid\n    };\n  };\n};\n\nexport { AuthError, DEFAULT_SESSION_EXPIRATION, ErrAccountIsRequired, LONG_SESSION_EXPIRATION, Session, ValidateSequenceDeployedWalletProof, ValidateSequenceUndeployedWalletProof, signAuthorization };","map":{"version":3,"names":["ethers","Proof","ETHAuth","IsValidSignatureBytes32MagicValue","SequenceAPIClient","SequenceUtilsFinder","decodeSignature","isDecodedSigner","editConfig","genConfig","SequenceIndexerClient","SequenceMetadataClient","findNetworkConfig","getAuthNetwork","sequenceContext","jwtDecodeClaims","Account","isValidSequenceUndeployedWalletSignature","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","DEFAULT_SESSION_EXPIRATION","LONG_SESSION_EXPIRATION","EXPIRATION_JWT_MARGIN","Session","constructor","sequenceApiUrl","sequenceMetadataUrl","networks","config","context","account","metadata","authProvider","jwt","_initialAuthRequest","_jwt","proofStrings","Map","onAuthCallbacks","apiClient","metadataClient","indexerClients","_jwt$expiration","token","Promise","resolve","expiration","getJWTExpiration","name","Math","max","onAuth","cb","push","setAccount","setConfig","auth","maxTries","url","Error","jwtAuth","getJWT","error","console","isTestnetMode","testnet","getAPIClient","tryAuth","getMetadataClient","getIndexerClient","chainId","network","has","indexer","set","indexerUrl","get","_this","_token","now","undefined","proofStringKey","getProofStringKey","proofString","getProofString","then","api","authResp","getAuthToken","ewtString","testnetMode","status","jwtToken","isProofStringValid","delete","catch","reason","forEach","value","_unused","_unused2","_proofString","proof","address","claims","app","setExpiryIn","ethAuth","configFinder","authWallet","findCurrentConfig","wallet","provider","knownConfigs","val","useConfig","sign","messageDigest","signature","decodedSignature","totalWeight","signers","filter","reduce","signer","weight","threshold","encodeProof","decodeProof","_unused3","dump","_unused4","floor","Date","getTime","open","args","referenceSigner","deepSearch","noIndex","getAuthProvider","solvedSigners","all","map","s","getAddress","fullSigners","existingWallet","findLastWalletOfInitialSigner","requireIndex","initialConfig","session","newConfig","updateConfig","reject","publishConfig","load","_authChain$provider","authChain","providers","JsonRpcProvider","rpcUrl","exp","signAuthorization","options","getChainId","utils","ErrAccountIsRequired","AuthError","ogn","origin","expiry","typedData","messageTypedData","signTypedData","domain","types","message","ValidateSequenceDeployedWalletProof","isValid","digest","walletCode","getCode","abi","contract","Contract","isValidSignature","arrayify","ValidateSequenceUndeployedWalletProof","keccak256"],"sources":["C:/Users/rishi/contract-poc/ThriEstate/Brandvilla/node_modules/@0xsequence/auth/dist/0xsequence-auth.esm.js"],"sourcesContent":["import { ethers } from 'ethers';\nimport { Proof, ETHAuth, IsValidSignatureBytes32MagicValue } from '@0xsequence/ethauth';\nimport { SequenceAPIClient } from '@0xsequence/api';\nimport { SequenceUtilsFinder, decodeSignature, isDecodedSigner, editConfig, genConfig } from '@0xsequence/config';\nimport { SequenceIndexerClient } from '@0xsequence/indexer';\nimport { SequenceMetadataClient } from '@0xsequence/metadata';\nimport { findNetworkConfig, getAuthNetwork, sequenceContext } from '@0xsequence/network';\nimport { jwtDecodeClaims } from '@0xsequence/utils';\nimport { Account, isValidSequenceUndeployedWalletSignature } from '@0xsequence/wallet';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n// Default session expiration of ETHAuth token (1 week)\nconst DEFAULT_SESSION_EXPIRATION = 60 * 60 * 24 * 7; // Long session expiration of ETHAuth token (~1 year)\n\nconst LONG_SESSION_EXPIRATION = 3e7;\nconst EXPIRATION_JWT_MARGIN = 60; // seconds\n\nclass Session {\n  // proof strings are indexed by account address and app name, see getProofStringKey()\n  constructor(sequenceApiUrl, sequenceMetadataUrl, networks, config, context, account, metadata, authProvider, jwt) {\n    this.sequenceApiUrl = sequenceApiUrl;\n    this.sequenceMetadataUrl = sequenceMetadataUrl;\n    this.networks = networks;\n    this.config = config;\n    this.context = context;\n    this.account = account;\n    this.metadata = metadata;\n    this.authProvider = authProvider;\n    this._initialAuthRequest = void 0;\n    this._jwt = void 0;\n    this.proofStrings = new Map();\n    this.onAuthCallbacks = [];\n    this.apiClient = void 0;\n    this.metadataClient = void 0;\n    this.indexerClients = new Map();\n\n    if (jwt) {\n      var _jwt$expiration;\n\n      this._jwt = {\n        token: Promise.resolve(jwt.token),\n        expiration: (_jwt$expiration = jwt.expiration) != null ? _jwt$expiration : getJWTExpiration(jwt.token)\n      };\n    }\n  }\n\n  get name() {\n    return this.metadata.name;\n  }\n\n  get expiration() {\n    return this.metadata.expiration ? Math.max(this.metadata.expiration, 120) : DEFAULT_SESSION_EXPIRATION;\n  }\n\n  onAuth(cb) {\n    this.onAuthCallbacks.push(cb);\n  }\n\n  setAccount(account) {\n    this.account = account;\n  }\n\n  setConfig(config) {\n    this.config = config;\n  }\n\n  async auth(maxTries = 5) {\n    const url = this.sequenceApiUrl;\n    if (!url) throw Error('No sequence api url');\n    let jwtAuth;\n\n    for (let i = 0;; i++) {\n      try {\n        jwtAuth = (await this.getJWT(true)).token;\n        break;\n      } catch (error) {\n        if (i === maxTries - 1) {\n          console.error(`couldn't authenticate after ${maxTries} attempts`, error);\n          throw error;\n        }\n      }\n    }\n\n    return new SequenceAPIClient(url, jwtAuth);\n  }\n\n  get isTestnetMode() {\n    if (!this.networks || this.networks.length === 0) return;\n    return !!this.networks[0].testnet;\n  }\n\n  async getAPIClient(tryAuth = true) {\n    if (!this.apiClient) {\n      const url = this.sequenceApiUrl;\n      if (!url) throw Error('No chaind url');\n      const jwtAuth = (await this.getJWT(tryAuth)).token;\n      this.apiClient = new SequenceAPIClient(url, jwtAuth);\n    }\n\n    return this.apiClient;\n  }\n\n  getMetadataClient() {\n    if (!this.metadataClient) {\n      this.metadataClient = new SequenceMetadataClient(this.sequenceMetadataUrl);\n    }\n\n    return this.metadataClient;\n  }\n\n  async getIndexerClient(chainId) {\n    const network = findNetworkConfig(this.networks, chainId);\n\n    if (!network) {\n      throw Error(`No network for chain ${chainId}`);\n    }\n\n    const jwtAuth = (await this.getJWT(true)).token;\n\n    if (!this.indexerClients.has(network.chainId)) {\n      if (network.indexer) {\n        this.indexerClients.set(network.chainId, network.indexer);\n      } else if (network.indexerUrl) {\n        this.indexerClients.set(network.chainId, new SequenceIndexerClient(network.indexerUrl, jwtAuth));\n      } else {\n        throw Error(`No indexer url for chain ${chainId}`);\n      }\n    }\n\n    return this.indexerClients.get(network.chainId);\n  }\n\n  async getJWT(tryAuth) {\n    var _this = this;\n\n    const url = this.sequenceApiUrl;\n    if (!url) throw Error('No chaind url'); // check if we already have or are waiting for a token\n\n    if (this._jwt) {\n      const _jwt = this._jwt;\n\n      const _token = await _jwt.token;\n\n      if (this.now() < _jwt.expiration) {\n        return {\n          token: _token,\n          expiration: _jwt.expiration\n        };\n      } // token expired, delete it and get a new one\n\n\n      this._jwt = undefined;\n    }\n\n    if (!tryAuth) {\n      throw new Error('no auth token in memory');\n    }\n\n    const proofStringKey = this.getProofStringKey();\n    const {\n      proofString,\n      expiration\n    } = this.getProofString(proofStringKey);\n    const jwt = {\n      token: proofString.then(async function (proofString) {\n        const api = new SequenceAPIClient(url);\n        const authResp = await api.getAuthToken({\n          ewtString: proofString,\n          testnetMode: _this.isTestnetMode\n        });\n\n        if ((authResp == null ? void 0 : authResp.status) === true && authResp.jwtToken.length !== 0) {\n          return authResp.jwtToken;\n        } else {\n          if (!(await _this.isProofStringValid(proofString))) {\n            _this.proofStrings.delete(proofStringKey);\n          }\n\n          throw new Error('no auth token from server');\n        }\n      }).catch(reason => {\n        this._jwt = undefined;\n        throw reason;\n      }),\n      expiration\n    };\n    this._jwt = jwt;\n    jwt.token.then(() => {\n      this.onAuthCallbacks.forEach(cb => {\n        try {\n          cb({\n            status: 'fulfilled',\n            value: undefined\n          });\n        } catch (_unused) {}\n      });\n    }).catch(reason => {\n      this.onAuthCallbacks.forEach(cb => {\n        try {\n          cb({\n            status: 'rejected',\n            reason\n          });\n        } catch (_unused2) {}\n      });\n    });\n    const token = await jwt.token;\n    return {\n      token,\n      expiration\n    };\n  }\n\n  getProofString(key) {\n    // check if we already have or are waiting for a proof string\n    if (this.proofStrings.has(key)) {\n      const _proofString = this.proofStrings.get(key);\n\n      if (this.now() < _proofString.expiration) {\n        return _proofString;\n      } // proof string expired, delete it and make a new one\n\n\n      this.proofStrings.delete(key);\n    }\n\n    const proof = new Proof({\n      address: this.account.address\n    });\n    proof.claims.app = this.name;\n    proof.setExpiryIn(this.expiration);\n    const ethAuth = new ETHAuth();\n    const configFinder = new SequenceUtilsFinder(this.authProvider);\n    const authWallet = this.account.authWallet();\n    const expiration = this.now() + this.expiration - EXPIRATION_JWT_MARGIN;\n    const proofString = {\n      // Fetch latest config\n      // TODO: Should only search for latest config if necessary to be more efficient.\n      //       Perhaps compare local config hash with on-chain hash before doing\n      //       the search through the logs. Should do this accross sequence.js\n      proofString: configFinder.findCurrentConfig({\n        address: authWallet.wallet.address,\n        provider: this.authProvider,\n        context: authWallet.wallet.context,\n        knownConfigs: [authWallet.wallet.config]\n      }).then(val => {\n        if (!val.config) throw Error(\"Can't find latest config\");\n        return authWallet.wallet.useConfig(val.config).sign(proof.messageDigest()).then(signature => {\n          const decodedSignature = decodeSignature(signature);\n          const totalWeight = decodedSignature.signers.filter(isDecodedSigner).reduce((totalWeight, signer) => totalWeight + signer.weight, 0);\n\n          if (totalWeight < decodedSignature.threshold) {\n            throw Error(`insufficient signing power, need ${decodedSignature.threshold}, have ${totalWeight}`);\n          }\n\n          proof.signature = signature;\n          return ethAuth.encodeProof(proof, true);\n        });\n      }).catch(reason => {\n        this.proofStrings.delete(key);\n        throw reason;\n      }),\n      expiration\n    };\n    this.proofStrings.set(key, proofString);\n    return proofString;\n  }\n\n  getProofStringKey() {\n    return `${this.account.address} - ${this.name}`;\n  }\n\n  async isProofStringValid(proofString) {\n    try {\n      const ethAuth = new ETHAuth();\n      ethAuth.provider = this.authProvider;\n      await ethAuth.decodeProof(proofString);\n      return true;\n    } catch (_unused3) {\n      return false;\n    }\n  }\n\n  async dump() {\n    let jwt;\n\n    if (this._jwt) {\n      try {\n        const expiration = this._jwt.expiration;\n        jwt = {\n          token: await this._jwt.token,\n          expiration\n        };\n      } catch (_unused4) {}\n    }\n\n    return {\n      config: this.config,\n      context: this.context,\n      metadata: this.metadata,\n      jwt\n    };\n  }\n\n  now() {\n    return Math.floor(new Date().getTime() / 1000);\n  }\n\n  static async open(args) {\n    const {\n      sequenceApiUrl,\n      sequenceMetadataUrl,\n      context,\n      networks,\n      referenceSigner,\n      signers,\n      threshold,\n      deepSearch,\n      knownConfigs,\n      noIndex,\n      metadata\n    } = args;\n    const authProvider = getAuthProvider(networks);\n    const configFinder = args.configFinder ? args.configFinder : new SequenceUtilsFinder(authProvider);\n    const solvedSigners = Promise.all(signers.map(async function (s) {\n      return _extends({}, s, {\n        address: typeof s.signer === 'string' ? s.signer : await s.signer.getAddress()\n      });\n    }));\n    const fullSigners = signers.filter(s => typeof s.signer !== 'string').map(s => s.signer);\n    const existingWallet = (await configFinder.findLastWalletOfInitialSigner({\n      signer: referenceSigner,\n      context: context,\n      provider: authProvider,\n      requireIndex: deepSearch ? false : true\n    })).wallet;\n\n    if (existingWallet) {\n      // existing account\n      // Find prev configuration\n      const config = (await configFinder.findCurrentConfig({\n        address: existingWallet,\n        provider: authProvider,\n        context: context,\n        knownConfigs\n      })).config;\n      if (!config) throw Error('Wallet config not found'); // Load prev account\n\n      const account = new Account({\n        initialConfig: config,\n        networks: networks,\n        context: context\n      }, ...fullSigners);\n      const session = new Session(sequenceApiUrl, sequenceMetadataUrl, networks, config, context, account, metadata, authProvider); // Update wallet config on-chain on the authChain\n\n      const [newConfig] = await account.updateConfig(editConfig(config, {\n        threshold,\n        set: await solvedSigners\n      }), noIndex ? false : true); // Session is ready, lets update\n\n      session.setConfig(newConfig);\n      session.setAccount(new Account({\n        initialConfig: newConfig,\n        networks: networks,\n        context: context\n      }, ...fullSigners));\n\n      if (sequenceApiUrl) {\n        // Fire JWT requests after updating config\n        session._initialAuthRequest = session.auth();\n      } else {\n        session._initialAuthRequest = Promise.reject('no sequence api url');\n      }\n\n      return session;\n    } else {\n      // fresh account\n      const config = genConfig(threshold, await solvedSigners);\n      const account = new Account({\n        initialConfig: config,\n        networks: networks,\n        context: context\n      }, ...fullSigners); // send referenceSigner as \"requireFreshSigners\"\n      // this ensures the user doesn't end up with multiple accounts if there is a race condition during login\n\n      await account.publishConfig(noIndex ? false : true, [referenceSigner]);\n      const session = new Session(sequenceApiUrl, sequenceMetadataUrl, networks, config, context, account, metadata, authProvider);\n\n      if (sequenceApiUrl) {\n        // Fire JWT requests when opening session\n        session._initialAuthRequest = session.auth();\n      } else {\n        session._initialAuthRequest = Promise.reject('no sequence api url');\n      }\n\n      return session;\n    }\n  }\n\n  static load(args) {\n    const {\n      sequenceApiUrl,\n      sequenceMetadataUrl,\n      dump,\n      signers,\n      networks\n    } = args;\n    return new Session(sequenceApiUrl, sequenceMetadataUrl, networks, dump.config, dump.context, new Account({\n      initialConfig: dump.config,\n      context: dump.context,\n      networks: networks\n    }, ...signers), dump.metadata, getAuthProvider(networks), dump.jwt);\n  }\n\n}\n\nfunction getAuthProvider(networks) {\n  var _authChain$provider;\n\n  const authChain = getAuthNetwork(networks);\n  if (!authChain) throw Error('Auth chain not found');\n  return (_authChain$provider = authChain.provider) != null ? _authChain$provider : new ethers.providers.JsonRpcProvider(authChain.rpcUrl);\n}\n\nfunction getJWTExpiration(jwt) {\n  return jwtDecodeClaims(jwt).exp;\n}\n\n// signAuthorization will perform an EIP712 typed-data message signing of ETHAuth domain via the provided\n// Signer and authorization options.\nconst signAuthorization = async (signer, options) => {\n  const chainId = await signer.getChainId();\n  const address = ethers.utils.getAddress(await signer.getAddress());\n\n  if (!address || address === '' || address === '0x') {\n    throw ErrAccountIsRequired;\n  }\n\n  const proof = new Proof();\n  proof.address = address;\n\n  if (!options || !options.app || options.app === '') {\n    throw new AuthError('authorization options requires app to be set');\n  }\n\n  proof.claims.app = options.app;\n  proof.claims.ogn = options.origin;\n  proof.setExpiryIn(options.expiry ? Math.max(options.expiry, 200) : DEFAULT_SESSION_EXPIRATION);\n  const typedData = proof.messageTypedData();\n  proof.signature = await signer.signTypedData(typedData.domain, typedData.types, typedData.message, chainId);\n  const ethAuth = new ETHAuth();\n  const proofString = await ethAuth.encodeProof(proof, true);\n  return {\n    typedData,\n    proofString\n  };\n}; // TODO: review......\n\nclass AuthError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'AuthError';\n  }\n\n}\nconst ErrAccountIsRequired = new AuthError('auth error: account address is empty');\n\nconst ValidateSequenceDeployedWalletProof = async (provider, chainId, proof) => {\n  if (!provider || provider === undefined || chainId === undefined) {\n    return {\n      isValid: false\n    };\n  } // Compute eip712 message digest from the proof claims\n\n\n  const digest = proof.messageDigest(); // Early check to ensure the contract wallet has been deployed\n\n  const walletCode = await provider.getCode(proof.address);\n\n  if (walletCode === '0x' || walletCode.length <= 2) {\n    throw new Error('ValidateSequenceDeployedWalletProof failed. unable to fetch wallet contract code');\n  } // Call EIP-1271 IsValidSignature(bytes32, bytes) method on the deployed wallet. Note: for undeployed\n  // wallets, you will need to implement your own ValidatorFunc with the additional context.\n\n\n  const abi = ['function isValidSignature(bytes32, bytes) public view returns (bytes4)'];\n  const contract = new ethers.Contract(proof.address, abi, provider); // hash the message digest as required by isValidSignature\n\n  const isValidSignature = await contract.isValidSignature(digest, ethers.utils.arrayify(proof.signature));\n\n  if (isValidSignature === IsValidSignatureBytes32MagicValue) {\n    return {\n      isValid: true\n    };\n  } else {\n    return {\n      isValid: false\n    };\n  }\n};\nconst ValidateSequenceUndeployedWalletProof = context => {\n  return async (provider, chainId, proof) => {\n    if (!provider || provider === undefined || chainId === undefined) {\n      return {\n        isValid: false\n      };\n    } // The contract must not be deployed\n\n\n    const walletCode = ethers.utils.arrayify(await provider.getCode(proof.address));\n    if (walletCode.length !== 0) return {\n      isValid: false\n    }; // Compute eip712 message digest from the proof claims\n\n    const message = proof.messageDigest(); // hash the message digest as required by isValidSignature\n\n    const digest = ethers.utils.arrayify(ethers.utils.keccak256(message));\n    const isValid = await isValidSequenceUndeployedWalletSignature(proof.address, digest, proof.signature, context ? context : sequenceContext, provider, chainId);\n    return {\n      isValid: !!isValid\n    };\n  };\n};\n\nexport { AuthError, DEFAULT_SESSION_EXPIRATION, ErrAccountIsRequired, LONG_SESSION_EXPIRATION, Session, ValidateSequenceDeployedWalletProof, ValidateSequenceUndeployedWalletProof, signAuthorization };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}