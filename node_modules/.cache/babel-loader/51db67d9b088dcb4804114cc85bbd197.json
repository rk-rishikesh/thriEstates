{"ast":null,"code":"import { Signer, ethers, Contract } from 'ethers';\nimport { walletContracts } from '@0xsequence/abi';\nimport { logger } from '@0xsequence/utils';\nimport * as multicall from '@0xsequence/multicall';\n/* tslint:disable */\n\n/**\n    Minimal upgradeable proxy implementation, delegates all calls to the address\n    defined by the storage slot matching the wallet address.\n\n    Inspired by EIP-1167 Implementation (https://eips.ethereum.org/EIPS/eip-1167)\n\n    deployed code:\n\n        0x00    0x36         0x36      CALLDATASIZE      cds\n        0x01    0x3d         0x3d      RETURNDATASIZE    0 cds\n        0x02    0x3d         0x3d      RETURNDATASIZE    0 0 cds\n        0x03    0x37         0x37      CALLDATACOPY\n        0x04    0x3d         0x3d      RETURNDATASIZE    0\n        0x05    0x3d         0x3d      RETURNDATASIZE    0 0\n        0x06    0x3d         0x3d      RETURNDATASIZE    0 0 0\n        0x07    0x36         0x36      CALLDATASIZE      cds 0 0 0\n        0x08    0x3d         0x3d      RETURNDATASIZE    0 cds 0 0 0\n        0x09    0x30         0x30      ADDRESS           addr 0 cds 0 0 0\n        0x0A    0x54         0x54      SLOAD             imp 0 cds 0 0 0\n        0x0B    0x5a         0x5a      GAS               gas imp 0 cds 0 0 0\n        0x0C    0xf4         0xf4      DELEGATECALL      suc 0\n        0x0D    0x3d         0x3d      RETURNDATASIZE    rds suc 0\n        0x0E    0x82         0x82      DUP3              0 rds suc 0\n        0x0F    0x80         0x80      DUP1              0 0 rds suc 0\n        0x10    0x3e         0x3e      RETURNDATACOPY    suc 0\n        0x11    0x90         0x90      SWAP1             0 suc\n        0x12    0x3d         0x3d      RETURNDATASIZE    rds 0 suc\n        0x13    0x91         0x91      SWAP2             suc 0 rds\n        0x14    0x60 0x18    0x6018    PUSH1             0x18 suc 0 rds\n    /-- 0x16    0x57         0x57      JUMPI             0 rds\n    |   0x17    0xfd         0xfd      REVERT\n    \\-> 0x18    0x5b         0x5b      JUMPDEST          0 rds\n        0x19    0xf3         0xf3      RETURN\n\n    flat deployed code: 0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\n\n    deploy function:\n\n        0x00    0x60 0x3a    0x603a    PUSH1             0x3a\n        0x02    0x60 0x0e    0x600e    PUSH1             0x0e 0x3a\n        0x04    0x3d         0x3d      RETURNDATASIZE    0 0x0e 0x3a\n        0x05    0x39         0x39      CODECOPY\n        0x06    0x60 0x1a    0x601a    PUSH1             0x1a\n        0x08    0x80         0x80      DUP1              0x1a 0x1a\n        0x09    0x51         0x51      MLOAD             imp 0x1a\n        0x0A    0x30         0x30      ADDRESS           addr imp 0x1a\n        0x0B    0x55         0x55      SSTORE            0x1a\n        0x0C    0x3d         0x3d      RETURNDATASIZE    0 0x1a\n        0x0D    0xf3         0xf3      RETURN\n        [...deployed code]\n\n    flat deploy function: 0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\n*/\n\nconst WalletContractBytecode = '0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3';\nconst maxCachedConfigs = 10;\nconst listKey = '@sequence.config.imageHashes';\n\nconst configKey = imageHash => `@sequence.config.${imageHash}`;\n\nlet storage;\n\ntry {\n  storage = localStorage;\n} catch (_unused) {\n  const map = new Map();\n  storage = {\n    getItem: key => {\n      var _map$get;\n\n      return (_map$get = map.get(key)) != null ? _map$get : null;\n    },\n    setItem: (key, value) => map.set(key, value),\n    removeItem: key => map.delete(key)\n  };\n}\n\nfunction getCachedConfig(imageHash) {\n  var _storage$getItem;\n\n  const config = JSON.parse((_storage$getItem = storage.getItem(configKey(imageHash))) != null ? _storage$getItem : 'null');\n\n  if (config) {\n    pushImageHash(imageHash);\n    return config;\n  } else {\n    return;\n  }\n}\n\nfunction cacheConfig(imageHash, config) {\n  storage.setItem(configKey(imageHash), JSON.stringify(config));\n  pushImageHash(imageHash);\n}\n\nfunction pushImageHash(imageHash) {\n  var _storage$getItem2;\n\n  let imageHashes = JSON.parse((_storage$getItem2 = storage.getItem(listKey)) != null ? _storage$getItem2 : '[]');\n  imageHashes = imageHashes.filter(hash => hash !== imageHash);\n  imageHashes.push(imageHash);\n\n  while (imageHashes.length > maxCachedConfigs) {\n    storage.removeItem(configKey(imageHashes.shift()));\n  }\n\n  storage.setItem(listKey, JSON.stringify(imageHashes));\n} // and control the wallet\n// TODO: createWalletConfig and genConfig are very similar, lets update + remove one\n\n\nconst createWalletConfig = async (threshold, signers) => {\n  const config = {\n    threshold,\n    signers: []\n  };\n  signers.forEach(async s => {\n    config.signers.push({\n      weight: s.weight,\n      address: Signer.isSigner(s.signer) ? await s.signer.getAddress() : s.signer\n    });\n  });\n\n  if (!isUsableConfig(config)) {\n    throw new Error('wallet config is not usable');\n  }\n\n  return config;\n}; // isUsableConfig checks if a the sum of the owners in the configuration meets the necessary threshold to sign a transaction\n// a wallet that has a non-usable configuration is not able to perform any transactions, and can be considered as destroyed\n\n\nconst isUsableConfig = config => {\n  const sum = config.signers.reduce((p, c) => ethers.BigNumber.from(c.weight).add(p), ethers.constants.Zero);\n  return sum.gte(ethers.BigNumber.from(config.threshold));\n};\n\nconst isValidConfigSigners = (config, signers) => {\n  if (signers.length === 0) return true;\n  const a = config.signers.map(s => ethers.utils.getAddress(s.address));\n  const b = signers.map(s => ethers.utils.getAddress(s));\n  let valid = true;\n  b.forEach(s => {\n    if (!a.includes(s)) valid = false;\n  });\n  return valid;\n};\n\nconst addressOf = function (salt, context) {\n  let ignoreAddress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (typeof salt === 'string') {\n    const codeHash = ethers.utils.keccak256(ethers.utils.solidityPack(['bytes', 'bytes32'], [WalletContractBytecode, ethers.utils.hexZeroPad(context.mainModule, 32)]));\n    const hash = ethers.utils.keccak256(ethers.utils.solidityPack(['bytes1', 'address', 'bytes32', 'bytes32'], ['0xff', context.factory, salt, codeHash]));\n    return ethers.utils.getAddress(ethers.utils.hexDataSlice(hash, 12));\n  }\n\n  if (salt.address && !ignoreAddress) return salt.address;\n  return addressOf(imageHash(salt), context);\n};\n\nconst imageHash = config => {\n  config = sortConfig(config);\n  const imageHash = config.signers.reduce((imageHash, signer) => ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['bytes32', 'uint8', 'address'], [imageHash, signer.weight, signer.address])), ethers.utils.solidityPack(['uint256'], [config.threshold]));\n  cacheConfig(imageHash, config);\n  return imageHash;\n}; // sortConfig normalizes the list of signer addreses in a WalletConfig\n\n\nconst sortConfig = config => {\n  config.signers.sort((a, b) => compareAddr(a.address, b.address)); // normalize\n\n  config.signers.forEach(s => s.address = ethers.utils.getAddress(s.address));\n  if (config.address) config.address = ethers.utils.getAddress(config.address); // ensure no duplicate signers in the config\n\n  const signers = config.signers.map(s => s.address);\n  const signerDupes = signers.filter((c, i) => signers.indexOf(c) !== i);\n\n  if (signerDupes.length > 0) {\n    throw new Error('invalid wallet config: duplicate signer addresses detected in the config, ${signerDupes}');\n  }\n\n  return config;\n};\n\nconst isConfigEqual = (a, b) => {\n  return imageHash(a) === imageHash(b);\n};\n\nconst compareAddr = (a, b) => {\n  const bigA = ethers.BigNumber.from(a);\n  const bigB = ethers.BigNumber.from(b);\n\n  if (bigA.lt(bigB)) {\n    return -1;\n  } else if (bigA.eq(bigB)) {\n    return 0;\n  } else {\n    return 1;\n  }\n};\n\nfunction editConfig(config, args) {\n  const normSigner = s => ({\n    weight: ethers.BigNumber.from(s.weight).toNumber(),\n    address: ethers.utils.getAddress(s.address)\n  });\n\n  const normSrcSigners = config.signers.map(normSigner);\n  const normSetSigners = args.set ? args.set.map(normSigner) : [];\n  const normDelAddress = args.del ? args.del.map(a => ethers.utils.getAddress(a.address)) : [];\n  const normSetAddress = normSetSigners.map(s => s.address);\n  const newSigners = normSrcSigners.filter(s => normDelAddress.indexOf(s.address) === -1 && normSetAddress.indexOf(s.address) === -1).concat(...normSetSigners);\n  return sortConfig({\n    address: config.address,\n    threshold: args.threshold ? ethers.BigNumber.from(args.threshold).toNumber() : config.threshold,\n    signers: newSigners\n  });\n} // TODO: very similar to createWalletConfig, but doesn't allow an AbstractSigner object\n// TODO: lets also check isUsableConfig before returning it\n\n\nfunction genConfig(threshold, signers) {\n  return sortConfig({\n    threshold: ethers.BigNumber.from(threshold).toNumber(),\n    signers: signers.map(s => ({\n      weight: ethers.BigNumber.from(s.weight).toNumber(),\n      address: ethers.utils.getAddress(s.address)\n    }))\n  });\n}\n\nclass ConfigFinder {\n  constructor() {\n    this.findCurrentConfig = void 0;\n    this.findLastWalletOfInitialSigner = void 0;\n  }\n\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nclass SequenceUtilsFinder {\n  constructor(authProvider) {\n    var _this = this;\n\n    this.authProvider = authProvider;\n\n    this.findCurrentConfig = async function (args) {\n      const {\n        provider,\n        context,\n        ignoreIndex,\n        requireIndex,\n        skipCache\n      } = args;\n      const address = ethers.utils.getAddress(args.address);\n      logger.info(`[findCurrentConfig] address:${address}, ignoreIndex:${ignoreIndex}, requireIndex:${requireIndex}`);\n      if (requireIndex && ignoreIndex) throw Error(`findCurrentConfig: can't ignore index and require index`);\n      const chainIdPromise = provider.getNetwork();\n      const knownConfigs = args.knownConfigs ? args.knownConfigs : []; // Get imageHash of wallet\n\n      const {\n        imageHash,\n        config\n      } = await _this.findCurrentImageHash(context, provider, address, knownConfigs, skipCache);\n      if (imageHash === undefined) return {\n        config: undefined\n      }; // Get config for that imageHash\n\n      const found = await _this.findConfigForImageHash(context, imageHash, config ? [config, ...knownConfigs] : knownConfigs, skipCache);\n      const chainId = (await chainIdPromise).chainId;\n      return {\n        config: found ? _extends({}, found, {\n          chainId,\n          address\n        }) : undefined\n      };\n    };\n\n    this.findLastWalletOfInitialSigner = async function (args) {\n      const {\n        signer,\n        context,\n        ignoreIndex,\n        requireIndex\n      } = args;\n      logger.info(`[findLastWalletOfInitialSigner] signer:${signer}`);\n      if (requireIndex && ignoreIndex) throw Error(`findCurrentConfig: can't ignore index and require index`);\n      const authContract = new Contract(context.sequenceUtils, walletContracts.sequenceUtils.abi, _this.authProvider);\n      const logBlockHeight = ignoreIndex ? 0 : (await authContract.lastSignerUpdate(signer)).toNumber();\n      if (requireIndex && logBlockHeight === 0) return {\n        wallet: undefined\n      };\n      const filter = authContract.filters.RequiredSigner(null, signer);\n      const lastLog = await _this.findLatestLog(_this.authProvider, _extends({}, filter, {\n        fromBlock: logBlockHeight,\n        toBlock: logBlockHeight !== 0 ? logBlockHeight : 'latest'\n      }));\n\n      if (lastLog === undefined) {\n        logger.warn('publishConfig: wallet config last log not found');\n        return {\n          wallet: undefined\n        };\n      }\n\n      const event = authContract.interface.decodeEventLog('RequiredSigner', lastLog.data, lastLog.topics);\n      return {\n        wallet: event._wallet\n      };\n    };\n\n    this.findConfigForImageHash = async function (context, image) {\n      let knownConfigs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      let skipCache = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      // Lookup config in known configurations\n      const found = knownConfigs.find(kc => imageHash(kc) === image);\n      if (found) return found; // Lookup config in cached configurations\n\n      if (!skipCache) {\n        const cached = getCachedConfig(image);\n\n        if (cached) {\n          return cached;\n        }\n      }\n\n      logger.info(`[findConfigForImageHash] image:${image}`); // Load index for last imageHash update\n\n      const authContract = new Contract(context.sequenceUtils, walletContracts.sequenceUtils.abi, _this.authProvider);\n      const imageHashHeight = (await authContract.lastImageHashUpdate(image)).toNumber(); // Get requireConfig with imageHash info\n\n      const filter = authContract.filters.RequiredConfig(undefined, image);\n      const lastLog = await _this.findLatestLog(_this.authProvider, _extends({}, filter, {\n        fromBlock: imageHashHeight,\n        toBlock: imageHashHeight !== 0 ? imageHashHeight : 'latest'\n      })); // If there is no log, and no knownConfig...\n      // the config is not found\n\n      if (lastLog === undefined) return undefined;\n      const event = authContract.interface.decodeEventLog('RequiredConfig', lastLog.data, lastLog.topics);\n      const signers = ethers.utils.defaultAbiCoder.decode([`tuple(\n        uint256 weight,\n        address signer\n      )[]`], event._signers)[0];\n      const config = {\n        threshold: ethers.BigNumber.from(event._threshold).toNumber(),\n        signers: signers.map(s => ({\n          address: s.signer,\n          weight: ethers.BigNumber.from(s.weight).toNumber()\n        }))\n      }; // Cache this config\n\n      imageHash(config);\n      return config;\n    };\n\n    this.findCurrentImageHash = async function (context, provider, address) {\n      let knownConfigs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      let skipCache = arguments.length > 4 ? arguments[4] : undefined;\n      logger.info(`[findCurrentImageHash] address:${address}`);\n      const walletContract = new Contract(address, walletContracts.mainModuleUpgradable.abi, provider);\n      const currentImageHash = await walletContract.functions.imageHash.call([]).catch(() => []); // Wallet is not counterfactual and has a defined imageHash\n\n      if (currentImageHash[0] !== undefined) {\n        return {\n          imageHash: currentImageHash[0],\n          config: skipCache ? undefined : getCachedConfig(currentImageHash[0])\n        };\n      } // Wallet is in counter-factual mode\n      // Lookup config in known configurations\n\n\n      const normalizedAddress = ethers.utils.getAddress(address);\n      const found = knownConfigs.find(kc => addressOf(kc, context, true) === normalizedAddress);\n      if (found) return {\n        imageHash: imageHash(found),\n        config: found\n      }; // Call wallet index\n\n      const authContract = new Contract(context.sequenceUtils, walletContracts.sequenceUtils.abi, _this.authProvider);\n      const knownImageHash = await authContract.knownImageHashes(address);\n\n      if (knownImageHash !== ethers.constants.HashZero) {\n        if (addressOf(knownImageHash, context) !== address) throw Error('findCurrentImageHash: inconsistent RequireUtils results');\n        return {\n          imageHash: knownImageHash\n        };\n      } // Get known image hash from raw logs, as last resort\n\n\n      const filter = authContract.filters.RequiredConfig(address);\n      const log = await _this.findFirstLog(_this.authProvider, filter);\n\n      if (log !== undefined) {\n        const event = authContract.interface.decodeEventLog('RequiredConfig', log.data, log.topics);\n        const signers = ethers.utils.defaultAbiCoder.decode([`tuple(\n          uint256 weight,\n          address signer\n        )[]`], event._signers)[0];\n        const config = {\n          threshold: ethers.BigNumber.from(event._threshold).toNumber(),\n          signers: signers.map(s => ({\n            address: s.signer,\n            weight: ethers.BigNumber.from(s.weight).toNumber()\n          }))\n        };\n        const gotImageHash = imageHash(config);\n\n        if (addressOf(gotImageHash, context) === address) {\n          return {\n            imageHash: gotImageHash,\n            config\n          };\n        }\n      } // Counter-factual imageHash not found\n\n\n      return {};\n    };\n\n    this.findLatestLog = async function (provider, filter) {\n      const toBlock = filter.toBlock === 'latest' ? await provider.getBlockNumber() : filter.toBlock;\n      const fromBlock = filter.fromBlock;\n\n      if (fromBlock === 0) {\n        logger.warn(`findLatestLog: expensive getLogs query fromBlock 0 toBlock ${toBlock}`);\n      }\n\n      try {\n        const logs = await provider.getLogs(_extends({}, filter, {\n          toBlock: toBlock\n        }));\n        return logs.length === 0 ? undefined : logs[logs.length - 1];\n      } catch (e) {\n        // TODO Don't assume all errors are bad\n        const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock);\n        const nhalf = await _this.findLatestLog(provider, _extends({}, filter, {\n          fromBlock: pivot,\n          toBlock: toBlock\n        }));\n        if (nhalf !== undefined) return nhalf;\n        return _this.findLatestLog(provider, _extends({}, filter, {\n          fromBlock: fromBlock,\n          toBlock: pivot\n        }));\n      }\n    };\n\n    this.findFirstLog = async function (provider, filter) {\n      const toBlock = filter.toBlock === 'latest' || !filter.toBlock ? await provider.getBlockNumber() : filter.toBlock;\n      const fromBlock = filter.fromBlock ? filter.fromBlock : 0;\n\n      if (fromBlock === 0) {\n        logger.warn(`findFirstLog: expensive getLogs query fromBlock 0 toBlock ${toBlock}`);\n      }\n\n      try {\n        const logs = await provider.getLogs(_extends({}, filter, {\n          fromBlock,\n          toBlock\n        }));\n        return logs.length === 0 ? undefined : logs[0];\n      } catch (e) {\n        // TODO Don't assume all errors are bad\n        const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock);\n        const nhalf = await _this.findFirstLog(provider, _extends({}, filter, {\n          fromBlock,\n          toBlock: pivot\n        }));\n        if (nhalf !== undefined) return nhalf;\n        return _this.findFirstLog(provider, _extends({}, filter, {\n          fromBlock: pivot,\n          toBlock\n        }));\n      }\n    };\n  }\n\n}\n\nfunction isDecodedAddress(cand) {\n  const c = cand;\n  return c.address !== undefined && !isDecodedSigner(cand);\n}\n\nfunction isDecodedSigner(cand) {\n  return isDecodedEOASigner(cand) || isDecodedEOASplitSigner(cand) || isDecodedFullSigner(cand);\n}\n\nfunction isDecodedEOASigner(cand) {\n  const c = cand;\n  return c.signature !== undefined && c.address === undefined;\n}\n\nfunction isDecodedEOASplitSigner(cand) {\n  const c = cand;\n  return c.r !== undefined && c.s !== undefined && c.v !== undefined && c.t !== undefined;\n}\n\nfunction isDecodedFullSigner(cand) {\n  const c = cand;\n  return c.address !== undefined && c.signature !== undefined;\n}\n\nlet SignatureType;\n\n(function (SignatureType) {\n  SignatureType[SignatureType[\"EOA\"] = 0] = \"EOA\";\n  SignatureType[SignatureType[\"Address\"] = 1] = \"Address\";\n  SignatureType[SignatureType[\"Full\"] = 2] = \"Full\";\n})(SignatureType || (SignatureType = {}));\n\nconst decodeSignature = signature => {\n  if (typeof signature !== 'string') return signature;\n  const auxsig = signature.replace('0x', '');\n  const threshold = ethers.BigNumber.from(`0x${auxsig.slice(0, 4)}`).toNumber();\n  const signers = [];\n\n  for (let rindex = 4; rindex < auxsig.length;) {\n    const signatureType = ethers.BigNumber.from(auxsig.slice(rindex, rindex + 2)).toNumber();\n    rindex += 2;\n    const weight = ethers.BigNumber.from(`0x${auxsig.slice(rindex, rindex + 2)}`).toNumber();\n    rindex += 2;\n\n    switch (signatureType) {\n      case SignatureType.Address:\n        const addr = ethers.utils.getAddress(auxsig.slice(rindex, rindex + 40));\n        rindex += 40;\n        signers.push({\n          weight: weight,\n          address: addr\n        });\n        break;\n\n      case SignatureType.EOA:\n        const sig = ethers.utils.arrayify(`0x${auxsig.slice(rindex, rindex + 132)}`);\n        rindex += 132;\n        const split = ethers.utils.splitSignature(sig.slice(0, 65));\n        const r = split.r;\n        const s = split.s;\n        const v = split.v;\n        const t = ethers.BigNumber.from(sig[sig.length - 1]).toNumber();\n        signers.push({\n          weight: weight,\n          signature: sig,\n          r: r,\n          s: s,\n          v: v,\n          t: t\n        });\n        break;\n\n      case SignatureType.Full:\n        const address = ethers.utils.getAddress(auxsig.slice(rindex, rindex + 40));\n        rindex += 40;\n        const size = ethers.BigNumber.from(`0x${auxsig.slice(rindex, rindex + 4)}`).mul(2).toNumber();\n        rindex += 4;\n\n        const _signature = ethers.utils.arrayify(`0x${auxsig.slice(rindex, rindex + size)}`);\n\n        rindex += size;\n        signers.push({\n          weight: weight,\n          address: address,\n          signature: _signature\n        });\n        break;\n\n      default:\n        throw Error('Signature type not supported');\n    }\n  }\n\n  return {\n    threshold: threshold,\n    signers: signers\n  };\n};\n\nconst SIG_TYPE_EIP712 = 1;\nconst SIG_TYPE_ETH_SIGN = 2;\nconst SIG_TYPE_WALLET_BYTES32 = 3;\n\nconst splitDecodedEOASigner = sig => {\n  const signature = ethers.utils.arrayify(sig.signature);\n  const split = ethers.utils.splitSignature(signature.slice(0, 65));\n  const t = ethers.BigNumber.from(signature[signature.length - 1]).toNumber();\n  return _extends({}, sig, split, {\n    t: t\n  });\n};\n\nconst recoverEOASigner = (digest, sig) => {\n  const signature = isDecodedEOASplitSigner(sig) ? sig : splitDecodedEOASigner(sig);\n\n  switch (signature.t) {\n    case SIG_TYPE_EIP712:\n      return ethers.utils.recoverAddress(digest, {\n        r: signature.r,\n        s: signature.s,\n        v: signature.v\n      });\n\n    case SIG_TYPE_ETH_SIGN:\n      const subDigest = ethers.utils.keccak256(ethers.utils.solidityPack(['string', 'bytes32'], ['\\x19Ethereum Signed Message:\\n32', digest]));\n      return ethers.utils.recoverAddress(subDigest, {\n        r: signature.r,\n        s: signature.s,\n        v: signature.v\n      });\n\n    default:\n      throw new Error('Unknown signature');\n  }\n};\n\nconst joinSignatures = function () {\n  for (var _len = arguments.length, signatures = new Array(_len), _key = 0; _key < _len; _key++) {\n    signatures[_key] = arguments[_key];\n  }\n\n  const parts = signatures.map(s => typeof s === 'string' ? decodeSignature(s) : s);\n  return parts.reduce((p, c) => joinTwoSignatures(p, c));\n};\n\nconst joinTwoSignatures = (a, b) => {\n  return {\n    threshold: a.threshold,\n    signers: a.signers.map((s, i) => isDecodedAddress(s) ? b.signers[i] : s)\n  };\n};\n\nconst encodeSignature = sig => {\n  if (typeof sig === 'string') return encodeSignature(decodeSignature(sig));\n  const accountBytes = sig.signers.map(s => {\n    if (isDecodedAddress(s)) {\n      return ethers.utils.solidityPack(['uint8', 'uint8', 'address'], [SignatureType.Address, s.weight, s.address]);\n    }\n\n    if (isDecodedEOASplitSigner(s)) {\n      return ethers.utils.solidityPack(['uint8', 'uint8', 'bytes32', 'bytes32', 'uint8', 'uint8'], [SignatureType.EOA, s.weight, s.r, s.s, s.v, s.t]);\n    }\n\n    if (isDecodedFullSigner(s)) {\n      const signatureSize = ethers.utils.arrayify(s.signature).length;\n      return ethers.utils.solidityPack(['uint8', 'uint8', 'address', 'uint16', 'bytes'], [SignatureType.Full, s.weight, s.address, signatureSize, s.signature]);\n    }\n\n    if (isDecodedEOASigner(s)) {\n      return ethers.utils.solidityPack(['uint8', 'uint8', 'bytes'], [SignatureType.EOA, s.weight, s.signature]);\n    }\n\n    throw Error('Unkwnown signature part type');\n  });\n  return ethers.utils.solidityPack(['uint16', ...Array(accountBytes.length).fill('bytes')], [sig.threshold, ...accountBytes]);\n};\n\nfunction signerOf(part, digest) {\n  if (isDecodedAddress(part)) {\n    return part.address;\n  }\n\n  if (isDecodedFullSigner(part)) {\n    return part.address;\n  }\n\n  if (isDecodedEOASplitSigner(part) || isDecodedEOASigner(part)) {\n    return recoverEOASigner(digest, part);\n  }\n\n  throw Error('Unkwnown signature part type');\n}\n\nfunction mutateSignature(sig, config, digest) {\n  const allSigners = sig.signers.map(s => signerOf(s, digest));\n  return {\n    threshold: config.threshold,\n    signers: config.signers.map(s => {\n      const found = allSigners.indexOf(s.address);\n\n      if (found !== -1) {\n        const part = sig.signers[found];\n        return _extends({}, part, {\n          weight: s.weight\n        });\n      }\n\n      return {\n        weight: s.weight,\n        address: s.address\n      };\n    })\n  };\n}\n\nasync function buildStubSignature(provider, config) {\n  const multicallProvider = new multicall.providers.MulticallProvider(provider); // Pre-load if signers are EOAs or not\n\n  const signers = await Promise.all(config.signers.map(async (s, i) => {\n    return _extends({}, s, {\n      index: i,\n      isEOA: ethers.utils.arrayify(await multicallProvider.getCode(s.address)).length === 0\n    });\n  })); // Sort signers by weight\n  // and prepare them for selection\n\n  let sortedSigners = signers.sort((a, b) => a.weight - b.weight); // Keep track of the total signing power\n\n  let totalWeight = 0; // First pick non-eoa signers\n\n  sortedSigners = sortedSigners.map(s => {\n    if (totalWeight >= config.threshold || s.isEOA) return s;\n    totalWeight += s.weight;\n    return _extends({}, s, {\n      willSign: true\n    });\n  }); // If we still haven't reached threshold\n  // start picking non-EOA signers\n\n  if (totalWeight < config.threshold) {\n    sortedSigners = sortedSigners.map(s => {\n      if (s.willSign || totalWeight >= config.threshold) return s;\n      totalWeight += s.weight;\n      return _extends({}, s, {\n        willSign: true\n      });\n    });\n  } // Stub signature part\n  // pre-determined signature, tailored for worse-case scenario in gas costs\n\n\n  const stubSig = ethers.utils.arrayify(\"0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a01b02\"); // Re-sort signers by original index\n\n  const finalSigners = sortedSigners.sort((a, b) => a.index - b.index); // Map final signers to signature parts\n\n  return {\n    threshold: config.threshold,\n    signers: finalSigners.map(s => {\n      // If wallet shouldn't sign\n      // just return address part\n      if (!s.willSign) {\n        return {\n          address: s.address,\n          weight: s.weight\n        };\n      } // If wallet is EOA return signature\n      // part is with stubSign\n\n\n      if (s.isEOA) {\n        return {\n          weight: s.weight,\n          signature: stubSig\n        };\n      } // If wallet is a contract\n      // build a stub nested signature\n\n\n      return {\n        weight: s.weight,\n        address: s.address,\n        signature: encodeSignature({\n          threshold: 1,\n          signers: [{\n            address: ethers.Wallet.createRandom().address,\n            weight: 1\n          }, {\n            weight: 1,\n            signature: stubSig\n          }]\n        }) + ethers.utils.hexlify(SIG_TYPE_WALLET_BYTES32).substring(2)\n      };\n    })\n  };\n}\n\nexport { ConfigFinder, SequenceUtilsFinder, SignatureType, WalletContractBytecode, addressOf, buildStubSignature, compareAddr, createWalletConfig, decodeSignature, editConfig, encodeSignature, genConfig, imageHash, isConfigEqual, isDecodedAddress, isDecodedEOASigner, isDecodedEOASplitSigner, isDecodedFullSigner, isDecodedSigner, isUsableConfig, isValidConfigSigners, joinSignatures, joinTwoSignatures, mutateSignature, recoverEOASigner, signerOf, sortConfig, splitDecodedEOASigner };","map":{"version":3,"names":["Signer","ethers","Contract","walletContracts","logger","multicall","WalletContractBytecode","maxCachedConfigs","listKey","configKey","imageHash","storage","localStorage","_unused","map","Map","getItem","key","_map$get","get","setItem","value","set","removeItem","delete","getCachedConfig","_storage$getItem","config","JSON","parse","pushImageHash","cacheConfig","stringify","_storage$getItem2","imageHashes","filter","hash","push","length","shift","createWalletConfig","threshold","signers","forEach","s","weight","address","isSigner","signer","getAddress","isUsableConfig","Error","sum","reduce","p","c","BigNumber","from","add","constants","Zero","gte","isValidConfigSigners","a","utils","b","valid","includes","addressOf","salt","context","ignoreAddress","codeHash","keccak256","solidityPack","hexZeroPad","mainModule","factory","hexDataSlice","sortConfig","defaultAbiCoder","encode","sort","compareAddr","signerDupes","i","indexOf","isConfigEqual","bigA","bigB","lt","eq","editConfig","args","normSigner","toNumber","normSrcSigners","normSetSigners","normDelAddress","del","normSetAddress","newSigners","concat","genConfig","ConfigFinder","constructor","findCurrentConfig","findLastWalletOfInitialSigner","_extends","Object","assign","target","arguments","source","prototype","hasOwnProperty","call","apply","SequenceUtilsFinder","authProvider","_this","provider","ignoreIndex","requireIndex","skipCache","info","chainIdPromise","getNetwork","knownConfigs","findCurrentImageHash","undefined","found","findConfigForImageHash","chainId","authContract","sequenceUtils","abi","logBlockHeight","lastSignerUpdate","wallet","filters","RequiredSigner","lastLog","findLatestLog","fromBlock","toBlock","warn","event","interface","decodeEventLog","data","topics","_wallet","image","find","kc","cached","imageHashHeight","lastImageHashUpdate","RequiredConfig","decode","_signers","_threshold","walletContract","mainModuleUpgradable","currentImageHash","functions","catch","normalizedAddress","knownImageHash","knownImageHashes","HashZero","log","findFirstLog","gotImageHash","getBlockNumber","logs","getLogs","e","pivot","Math","floor","nhalf","isDecodedAddress","cand","isDecodedSigner","isDecodedEOASigner","isDecodedEOASplitSigner","isDecodedFullSigner","signature","r","v","t","SignatureType","decodeSignature","auxsig","replace","slice","rindex","signatureType","Address","addr","EOA","sig","arrayify","split","splitSignature","Full","size","mul","_signature","SIG_TYPE_EIP712","SIG_TYPE_ETH_SIGN","SIG_TYPE_WALLET_BYTES32","splitDecodedEOASigner","recoverEOASigner","digest","recoverAddress","subDigest","joinSignatures","signatures","parts","joinTwoSignatures","encodeSignature","accountBytes","signatureSize","Array","fill","signerOf","part","mutateSignature","allSigners","buildStubSignature","multicallProvider","providers","MulticallProvider","Promise","all","index","isEOA","getCode","sortedSigners","totalWeight","willSign","stubSig","finalSigners","Wallet","createRandom","hexlify","substring"],"sources":["C:/Users/rishi/contract-poc/ThriEstate/Brandvilla/node_modules/@0xsequence/config/dist/0xsequence-config.esm.js"],"sourcesContent":["import { Signer, ethers, Contract } from 'ethers';\nimport { walletContracts } from '@0xsequence/abi';\nimport { logger } from '@0xsequence/utils';\nimport * as multicall from '@0xsequence/multicall';\n\n/* tslint:disable */\n\n/**\n    Minimal upgradeable proxy implementation, delegates all calls to the address\n    defined by the storage slot matching the wallet address.\n\n    Inspired by EIP-1167 Implementation (https://eips.ethereum.org/EIPS/eip-1167)\n\n    deployed code:\n\n        0x00    0x36         0x36      CALLDATASIZE      cds\n        0x01    0x3d         0x3d      RETURNDATASIZE    0 cds\n        0x02    0x3d         0x3d      RETURNDATASIZE    0 0 cds\n        0x03    0x37         0x37      CALLDATACOPY\n        0x04    0x3d         0x3d      RETURNDATASIZE    0\n        0x05    0x3d         0x3d      RETURNDATASIZE    0 0\n        0x06    0x3d         0x3d      RETURNDATASIZE    0 0 0\n        0x07    0x36         0x36      CALLDATASIZE      cds 0 0 0\n        0x08    0x3d         0x3d      RETURNDATASIZE    0 cds 0 0 0\n        0x09    0x30         0x30      ADDRESS           addr 0 cds 0 0 0\n        0x0A    0x54         0x54      SLOAD             imp 0 cds 0 0 0\n        0x0B    0x5a         0x5a      GAS               gas imp 0 cds 0 0 0\n        0x0C    0xf4         0xf4      DELEGATECALL      suc 0\n        0x0D    0x3d         0x3d      RETURNDATASIZE    rds suc 0\n        0x0E    0x82         0x82      DUP3              0 rds suc 0\n        0x0F    0x80         0x80      DUP1              0 0 rds suc 0\n        0x10    0x3e         0x3e      RETURNDATACOPY    suc 0\n        0x11    0x90         0x90      SWAP1             0 suc\n        0x12    0x3d         0x3d      RETURNDATASIZE    rds 0 suc\n        0x13    0x91         0x91      SWAP2             suc 0 rds\n        0x14    0x60 0x18    0x6018    PUSH1             0x18 suc 0 rds\n    /-- 0x16    0x57         0x57      JUMPI             0 rds\n    |   0x17    0xfd         0xfd      REVERT\n    \\-> 0x18    0x5b         0x5b      JUMPDEST          0 rds\n        0x19    0xf3         0xf3      RETURN\n\n    flat deployed code: 0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\n\n    deploy function:\n\n        0x00    0x60 0x3a    0x603a    PUSH1             0x3a\n        0x02    0x60 0x0e    0x600e    PUSH1             0x0e 0x3a\n        0x04    0x3d         0x3d      RETURNDATASIZE    0 0x0e 0x3a\n        0x05    0x39         0x39      CODECOPY\n        0x06    0x60 0x1a    0x601a    PUSH1             0x1a\n        0x08    0x80         0x80      DUP1              0x1a 0x1a\n        0x09    0x51         0x51      MLOAD             imp 0x1a\n        0x0A    0x30         0x30      ADDRESS           addr imp 0x1a\n        0x0B    0x55         0x55      SSTORE            0x1a\n        0x0C    0x3d         0x3d      RETURNDATASIZE    0 0x1a\n        0x0D    0xf3         0xf3      RETURN\n        [...deployed code]\n\n    flat deploy function: 0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\n*/\nconst WalletContractBytecode = '0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3';\n\nconst maxCachedConfigs = 10;\nconst listKey = '@sequence.config.imageHashes';\n\nconst configKey = imageHash => `@sequence.config.${imageHash}`;\n\nlet storage;\n\ntry {\n  storage = localStorage;\n} catch (_unused) {\n  const map = new Map();\n  storage = {\n    getItem: key => {\n      var _map$get;\n\n      return (_map$get = map.get(key)) != null ? _map$get : null;\n    },\n    setItem: (key, value) => map.set(key, value),\n    removeItem: key => map.delete(key)\n  };\n}\n\nfunction getCachedConfig(imageHash) {\n  var _storage$getItem;\n\n  const config = JSON.parse((_storage$getItem = storage.getItem(configKey(imageHash))) != null ? _storage$getItem : 'null');\n\n  if (config) {\n    pushImageHash(imageHash);\n    return config;\n  } else {\n    return;\n  }\n}\nfunction cacheConfig(imageHash, config) {\n  storage.setItem(configKey(imageHash), JSON.stringify(config));\n  pushImageHash(imageHash);\n}\n\nfunction pushImageHash(imageHash) {\n  var _storage$getItem2;\n\n  let imageHashes = JSON.parse((_storage$getItem2 = storage.getItem(listKey)) != null ? _storage$getItem2 : '[]');\n  imageHashes = imageHashes.filter(hash => hash !== imageHash);\n  imageHashes.push(imageHash);\n\n  while (imageHashes.length > maxCachedConfigs) {\n    storage.removeItem(configKey(imageHashes.shift()));\n  }\n\n  storage.setItem(listKey, JSON.stringify(imageHashes));\n}\n\n// and control the wallet\n\n// TODO: createWalletConfig and genConfig are very similar, lets update + remove one\nconst createWalletConfig = async (threshold, signers) => {\n  const config = {\n    threshold,\n    signers: []\n  };\n  signers.forEach(async s => {\n    config.signers.push({\n      weight: s.weight,\n      address: Signer.isSigner(s.signer) ? await s.signer.getAddress() : s.signer\n    });\n  });\n\n  if (!isUsableConfig(config)) {\n    throw new Error('wallet config is not usable');\n  }\n\n  return config;\n}; // isUsableConfig checks if a the sum of the owners in the configuration meets the necessary threshold to sign a transaction\n// a wallet that has a non-usable configuration is not able to perform any transactions, and can be considered as destroyed\n\nconst isUsableConfig = config => {\n  const sum = config.signers.reduce((p, c) => ethers.BigNumber.from(c.weight).add(p), ethers.constants.Zero);\n  return sum.gte(ethers.BigNumber.from(config.threshold));\n};\nconst isValidConfigSigners = (config, signers) => {\n  if (signers.length === 0) return true;\n  const a = config.signers.map(s => ethers.utils.getAddress(s.address));\n  const b = signers.map(s => ethers.utils.getAddress(s));\n  let valid = true;\n  b.forEach(s => {\n    if (!a.includes(s)) valid = false;\n  });\n  return valid;\n};\nconst addressOf = (salt, context, ignoreAddress = false) => {\n  if (typeof salt === 'string') {\n    const codeHash = ethers.utils.keccak256(ethers.utils.solidityPack(['bytes', 'bytes32'], [WalletContractBytecode, ethers.utils.hexZeroPad(context.mainModule, 32)]));\n    const hash = ethers.utils.keccak256(ethers.utils.solidityPack(['bytes1', 'address', 'bytes32', 'bytes32'], ['0xff', context.factory, salt, codeHash]));\n    return ethers.utils.getAddress(ethers.utils.hexDataSlice(hash, 12));\n  }\n\n  if (salt.address && !ignoreAddress) return salt.address;\n  return addressOf(imageHash(salt), context);\n};\nconst imageHash = config => {\n  config = sortConfig(config);\n  const imageHash = config.signers.reduce((imageHash, signer) => ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['bytes32', 'uint8', 'address'], [imageHash, signer.weight, signer.address])), ethers.utils.solidityPack(['uint256'], [config.threshold]));\n  cacheConfig(imageHash, config);\n  return imageHash;\n}; // sortConfig normalizes the list of signer addreses in a WalletConfig\n\nconst sortConfig = config => {\n  config.signers.sort((a, b) => compareAddr(a.address, b.address)); // normalize\n\n  config.signers.forEach(s => s.address = ethers.utils.getAddress(s.address));\n  if (config.address) config.address = ethers.utils.getAddress(config.address); // ensure no duplicate signers in the config\n\n  const signers = config.signers.map(s => s.address);\n  const signerDupes = signers.filter((c, i) => signers.indexOf(c) !== i);\n\n  if (signerDupes.length > 0) {\n    throw new Error('invalid wallet config: duplicate signer addresses detected in the config, ${signerDupes}');\n  }\n\n  return config;\n};\nconst isConfigEqual = (a, b) => {\n  return imageHash(a) === imageHash(b);\n};\nconst compareAddr = (a, b) => {\n  const bigA = ethers.BigNumber.from(a);\n  const bigB = ethers.BigNumber.from(b);\n\n  if (bigA.lt(bigB)) {\n    return -1;\n  } else if (bigA.eq(bigB)) {\n    return 0;\n  } else {\n    return 1;\n  }\n};\nfunction editConfig(config, args) {\n  const normSigner = s => ({\n    weight: ethers.BigNumber.from(s.weight).toNumber(),\n    address: ethers.utils.getAddress(s.address)\n  });\n\n  const normSrcSigners = config.signers.map(normSigner);\n  const normSetSigners = args.set ? args.set.map(normSigner) : [];\n  const normDelAddress = args.del ? args.del.map(a => ethers.utils.getAddress(a.address)) : [];\n  const normSetAddress = normSetSigners.map(s => s.address);\n  const newSigners = normSrcSigners.filter(s => normDelAddress.indexOf(s.address) === -1 && normSetAddress.indexOf(s.address) === -1).concat(...normSetSigners);\n  return sortConfig({\n    address: config.address,\n    threshold: args.threshold ? ethers.BigNumber.from(args.threshold).toNumber() : config.threshold,\n    signers: newSigners\n  });\n} // TODO: very similar to createWalletConfig, but doesn't allow an AbstractSigner object\n// TODO: lets also check isUsableConfig before returning it\n\nfunction genConfig(threshold, signers) {\n  return sortConfig({\n    threshold: ethers.BigNumber.from(threshold).toNumber(),\n    signers: signers.map(s => ({\n      weight: ethers.BigNumber.from(s.weight).toNumber(),\n      address: ethers.utils.getAddress(s.address)\n    }))\n  });\n}\n\nclass ConfigFinder {\n  constructor() {\n    this.findCurrentConfig = void 0;\n    this.findLastWalletOfInitialSigner = void 0;\n  }\n\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nclass SequenceUtilsFinder {\n  constructor(authProvider) {\n    var _this = this;\n\n    this.authProvider = authProvider;\n\n    this.findCurrentConfig = async function (args) {\n      const {\n        provider,\n        context,\n        ignoreIndex,\n        requireIndex,\n        skipCache\n      } = args;\n      const address = ethers.utils.getAddress(args.address);\n      logger.info(`[findCurrentConfig] address:${address}, ignoreIndex:${ignoreIndex}, requireIndex:${requireIndex}`);\n      if (requireIndex && ignoreIndex) throw Error(`findCurrentConfig: can't ignore index and require index`);\n      const chainIdPromise = provider.getNetwork();\n      const knownConfigs = args.knownConfigs ? args.knownConfigs : []; // Get imageHash of wallet\n\n      const {\n        imageHash,\n        config\n      } = await _this.findCurrentImageHash(context, provider, address, knownConfigs, skipCache);\n      if (imageHash === undefined) return {\n        config: undefined\n      }; // Get config for that imageHash\n\n      const found = await _this.findConfigForImageHash(context, imageHash, config ? [config, ...knownConfigs] : knownConfigs, skipCache);\n      const chainId = (await chainIdPromise).chainId;\n      return {\n        config: found ? _extends({}, found, {\n          chainId,\n          address\n        }) : undefined\n      };\n    };\n\n    this.findLastWalletOfInitialSigner = async function (args) {\n      const {\n        signer,\n        context,\n        ignoreIndex,\n        requireIndex\n      } = args;\n      logger.info(`[findLastWalletOfInitialSigner] signer:${signer}`);\n      if (requireIndex && ignoreIndex) throw Error(`findCurrentConfig: can't ignore index and require index`);\n      const authContract = new Contract(context.sequenceUtils, walletContracts.sequenceUtils.abi, _this.authProvider);\n      const logBlockHeight = ignoreIndex ? 0 : (await authContract.lastSignerUpdate(signer)).toNumber();\n      if (requireIndex && logBlockHeight === 0) return {\n        wallet: undefined\n      };\n      const filter = authContract.filters.RequiredSigner(null, signer);\n      const lastLog = await _this.findLatestLog(_this.authProvider, _extends({}, filter, {\n        fromBlock: logBlockHeight,\n        toBlock: logBlockHeight !== 0 ? logBlockHeight : 'latest'\n      }));\n\n      if (lastLog === undefined) {\n        logger.warn('publishConfig: wallet config last log not found');\n        return {\n          wallet: undefined\n        };\n      }\n\n      const event = authContract.interface.decodeEventLog('RequiredSigner', lastLog.data, lastLog.topics);\n      return {\n        wallet: event._wallet\n      };\n    };\n\n    this.findConfigForImageHash = async function (context, image, knownConfigs = [], skipCache = false) {\n      // Lookup config in known configurations\n      const found = knownConfigs.find(kc => imageHash(kc) === image);\n      if (found) return found; // Lookup config in cached configurations\n\n      if (!skipCache) {\n        const cached = getCachedConfig(image);\n\n        if (cached) {\n          return cached;\n        }\n      }\n\n      logger.info(`[findConfigForImageHash] image:${image}`); // Load index for last imageHash update\n\n      const authContract = new Contract(context.sequenceUtils, walletContracts.sequenceUtils.abi, _this.authProvider);\n      const imageHashHeight = (await authContract.lastImageHashUpdate(image)).toNumber(); // Get requireConfig with imageHash info\n\n      const filter = authContract.filters.RequiredConfig(undefined, image);\n      const lastLog = await _this.findLatestLog(_this.authProvider, _extends({}, filter, {\n        fromBlock: imageHashHeight,\n        toBlock: imageHashHeight !== 0 ? imageHashHeight : 'latest'\n      })); // If there is no log, and no knownConfig...\n      // the config is not found\n\n      if (lastLog === undefined) return undefined;\n      const event = authContract.interface.decodeEventLog('RequiredConfig', lastLog.data, lastLog.topics);\n      const signers = ethers.utils.defaultAbiCoder.decode([`tuple(\n        uint256 weight,\n        address signer\n      )[]`], event._signers)[0];\n      const config = {\n        threshold: ethers.BigNumber.from(event._threshold).toNumber(),\n        signers: signers.map(s => ({\n          address: s.signer,\n          weight: ethers.BigNumber.from(s.weight).toNumber()\n        }))\n      }; // Cache this config\n\n      imageHash(config);\n      return config;\n    };\n\n    this.findCurrentImageHash = async function (context, provider, address, knownConfigs = [], skipCache) {\n      logger.info(`[findCurrentImageHash] address:${address}`);\n      const walletContract = new Contract(address, walletContracts.mainModuleUpgradable.abi, provider);\n      const currentImageHash = await walletContract.functions.imageHash.call([]).catch(() => []); // Wallet is not counterfactual and has a defined imageHash\n\n      if (currentImageHash[0] !== undefined) {\n        return {\n          imageHash: currentImageHash[0],\n          config: skipCache ? undefined : getCachedConfig(currentImageHash[0])\n        };\n      } // Wallet is in counter-factual mode\n      // Lookup config in known configurations\n\n\n      const normalizedAddress = ethers.utils.getAddress(address);\n      const found = knownConfigs.find(kc => addressOf(kc, context, true) === normalizedAddress);\n      if (found) return {\n        imageHash: imageHash(found),\n        config: found\n      }; // Call wallet index\n\n      const authContract = new Contract(context.sequenceUtils, walletContracts.sequenceUtils.abi, _this.authProvider);\n      const knownImageHash = await authContract.knownImageHashes(address);\n\n      if (knownImageHash !== ethers.constants.HashZero) {\n        if (addressOf(knownImageHash, context) !== address) throw Error('findCurrentImageHash: inconsistent RequireUtils results');\n        return {\n          imageHash: knownImageHash\n        };\n      } // Get known image hash from raw logs, as last resort\n\n\n      const filter = authContract.filters.RequiredConfig(address);\n      const log = await _this.findFirstLog(_this.authProvider, filter);\n\n      if (log !== undefined) {\n        const event = authContract.interface.decodeEventLog('RequiredConfig', log.data, log.topics);\n        const signers = ethers.utils.defaultAbiCoder.decode([`tuple(\n          uint256 weight,\n          address signer\n        )[]`], event._signers)[0];\n        const config = {\n          threshold: ethers.BigNumber.from(event._threshold).toNumber(),\n          signers: signers.map(s => ({\n            address: s.signer,\n            weight: ethers.BigNumber.from(s.weight).toNumber()\n          }))\n        };\n        const gotImageHash = imageHash(config);\n\n        if (addressOf(gotImageHash, context) === address) {\n          return {\n            imageHash: gotImageHash,\n            config\n          };\n        }\n      } // Counter-factual imageHash not found\n\n\n      return {};\n    };\n\n    this.findLatestLog = async function (provider, filter) {\n      const toBlock = filter.toBlock === 'latest' ? await provider.getBlockNumber() : filter.toBlock;\n      const fromBlock = filter.fromBlock;\n\n      if (fromBlock === 0) {\n        logger.warn(`findLatestLog: expensive getLogs query fromBlock 0 toBlock ${toBlock}`);\n      }\n\n      try {\n        const logs = await provider.getLogs(_extends({}, filter, {\n          toBlock: toBlock\n        }));\n        return logs.length === 0 ? undefined : logs[logs.length - 1];\n      } catch (e) {\n        // TODO Don't assume all errors are bad\n        const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock);\n        const nhalf = await _this.findLatestLog(provider, _extends({}, filter, {\n          fromBlock: pivot,\n          toBlock: toBlock\n        }));\n        if (nhalf !== undefined) return nhalf;\n        return _this.findLatestLog(provider, _extends({}, filter, {\n          fromBlock: fromBlock,\n          toBlock: pivot\n        }));\n      }\n    };\n\n    this.findFirstLog = async function (provider, filter) {\n      const toBlock = filter.toBlock === 'latest' || !filter.toBlock ? await provider.getBlockNumber() : filter.toBlock;\n      const fromBlock = filter.fromBlock ? filter.fromBlock : 0;\n\n      if (fromBlock === 0) {\n        logger.warn(`findFirstLog: expensive getLogs query fromBlock 0 toBlock ${toBlock}`);\n      }\n\n      try {\n        const logs = await provider.getLogs(_extends({}, filter, {\n          fromBlock,\n          toBlock\n        }));\n        return logs.length === 0 ? undefined : logs[0];\n      } catch (e) {\n        // TODO Don't assume all errors are bad\n        const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock);\n        const nhalf = await _this.findFirstLog(provider, _extends({}, filter, {\n          fromBlock,\n          toBlock: pivot\n        }));\n        if (nhalf !== undefined) return nhalf;\n        return _this.findFirstLog(provider, _extends({}, filter, {\n          fromBlock: pivot,\n          toBlock\n        }));\n      }\n    };\n  }\n\n}\n\nfunction isDecodedAddress(cand) {\n  const c = cand;\n  return c.address !== undefined && !isDecodedSigner(cand);\n}\nfunction isDecodedSigner(cand) {\n  return isDecodedEOASigner(cand) || isDecodedEOASplitSigner(cand) || isDecodedFullSigner(cand);\n}\nfunction isDecodedEOASigner(cand) {\n  const c = cand;\n  return c.signature !== undefined && c.address === undefined;\n}\nfunction isDecodedEOASplitSigner(cand) {\n  const c = cand;\n  return c.r !== undefined && c.s !== undefined && c.v !== undefined && c.t !== undefined;\n}\nfunction isDecodedFullSigner(cand) {\n  const c = cand;\n  return c.address !== undefined && c.signature !== undefined;\n}\nlet SignatureType;\n\n(function (SignatureType) {\n  SignatureType[SignatureType[\"EOA\"] = 0] = \"EOA\";\n  SignatureType[SignatureType[\"Address\"] = 1] = \"Address\";\n  SignatureType[SignatureType[\"Full\"] = 2] = \"Full\";\n})(SignatureType || (SignatureType = {}));\n\nconst decodeSignature = signature => {\n  if (typeof signature !== 'string') return signature;\n  const auxsig = signature.replace('0x', '');\n  const threshold = ethers.BigNumber.from(`0x${auxsig.slice(0, 4)}`).toNumber();\n  const signers = [];\n\n  for (let rindex = 4; rindex < auxsig.length;) {\n    const signatureType = ethers.BigNumber.from(auxsig.slice(rindex, rindex + 2)).toNumber();\n    rindex += 2;\n    const weight = ethers.BigNumber.from(`0x${auxsig.slice(rindex, rindex + 2)}`).toNumber();\n    rindex += 2;\n\n    switch (signatureType) {\n      case SignatureType.Address:\n        const addr = ethers.utils.getAddress(auxsig.slice(rindex, rindex + 40));\n        rindex += 40;\n        signers.push({\n          weight: weight,\n          address: addr\n        });\n        break;\n\n      case SignatureType.EOA:\n        const sig = ethers.utils.arrayify(`0x${auxsig.slice(rindex, rindex + 132)}`);\n        rindex += 132;\n        const split = ethers.utils.splitSignature(sig.slice(0, 65));\n        const r = split.r;\n        const s = split.s;\n        const v = split.v;\n        const t = ethers.BigNumber.from(sig[sig.length - 1]).toNumber();\n        signers.push({\n          weight: weight,\n          signature: sig,\n          r: r,\n          s: s,\n          v: v,\n          t: t\n        });\n        break;\n\n      case SignatureType.Full:\n        const address = ethers.utils.getAddress(auxsig.slice(rindex, rindex + 40));\n        rindex += 40;\n        const size = ethers.BigNumber.from(`0x${auxsig.slice(rindex, rindex + 4)}`).mul(2).toNumber();\n        rindex += 4;\n\n        const _signature = ethers.utils.arrayify(`0x${auxsig.slice(rindex, rindex + size)}`);\n\n        rindex += size;\n        signers.push({\n          weight: weight,\n          address: address,\n          signature: _signature\n        });\n        break;\n\n      default:\n        throw Error('Signature type not supported');\n    }\n  }\n\n  return {\n    threshold: threshold,\n    signers: signers\n  };\n};\nconst SIG_TYPE_EIP712 = 1;\nconst SIG_TYPE_ETH_SIGN = 2;\nconst SIG_TYPE_WALLET_BYTES32 = 3;\nconst splitDecodedEOASigner = sig => {\n  const signature = ethers.utils.arrayify(sig.signature);\n  const split = ethers.utils.splitSignature(signature.slice(0, 65));\n  const t = ethers.BigNumber.from(signature[signature.length - 1]).toNumber();\n  return _extends({}, sig, split, {\n    t: t\n  });\n};\nconst recoverEOASigner = (digest, sig) => {\n  const signature = isDecodedEOASplitSigner(sig) ? sig : splitDecodedEOASigner(sig);\n\n  switch (signature.t) {\n    case SIG_TYPE_EIP712:\n      return ethers.utils.recoverAddress(digest, {\n        r: signature.r,\n        s: signature.s,\n        v: signature.v\n      });\n\n    case SIG_TYPE_ETH_SIGN:\n      const subDigest = ethers.utils.keccak256(ethers.utils.solidityPack(['string', 'bytes32'], ['\\x19Ethereum Signed Message:\\n32', digest]));\n      return ethers.utils.recoverAddress(subDigest, {\n        r: signature.r,\n        s: signature.s,\n        v: signature.v\n      });\n\n    default:\n      throw new Error('Unknown signature');\n  }\n};\nconst joinSignatures = (...signatures) => {\n  const parts = signatures.map(s => typeof s === 'string' ? decodeSignature(s) : s);\n  return parts.reduce((p, c) => joinTwoSignatures(p, c));\n};\nconst joinTwoSignatures = (a, b) => {\n  return {\n    threshold: a.threshold,\n    signers: a.signers.map((s, i) => isDecodedAddress(s) ? b.signers[i] : s)\n  };\n};\nconst encodeSignature = sig => {\n  if (typeof sig === 'string') return encodeSignature(decodeSignature(sig));\n  const accountBytes = sig.signers.map(s => {\n    if (isDecodedAddress(s)) {\n      return ethers.utils.solidityPack(['uint8', 'uint8', 'address'], [SignatureType.Address, s.weight, s.address]);\n    }\n\n    if (isDecodedEOASplitSigner(s)) {\n      return ethers.utils.solidityPack(['uint8', 'uint8', 'bytes32', 'bytes32', 'uint8', 'uint8'], [SignatureType.EOA, s.weight, s.r, s.s, s.v, s.t]);\n    }\n\n    if (isDecodedFullSigner(s)) {\n      const signatureSize = ethers.utils.arrayify(s.signature).length;\n      return ethers.utils.solidityPack(['uint8', 'uint8', 'address', 'uint16', 'bytes'], [SignatureType.Full, s.weight, s.address, signatureSize, s.signature]);\n    }\n\n    if (isDecodedEOASigner(s)) {\n      return ethers.utils.solidityPack(['uint8', 'uint8', 'bytes'], [SignatureType.EOA, s.weight, s.signature]);\n    }\n\n    throw Error('Unkwnown signature part type');\n  });\n  return ethers.utils.solidityPack(['uint16', ...Array(accountBytes.length).fill('bytes')], [sig.threshold, ...accountBytes]);\n};\nfunction signerOf(part, digest) {\n  if (isDecodedAddress(part)) {\n    return part.address;\n  }\n\n  if (isDecodedFullSigner(part)) {\n    return part.address;\n  }\n\n  if (isDecodedEOASplitSigner(part) || isDecodedEOASigner(part)) {\n    return recoverEOASigner(digest, part);\n  }\n\n  throw Error('Unkwnown signature part type');\n}\nfunction mutateSignature(sig, config, digest) {\n  const allSigners = sig.signers.map(s => signerOf(s, digest));\n  return {\n    threshold: config.threshold,\n    signers: config.signers.map(s => {\n      const found = allSigners.indexOf(s.address);\n\n      if (found !== -1) {\n        const part = sig.signers[found];\n        return _extends({}, part, {\n          weight: s.weight\n        });\n      }\n\n      return {\n        weight: s.weight,\n        address: s.address\n      };\n    })\n  };\n}\nasync function buildStubSignature(provider, config) {\n  const multicallProvider = new multicall.providers.MulticallProvider(provider); // Pre-load if signers are EOAs or not\n\n  const signers = await Promise.all(config.signers.map(async (s, i) => {\n    return _extends({}, s, {\n      index: i,\n      isEOA: ethers.utils.arrayify(await multicallProvider.getCode(s.address)).length === 0\n    });\n  })); // Sort signers by weight\n  // and prepare them for selection\n\n  let sortedSigners = signers.sort((a, b) => a.weight - b.weight); // Keep track of the total signing power\n\n  let totalWeight = 0; // First pick non-eoa signers\n\n  sortedSigners = sortedSigners.map(s => {\n    if (totalWeight >= config.threshold || s.isEOA) return s;\n    totalWeight += s.weight;\n    return _extends({}, s, {\n      willSign: true\n    });\n  }); // If we still haven't reached threshold\n  // start picking non-EOA signers\n\n  if (totalWeight < config.threshold) {\n    sortedSigners = sortedSigners.map(s => {\n      if (s.willSign || totalWeight >= config.threshold) return s;\n      totalWeight += s.weight;\n      return _extends({}, s, {\n        willSign: true\n      });\n    });\n  } // Stub signature part\n  // pre-determined signature, tailored for worse-case scenario in gas costs\n\n\n  const stubSig = ethers.utils.arrayify(\"0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a01b02\"); // Re-sort signers by original index\n\n  const finalSigners = sortedSigners.sort((a, b) => a.index - b.index); // Map final signers to signature parts\n\n  return {\n    threshold: config.threshold,\n    signers: finalSigners.map(s => {\n      // If wallet shouldn't sign\n      // just return address part\n      if (!s.willSign) {\n        return {\n          address: s.address,\n          weight: s.weight\n        };\n      } // If wallet is EOA return signature\n      // part is with stubSign\n\n\n      if (s.isEOA) {\n        return {\n          weight: s.weight,\n          signature: stubSig\n        };\n      } // If wallet is a contract\n      // build a stub nested signature\n\n\n      return {\n        weight: s.weight,\n        address: s.address,\n        signature: encodeSignature({\n          threshold: 1,\n          signers: [{\n            address: ethers.Wallet.createRandom().address,\n            weight: 1\n          }, {\n            weight: 1,\n            signature: stubSig\n          }]\n        }) + ethers.utils.hexlify(SIG_TYPE_WALLET_BYTES32).substring(2)\n      };\n    })\n  };\n}\n\nexport { ConfigFinder, SequenceUtilsFinder, SignatureType, WalletContractBytecode, addressOf, buildStubSignature, compareAddr, createWalletConfig, decodeSignature, editConfig, encodeSignature, genConfig, imageHash, isConfigEqual, isDecodedAddress, isDecodedEOASigner, isDecodedEOASplitSigner, isDecodedFullSigner, isDecodedSigner, isUsableConfig, isValidConfigSigners, joinSignatures, joinTwoSignatures, mutateSignature, recoverEOASigner, signerOf, sortConfig, splitDecodedEOASigner };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}