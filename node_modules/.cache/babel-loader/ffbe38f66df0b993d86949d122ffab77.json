{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar car = require('@ipld/car');\n\nvar block = require('multiformats/block');\n\nvar raw = require('multiformats/codecs/raw');\n\nvar dagCbor = require('@ipld/dag-cbor');\n\nvar pb = require('@ipld/dag-pb');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar raw__namespace = /*#__PURE__*/_interopNamespace(raw);\n\nvar dagCbor__namespace = /*#__PURE__*/_interopNamespace(dagCbor);\n\nvar pb__namespace = /*#__PURE__*/_interopNamespace(pb);\n\nclass TreewalkCarSplitter {\n  constructor(reader, targetSize) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (typeof targetSize !== 'number' || targetSize <= 0) {\n      throw new Error('invalid target chunk size');\n    }\n\n    this._reader = reader;\n    this._targetSize = targetSize;\n    this._decoders = [pb__namespace, raw__namespace, dagCbor__namespace, ...(options.decoders || [])];\n  }\n\n  async *cars() {\n    const roots = await this._reader.getRoots();\n    if (roots.length !== 1) throw new Error(`unexpected number of roots: ${roots.length}`);\n    let channel;\n\n    for await (const val of this._cars(roots[0])) {\n      channel = val.channel;\n      if (val.out) yield val.out;\n    }\n\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n\n    channel.writer.close();\n    yield channel.out;\n  }\n\n  async _get(cid) {\n    const rawBlock = await this._reader.get(cid);\n    if (!rawBlock) throw new Error(`missing block for ${cid}`);\n    const {\n      bytes\n    } = rawBlock;\n\n    const decoder = this._decoders.find(d => d.code === cid.code);\n\n    if (!decoder) throw new Error(`missing decoder for ${cid.code}`);\n    return new block.Block({\n      cid,\n      bytes,\n      value: decoder.decode(bytes)\n    });\n  }\n\n  async *_cars(cid) {\n    let parents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let channel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    const block = await this._get(cid);\n    channel = channel || Object.assign(car.CarWriter.create(cid), {\n      size: 0\n    });\n\n    if (channel.size > 0 && channel.size + block.bytes.byteLength >= this._targetSize) {\n      channel.writer.close();\n      const {\n        out\n      } = channel;\n      channel = newCar(parents);\n      yield {\n        channel,\n        out\n      };\n    }\n\n    parents = parents.concat(block);\n    channel.size += block.bytes.byteLength;\n    channel.writer.put(block);\n\n    for (const [, cid] of block.links()) {\n      for await (const val of this._cars(cid, parents, channel)) {\n        channel = val.channel;\n        yield val;\n      }\n    }\n\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n\n    yield {\n      channel\n    };\n  }\n\n  static async fromIterable(iterable, targetSize, options) {\n    const reader = await car.CarReader.fromIterable(iterable);\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n\n  static async fromBlob(blob, targetSize, options) {\n    const buffer = await blob.arrayBuffer();\n    const reader = await car.CarReader.fromBytes(new Uint8Array(buffer));\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n\n}\n\nfunction newCar(parents) {\n  const ch = Object.assign(car.CarWriter.create(parents[0].cid), {\n    size: parents.reduce((size, b) => size + b.bytes.byteLength, 0)\n  });\n\n  for (const b of parents) {\n    ch.writer.put(b);\n  }\n\n  return ch;\n}\n\nexports.TreewalkCarSplitter = TreewalkCarSplitter;","map":{"version":3,"names":["Object","defineProperty","exports","value","car","require","block","raw","dagCbor","pb","_interopNamespace","e","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","raw__namespace","dagCbor__namespace","pb__namespace","TreewalkCarSplitter","constructor","reader","targetSize","options","Error","_reader","_targetSize","_decoders","decoders","cars","roots","getRoots","length","channel","val","_cars","out","writer","close","_get","cid","rawBlock","bytes","decoder","find","code","Block","decode","parents","undefined","assign","CarWriter","size","byteLength","newCar","concat","put","links","fromIterable","iterable","CarReader","fromBlob","blob","buffer","arrayBuffer","fromBytes","Uint8Array","ch","reduce","b"],"sources":["C:/Users/rishi/contract-poc/ThriEstate/ThriEstate/node_modules/carbites/cjs/lib/treewalk/splitter.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar car = require('@ipld/car');\nvar block = require('multiformats/block');\nvar raw = require('multiformats/codecs/raw');\nvar dagCbor = require('@ipld/dag-cbor');\nvar pb = require('@ipld/dag-pb');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar raw__namespace = /*#__PURE__*/_interopNamespace(raw);\nvar dagCbor__namespace = /*#__PURE__*/_interopNamespace(dagCbor);\nvar pb__namespace = /*#__PURE__*/_interopNamespace(pb);\n\nclass TreewalkCarSplitter {\n  constructor(reader, targetSize, options = {}) {\n    if (typeof targetSize !== 'number' || targetSize <= 0) {\n      throw new Error('invalid target chunk size');\n    }\n    this._reader = reader;\n    this._targetSize = targetSize;\n    this._decoders = [\n      pb__namespace,\n      raw__namespace,\n      dagCbor__namespace,\n      ...options.decoders || []\n    ];\n  }\n  async *cars() {\n    const roots = await this._reader.getRoots();\n    if (roots.length !== 1)\n      throw new Error(`unexpected number of roots: ${ roots.length }`);\n    let channel;\n    for await (const val of this._cars(roots[0])) {\n      channel = val.channel;\n      if (val.out)\n        yield val.out;\n    }\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n    channel.writer.close();\n    yield channel.out;\n  }\n  async _get(cid) {\n    const rawBlock = await this._reader.get(cid);\n    if (!rawBlock)\n      throw new Error(`missing block for ${ cid }`);\n    const {bytes} = rawBlock;\n    const decoder = this._decoders.find(d => d.code === cid.code);\n    if (!decoder)\n      throw new Error(`missing decoder for ${ cid.code }`);\n    return new block.Block({\n      cid,\n      bytes,\n      value: decoder.decode(bytes)\n    });\n  }\n  async *_cars(cid, parents = [], channel = undefined) {\n    const block = await this._get(cid);\n    channel = channel || Object.assign(car.CarWriter.create(cid), { size: 0 });\n    if (channel.size > 0 && channel.size + block.bytes.byteLength >= this._targetSize) {\n      channel.writer.close();\n      const {out} = channel;\n      channel = newCar(parents);\n      yield {\n        channel,\n        out\n      };\n    }\n    parents = parents.concat(block);\n    channel.size += block.bytes.byteLength;\n    channel.writer.put(block);\n    for (const [, cid] of block.links()) {\n      for await (const val of this._cars(cid, parents, channel)) {\n        channel = val.channel;\n        yield val;\n      }\n    }\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n    yield { channel };\n  }\n  static async fromIterable(iterable, targetSize, options) {\n    const reader = await car.CarReader.fromIterable(iterable);\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n  static async fromBlob(blob, targetSize, options) {\n    const buffer = await blob.arrayBuffer();\n    const reader = await car.CarReader.fromBytes(new Uint8Array(buffer));\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n}\nfunction newCar(parents) {\n  const ch = Object.assign(car.CarWriter.create(parents[0].cid), { size: parents.reduce((size, b) => size + b.bytes.byteLength, 0) });\n  for (const b of parents) {\n    ch.writer.put(b);\n  }\n  return ch;\n}\n\nexports.TreewalkCarSplitter = TreewalkCarSplitter;\n"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,GAAG,GAAGC,OAAO,CAAC,WAAD,CAAjB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,oBAAD,CAAnB;;AACA,IAAIE,GAAG,GAAGF,OAAO,CAAC,yBAAD,CAAjB;;AACA,IAAIG,OAAO,GAAGH,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAII,EAAE,GAAGJ,OAAO,CAAC,cAAD,CAAhB;;AAEA,SAASK,iBAAT,CAA2BC,CAA3B,EAA8B;EAC5B,IAAIA,CAAC,IAAIA,CAAC,CAACC,UAAX,EAAuB,OAAOD,CAAP;EACvB,IAAIE,CAAC,GAAGb,MAAM,CAACc,MAAP,CAAc,IAAd,CAAR;;EACA,IAAIH,CAAJ,EAAO;IACLX,MAAM,CAACe,IAAP,CAAYJ,CAAZ,EAAeK,OAAf,CAAuB,UAAUC,CAAV,EAAa;MAClC,IAAIA,CAAC,KAAK,SAAV,EAAqB;QACnB,IAAIC,CAAC,GAAGlB,MAAM,CAACmB,wBAAP,CAAgCR,CAAhC,EAAmCM,CAAnC,CAAR;QACAjB,MAAM,CAACC,cAAP,CAAsBY,CAAtB,EAAyBI,CAAzB,EAA4BC,CAAC,CAACE,GAAF,GAAQF,CAAR,GAAY;UACtCG,UAAU,EAAE,IAD0B;UAEtCD,GAAG,EAAE,YAAY;YACf,OAAOT,CAAC,CAACM,CAAD,CAAR;UACD;QAJqC,CAAxC;MAMD;IACF,CAVD;EAWD;;EACDJ,CAAC,CAAC,SAAD,CAAD,GAAeF,CAAf;EACA,OAAOX,MAAM,CAACsB,MAAP,CAAcT,CAAd,CAAP;AACD;;AAED,IAAIU,cAAc,GAAG,aAAab,iBAAiB,CAACH,GAAD,CAAnD;;AACA,IAAIiB,kBAAkB,GAAG,aAAad,iBAAiB,CAACF,OAAD,CAAvD;;AACA,IAAIiB,aAAa,GAAG,aAAaf,iBAAiB,CAACD,EAAD,CAAlD;;AAEA,MAAMiB,mBAAN,CAA0B;EACxBC,WAAW,CAACC,MAAD,EAASC,UAAT,EAAmC;IAAA,IAAdC,OAAc,uEAAJ,EAAI;;IAC5C,IAAI,OAAOD,UAAP,KAAsB,QAAtB,IAAkCA,UAAU,IAAI,CAApD,EAAuD;MACrD,MAAM,IAAIE,KAAJ,CAAU,2BAAV,CAAN;IACD;;IACD,KAAKC,OAAL,GAAeJ,MAAf;IACA,KAAKK,WAAL,GAAmBJ,UAAnB;IACA,KAAKK,SAAL,GAAiB,CACfT,aADe,EAEfF,cAFe,EAGfC,kBAHe,EAIf,IAAGM,OAAO,CAACK,QAAR,IAAoB,EAAvB,CAJe,CAAjB;EAMD;;EACU,OAAJC,IAAI,GAAG;IACZ,MAAMC,KAAK,GAAG,MAAM,KAAKL,OAAL,CAAaM,QAAb,EAApB;IACA,IAAID,KAAK,CAACE,MAAN,KAAiB,CAArB,EACE,MAAM,IAAIR,KAAJ,CAAW,+BAA+BM,KAAK,CAACE,MAAQ,EAAxD,CAAN;IACF,IAAIC,OAAJ;;IACA,WAAW,MAAMC,GAAjB,IAAwB,KAAKC,KAAL,CAAWL,KAAK,CAAC,CAAD,CAAhB,CAAxB,EAA8C;MAC5CG,OAAO,GAAGC,GAAG,CAACD,OAAd;MACA,IAAIC,GAAG,CAACE,GAAR,EACE,MAAMF,GAAG,CAACE,GAAV;IACH;;IACD,IAAI,CAACH,OAAL,EAAc;MACZ,MAAM,IAAIT,KAAJ,CAAU,4BAAV,CAAN;IACD;;IACDS,OAAO,CAACI,MAAR,CAAeC,KAAf;IACA,MAAML,OAAO,CAACG,GAAd;EACD;;EACS,MAAJG,IAAI,CAACC,GAAD,EAAM;IACd,MAAMC,QAAQ,GAAG,MAAM,KAAKhB,OAAL,CAAaZ,GAAb,CAAiB2B,GAAjB,CAAvB;IACA,IAAI,CAACC,QAAL,EACE,MAAM,IAAIjB,KAAJ,CAAW,qBAAqBgB,GAAK,EAArC,CAAN;IACF,MAAM;MAACE;IAAD,IAAUD,QAAhB;;IACA,MAAME,OAAO,GAAG,KAAKhB,SAAL,CAAeiB,IAAf,CAAoBjC,CAAC,IAAIA,CAAC,CAACkC,IAAF,KAAWL,GAAG,CAACK,IAAxC,CAAhB;;IACA,IAAI,CAACF,OAAL,EACE,MAAM,IAAInB,KAAJ,CAAW,uBAAuBgB,GAAG,CAACK,IAAM,EAA5C,CAAN;IACF,OAAO,IAAI9C,KAAK,CAAC+C,KAAV,CAAgB;MACrBN,GADqB;MAErBE,KAFqB;MAGrB9C,KAAK,EAAE+C,OAAO,CAACI,MAAR,CAAeL,KAAf;IAHc,CAAhB,CAAP;EAKD;;EACW,OAALP,KAAK,CAACK,GAAD,EAAyC;IAAA,IAAnCQ,OAAmC,uEAAzB,EAAyB;IAAA,IAArBf,OAAqB,uEAAXgB,SAAW;IACnD,MAAMlD,KAAK,GAAG,MAAM,KAAKwC,IAAL,CAAUC,GAAV,CAApB;IACAP,OAAO,GAAGA,OAAO,IAAIxC,MAAM,CAACyD,MAAP,CAAcrD,GAAG,CAACsD,SAAJ,CAAc5C,MAAd,CAAqBiC,GAArB,CAAd,EAAyC;MAAEY,IAAI,EAAE;IAAR,CAAzC,CAArB;;IACA,IAAInB,OAAO,CAACmB,IAAR,GAAe,CAAf,IAAoBnB,OAAO,CAACmB,IAAR,GAAerD,KAAK,CAAC2C,KAAN,CAAYW,UAA3B,IAAyC,KAAK3B,WAAtE,EAAmF;MACjFO,OAAO,CAACI,MAAR,CAAeC,KAAf;MACA,MAAM;QAACF;MAAD,IAAQH,OAAd;MACAA,OAAO,GAAGqB,MAAM,CAACN,OAAD,CAAhB;MACA,MAAM;QACJf,OADI;QAEJG;MAFI,CAAN;IAID;;IACDY,OAAO,GAAGA,OAAO,CAACO,MAAR,CAAexD,KAAf,CAAV;IACAkC,OAAO,CAACmB,IAAR,IAAgBrD,KAAK,CAAC2C,KAAN,CAAYW,UAA5B;IACApB,OAAO,CAACI,MAAR,CAAemB,GAAf,CAAmBzD,KAAnB;;IACA,KAAK,MAAM,GAAGyC,GAAH,CAAX,IAAsBzC,KAAK,CAAC0D,KAAN,EAAtB,EAAqC;MACnC,WAAW,MAAMvB,GAAjB,IAAwB,KAAKC,KAAL,CAAWK,GAAX,EAAgBQ,OAAhB,EAAyBf,OAAzB,CAAxB,EAA2D;QACzDA,OAAO,GAAGC,GAAG,CAACD,OAAd;QACA,MAAMC,GAAN;MACD;IACF;;IACD,IAAI,CAACD,OAAL,EAAc;MACZ,MAAM,IAAIT,KAAJ,CAAU,4BAAV,CAAN;IACD;;IACD,MAAM;MAAES;IAAF,CAAN;EACD;;EACwB,aAAZyB,YAAY,CAACC,QAAD,EAAWrC,UAAX,EAAuBC,OAAvB,EAAgC;IACvD,MAAMF,MAAM,GAAG,MAAMxB,GAAG,CAAC+D,SAAJ,CAAcF,YAAd,CAA2BC,QAA3B,CAArB;IACA,OAAO,IAAIxC,mBAAJ,CAAwBE,MAAxB,EAAgCC,UAAhC,EAA4CC,OAA5C,CAAP;EACD;;EACoB,aAARsC,QAAQ,CAACC,IAAD,EAAOxC,UAAP,EAAmBC,OAAnB,EAA4B;IAC/C,MAAMwC,MAAM,GAAG,MAAMD,IAAI,CAACE,WAAL,EAArB;IACA,MAAM3C,MAAM,GAAG,MAAMxB,GAAG,CAAC+D,SAAJ,CAAcK,SAAd,CAAwB,IAAIC,UAAJ,CAAeH,MAAf,CAAxB,CAArB;IACA,OAAO,IAAI5C,mBAAJ,CAAwBE,MAAxB,EAAgCC,UAAhC,EAA4CC,OAA5C,CAAP;EACD;;AA9EuB;;AAgF1B,SAAS+B,MAAT,CAAgBN,OAAhB,EAAyB;EACvB,MAAMmB,EAAE,GAAG1E,MAAM,CAACyD,MAAP,CAAcrD,GAAG,CAACsD,SAAJ,CAAc5C,MAAd,CAAqByC,OAAO,CAAC,CAAD,CAAP,CAAWR,GAAhC,CAAd,EAAoD;IAAEY,IAAI,EAAEJ,OAAO,CAACoB,MAAR,CAAe,CAAChB,IAAD,EAAOiB,CAAP,KAAajB,IAAI,GAAGiB,CAAC,CAAC3B,KAAF,CAAQW,UAA3C,EAAuD,CAAvD;EAAR,CAApD,CAAX;;EACA,KAAK,MAAMgB,CAAX,IAAgBrB,OAAhB,EAAyB;IACvBmB,EAAE,CAAC9B,MAAH,CAAUmB,GAAV,CAAca,CAAd;EACD;;EACD,OAAOF,EAAP;AACD;;AAEDxE,OAAO,CAACwB,mBAAR,GAA8BA,mBAA9B"},"metadata":{},"sourceType":"script"}