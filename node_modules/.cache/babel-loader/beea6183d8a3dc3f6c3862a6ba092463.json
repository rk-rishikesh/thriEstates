{"ast":null,"code":"import { ethers, providers, Signer } from 'ethers';\nimport { walletContracts } from '@0xsequence/abi';\nimport { sequenceTxAbiEncode, readSequenceNonce, encodeNonce, computeMetaTxnHash, MetaTransactionsType, appendNonce, decodeNonce } from '@0xsequence/transactions';\nimport { isBigNumberish, logger } from '@0xsequence/utils';\nimport { Provider } from '@ethersproject/providers';\nimport { imageHash, addressOf, encodeSignature, buildStubSignature } from '@0xsequence/config';\nimport { Interface } from 'ethers/lib/utils';\nimport fetchPonyfill from 'fetch-ponyfill';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction isBaseRelayerOptions(obj) {\n  return obj.bundleCreation !== undefined && typeof obj.bundleCreation === 'boolean' || obj.creationGasLimit !== undefined && isBigNumberish(obj.creationGasLimit) || obj.provider !== undefined && (providers.Provider.isProvider(obj.provider) || typeof obj.provider === 'string');\n}\n\nconst BaseRelayerDefaults = {\n  bundleCreation: true,\n  creationGasLimit: ethers.constants.Two.pow(17)\n};\n\nclass BaseRelayer {\n  constructor(options) {\n    this.provider = void 0;\n    this.bundleCreation = void 0;\n    this.creationGasLimit = void 0;\n\n    const opts = _extends({}, BaseRelayerDefaults, options);\n\n    this.bundleCreation = opts.bundleCreation;\n    this.provider = opts.provider;\n    this.creationGasLimit = ethers.BigNumber.from(opts.creationGasLimit);\n  }\n\n  async isWalletDeployed(walletAddress) {\n    if (!this.provider) throw new Error('Bundled creation provider not found');\n    return (await this.provider.getCode(walletAddress)) !== '0x';\n  }\n\n  prepareWalletDeploy(config, context) {\n    const factoryInterface = new Interface(walletContracts.factory.abi);\n    return {\n      to: context.factory,\n      data: factoryInterface.encodeFunctionData(factoryInterface.getFunction('deploy'), [context.mainModule, imageHash(config)])\n    };\n  }\n\n  async prependWalletDeploy(signedTransactions) {\n    const {\n      config,\n      context,\n      transactions,\n      nonce,\n      signature\n    } = signedTransactions;\n    const walletAddress = addressOf(config, context);\n    const walletInterface = new Interface(walletContracts.mainModule.abi);\n\n    const encodedSignature = async function () {\n      const sig = await signature;\n      if (typeof sig === 'string') return sig;\n      return encodeSignature(sig);\n    }();\n\n    if (this.bundleCreation && !(await this.isWalletDeployed(walletAddress))) {\n      return {\n        to: context.guestModule,\n        execute: {\n          transactions: [_extends({}, this.prepareWalletDeploy(config, context), {\n            delegateCall: false,\n            revertOnError: false,\n            gasLimit: this.creationGasLimit,\n            value: ethers.constants.Zero\n          }), {\n            delegateCall: false,\n            revertOnError: true,\n            gasLimit: ethers.constants.Zero,\n            to: walletAddress,\n            value: ethers.constants.Zero,\n            data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(transactions), nonce, await encodedSignature])\n          }],\n          nonce: ethers.constants.Zero,\n          signature: '0x'\n        }\n      };\n    } else {\n      return {\n        to: walletAddress,\n        execute: {\n          transactions,\n          nonce: ethers.BigNumber.from(nonce),\n          signature: await encodedSignature\n        }\n      };\n    }\n  }\n\n  async prepareTransactions(config, context, signature) {\n    for (var _len = arguments.length, transactions = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      transactions[_key - 3] = arguments[_key];\n    }\n\n    //, gasLimit?: ethers.BigNumberish }> {\n    const nonce = readSequenceNonce(...transactions);\n\n    if (!nonce) {\n      throw new Error('Unable to prepare transactions without a defined nonce');\n    }\n\n    const {\n      to,\n      execute\n    } = await this.prependWalletDeploy({\n      config,\n      context,\n      transactions,\n      nonce,\n      signature\n    });\n    const walletInterface = new Interface(walletContracts.mainModule.abi);\n    return {\n      to,\n      data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature])\n    };\n  }\n\n}\n\nconst DEFAULT_GAS_LIMIT = ethers.BigNumber.from(800000);\nconst ProviderRelayerDefaults = {\n  waitPollRate: 1000,\n  deltaBlocksLog: 12,\n  fromBlockLog: -1024\n};\n\nfunction isProviderRelayerOptions(obj) {\n  return obj.provider !== undefined && Provider.isProvider(obj.provider);\n}\n\nclass ProviderRelayer extends BaseRelayer {\n  constructor(options) {\n    super(options);\n    this.provider = void 0;\n    this.waitPollRate = void 0;\n    this.deltaBlocksLog = void 0;\n    this.fromBlockLog = void 0;\n\n    const opts = _extends({}, ProviderRelayerDefaults, options);\n\n    this.provider = opts.provider;\n    this.waitPollRate = opts.waitPollRate;\n    this.deltaBlocksLog = opts.deltaBlocksLog;\n    this.fromBlockLog = opts.fromBlockLog;\n  }\n\n  async simulate(wallet) {\n    var _this = this;\n\n    for (var _len2 = arguments.length, transactions = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      transactions[_key2 - 1] = arguments[_key2];\n    }\n\n    return (await Promise.all(transactions.map(async function (tx) {\n      // Respect gasLimit request of the transaction (as long as its not 0)\n      if (tx.gasLimit && !ethers.BigNumber.from(tx.gasLimit || 0).eq(ethers.constants.Zero)) {\n        return tx.gasLimit;\n      } // Fee can't be estimated locally for delegateCalls\n\n\n      if (tx.delegateCall) {\n        return DEFAULT_GAS_LIMIT;\n      } // Fee can't be estimated for self-called if wallet hasn't been deployed\n\n\n      if (tx.to === wallet && !(await _this.isWalletDeployed(wallet))) {\n        return DEFAULT_GAS_LIMIT;\n      }\n\n      if (!_this.provider) {\n        throw new Error('signer.provider is not set, but is required');\n      } // TODO: If the wallet address has been deployed, gas limits can be\n      // estimated with more accurately by using self-calls with the batch transactions one by one\n\n\n      return _this.provider.estimateGas({\n        from: wallet,\n        to: tx.to,\n        data: tx.data,\n        value: tx.value\n      });\n    }))).map(gasLimit => ({\n      executed: true,\n      succeeded: true,\n      gasLimit: ethers.BigNumber.from(gasLimit).toNumber(),\n      gasUsed: ethers.BigNumber.from(gasLimit).toNumber()\n    }));\n  }\n\n  async estimateGasLimits(config, context) {\n    const walletAddr = addressOf(config, context);\n\n    for (var _len3 = arguments.length, transactions = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      transactions[_key3 - 2] = arguments[_key3];\n    }\n\n    const results = await this.simulate(walletAddr, ...transactions);\n    return transactions.map((t, i) => _extends({}, t, {\n      gasLimit: results[i].gasLimit\n    }));\n  }\n\n  async getNonce(config, context, space, blockTag) {\n    if (!this.provider) {\n      throw new Error('provider is not set');\n    }\n\n    const addr = addressOf(config, context);\n\n    if ((await this.provider.getCode(addr)) === '0x') {\n      return 0;\n    }\n\n    if (space === undefined) {\n      space = 0;\n    }\n\n    const module = new ethers.Contract(addr, walletContracts.mainModule.abi, this.provider);\n    const nonce = await module.readNonce(space, {\n      blockTag: blockTag\n    });\n    return encodeNonce(space, nonce);\n  }\n\n  async wait(metaTxnId, timeout) {\n    if (typeof metaTxnId !== 'string') {\n      logger.info(\"computing id\", metaTxnId.config, metaTxnId.context, metaTxnId.chainId, ...metaTxnId.transactions);\n      return this.wait(computeMetaTxnHash(addressOf(metaTxnId.config, metaTxnId.context), metaTxnId.chainId, ...metaTxnId.transactions), timeout);\n    } // Transactions can only get executed on nonce change\n    // get all nonce changes and look for metaTxnIds in between logs\n\n\n    const timeoutTime = new Date().getTime() + timeout;\n    let lastBlock = this.fromBlockLog;\n\n    if (lastBlock < 0) {\n      const block = await this.provider.getBlockNumber();\n      lastBlock = block + lastBlock;\n    }\n\n    const normalMetaTxnId = metaTxnId.replace('0x', '');\n\n    while (new Date().getTime() < timeoutTime) {\n      const block = await this.provider.getBlockNumber();\n      const logs = await this.provider.getLogs({\n        fromBlock: Math.max(0, lastBlock - this.deltaBlocksLog),\n        toBlock: block,\n        // Nonce change event topic\n        topics: ['0x1f180c27086c7a39ea2a7b25239d1ab92348f07ca7bb59d1438fcf527568f881']\n      });\n      lastBlock = block; // Get receipts of all transactions\n\n      const txs = await Promise.all(logs.map(l => this.provider.getTransactionReceipt(l.transactionHash))); // Find a transaction with a TxExecuted log\n\n      const found = txs.find(tx => tx.logs.find(l => l.topics.length === 0 && l.data.replace('0x', '') === normalMetaTxnId || l.topics.length === 1 && // TxFailed event topic\n      l.topics[0] === \"0x3dbd1590ea96dd3253a91f24e64e3a502e1225d602a5731357bc12643070ccd7\" && l.data.length >= 64 && l.data.replace('0x', '').startsWith(normalMetaTxnId))); // If found return that\n\n      if (found) {\n        return _extends({\n          receipt: found\n        }, await this.provider.getTransaction(found.transactionHash));\n      } // Otherwise wait and try again\n\n\n      await new Promise(r => setTimeout(r, this.waitPollRate));\n    }\n\n    throw new Error(`Timeout waiting for transaction receipt ${metaTxnId}`);\n  }\n\n}\n\nfunction isLocalRelayerOptions(obj) {\n  return obj.signer !== undefined && Signer.isSigner(obj.signer);\n}\n\nclass LocalRelayer extends ProviderRelayer {\n  constructor(options) {\n    super(Signer.isSigner(options) ? {\n      provider: options.provider\n    } : _extends({}, options, {\n      provider: options.signer.provider\n    }));\n    this.signer = void 0;\n    this.txnOptions = void 0;\n    this.signer = Signer.isSigner(options) ? options : options.signer;\n    if (!this.signer.provider) throw new Error(\"Signer must have a provider\");\n  }\n\n  async deployWallet(config, context) {\n    // NOTE: on hardhat some tests fail on HookCallerMock when not passing gasLimit directly as below,\n    // and using eth_gasEstimate. Perhaps review HookCallerMock.sol and fix it to avoid what looks\n    // like an infinite loop?\n    const walletDeployTxn = this.prepareWalletDeploy(config, context); // NOTE: for hardhat to pass, we have to set the gasLimit directly, as its unable to estimate\n\n    return this.signer.sendTransaction(_extends({}, walletDeployTxn, {\n      gasLimit: ethers.constants.Two.pow(17)\n    }));\n  }\n\n  async getFeeOptions(_config, _context) {\n    return {\n      options: []\n    };\n  }\n\n  async gasRefundOptions(config, context) {\n    for (var _len4 = arguments.length, transactions = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n      transactions[_key4 - 2] = arguments[_key4];\n    }\n\n    const {\n      options\n    } = await this.getFeeOptions(config, context, ...transactions);\n    return options;\n  }\n\n  setTransactionOptions(transactionRequest) {\n    this.txnOptions = transactionRequest;\n  }\n\n  async relay(signedTxs, quote) {\n    if (quote !== undefined) {\n      logger.warn(`LocalRelayer doesn't accept fee quotes`);\n    }\n\n    if (!signedTxs.context.guestModule || signedTxs.context.guestModule.length !== 42) {\n      throw new Error('LocalRelayer requires the context.guestModule address');\n    }\n\n    const {\n      to,\n      execute\n    } = await this.prependWalletDeploy(signedTxs);\n    const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);\n    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]); // TODO: think about computing gas limit individually, summing together and passing across\n    // NOTE: we expect that all txns have set their gasLimit ahead of time through proper estimation\n    // const gasLimit = signedTxs.transactions.reduce((sum, tx) => sum.add(tx.gasLimit), ethers.BigNumber.from(0))\n    // txRequest.gasLimit = gasLimit\n\n    return this.signer.sendTransaction(_extends({\n      to,\n      data\n    }, this.txnOptions));\n  }\n\n}\n/* eslint-disable */\n// sequence-relayer v0.4.0 4dca0b91c1531d1166ae2f7ebd8af571b0c0e43b\n// --\n// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript\n// Do not edit by hand. Update your webrpc schema and re-generate.\n// WebRPC description and code-gen version\n\n\nconst WebRPCVersion = 'v1'; // Schema version of your RIDL schema\n\nconst WebRPCSchemaVersion = 'v0.4.0'; // Schema hash generated from your RIDL schema\n\nconst WebRPCSchemaHash = '4dca0b91c1531d1166ae2f7ebd8af571b0c0e43b'; //\n// Types\n//\n\nlet ETHTxnStatus;\n\n(function (ETHTxnStatus) {\n  ETHTxnStatus[\"UNKNOWN\"] = \"UNKNOWN\";\n  ETHTxnStatus[\"DROPPED\"] = \"DROPPED\";\n  ETHTxnStatus[\"QUEUED\"] = \"QUEUED\";\n  ETHTxnStatus[\"SENT\"] = \"SENT\";\n  ETHTxnStatus[\"SUCCEEDED\"] = \"SUCCEEDED\";\n  ETHTxnStatus[\"PARTIALLY_FAILED\"] = \"PARTIALLY_FAILED\";\n  ETHTxnStatus[\"FAILED\"] = \"FAILED\";\n})(ETHTxnStatus || (ETHTxnStatus = {}));\n\nlet TransferType;\n\n(function (TransferType) {\n  TransferType[\"SEND\"] = \"SEND\";\n  TransferType[\"RECEIVE\"] = \"RECEIVE\";\n  TransferType[\"BRIDGE_DEPOSIT\"] = \"BRIDGE_DEPOSIT\";\n  TransferType[\"BRIDGE_WITHDRAW\"] = \"BRIDGE_WITHDRAW\";\n  TransferType[\"BURN\"] = \"BURN\";\n  TransferType[\"UNKNOWN\"] = \"UNKNOWN\";\n})(TransferType || (TransferType = {}));\n\nlet FeeTokenType;\n\n(function (FeeTokenType) {\n  FeeTokenType[\"UNKNOWN\"] = \"UNKNOWN\";\n  FeeTokenType[\"ERC20_TOKEN\"] = \"ERC20_TOKEN\";\n  FeeTokenType[\"ERC1155_TOKEN\"] = \"ERC1155_TOKEN\";\n})(FeeTokenType || (FeeTokenType = {}));\n\nlet SortOrder;\n\n(function (SortOrder) {\n  SortOrder[\"DESC\"] = \"DESC\";\n  SortOrder[\"ASC\"] = \"ASC\";\n})(SortOrder || (SortOrder = {})); //\n// Client\n//\n\n\nclass Relayer {\n  constructor(hostname, fetch) {\n    this.hostname = void 0;\n    this.fetch = void 0;\n    this.path = '/rpc/Relayer/';\n\n    this.ping = headers => {\n      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.version = headers => {\n      return this.fetch(this.url('Version'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            version: _data.version\n          };\n        });\n      });\n    };\n\n    this.runtimeStatus = headers => {\n      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.getSequenceContext = headers => {\n      return this.fetch(this.url('GetSequenceContext'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            data: _data.data\n          };\n        });\n      });\n    };\n\n    this.getChainID = headers => {\n      return this.fetch(this.url('GetChainID'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            chainID: _data.chainID\n          };\n        });\n      });\n    };\n\n    this.sendMetaTxn = (args, headers) => {\n      return this.fetch(this.url('SendMetaTxn'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status,\n            txnHash: _data.txnHash\n          };\n        });\n      });\n    };\n\n    this.getMetaTxnNonce = (args, headers) => {\n      return this.fetch(this.url('GetMetaTxnNonce'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            nonce: _data.nonce\n          };\n        });\n      });\n    };\n\n    this.getMetaTxnReceipt = (args, headers) => {\n      return this.fetch(this.url('GetMetaTxnReceipt'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            receipt: _data.receipt\n          };\n        });\n      });\n    };\n\n    this.simulate = (args, headers) => {\n      return this.fetch(this.url('Simulate'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            results: _data.results\n          };\n        });\n      });\n    };\n\n    this.updateMetaTxnGasLimits = (args, headers) => {\n      return this.fetch(this.url('UpdateMetaTxnGasLimits'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            payload: _data.payload\n          };\n        });\n      });\n    };\n\n    this.feeTokens = headers => {\n      return this.fetch(this.url('FeeTokens'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            isFeeRequired: _data.isFeeRequired,\n            tokens: _data.tokens\n          };\n        });\n      });\n    };\n\n    this.feeOptions = (args, headers) => {\n      return this.fetch(this.url('FeeOptions'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            options: _data.options,\n            quote: _data.quote\n          };\n        });\n      });\n    };\n\n    this.getMetaTxnNetworkFeeOptions = (args, headers) => {\n      return this.fetch(this.url('GetMetaTxnNetworkFeeOptions'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            options: _data.options\n          };\n        });\n      });\n    };\n\n    this.sentTransactions = (args, headers) => {\n      return this.fetch(this.url('SentTransactions'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: _data.page,\n            transactions: _data.transactions\n          };\n        });\n      });\n    };\n\n    this.pendingTransactions = (args, headers) => {\n      return this.fetch(this.url('PendingTransactions'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: _data.page,\n            transactions: _data.transactions\n          };\n        });\n      });\n    };\n\n    this.hostname = hostname;\n    this.fetch = fetch;\n  }\n\n  url(name) {\n    return this.hostname + this.path + name;\n  }\n\n}\n\nconst createHTTPRequest = function () {\n  let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return {\n    method: 'POST',\n    headers: _extends({}, headers, {\n      'Content-Type': 'application/json'\n    }),\n    body: JSON.stringify(body || {})\n  };\n};\n\nconst buildResponse = res => {\n  return res.text().then(text => {\n    let data;\n\n    try {\n      data = JSON.parse(text);\n    } catch (err) {\n      throw {\n        code: 'unknown',\n        msg: `expecting JSON, got: ${text}`,\n        status: res.status\n      };\n    }\n\n    if (!res.ok) {\n      throw data; // webrpc error response\n    }\n\n    return data;\n  });\n};\n\nvar relayer_gen = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  WebRPCVersion: WebRPCVersion,\n  WebRPCSchemaVersion: WebRPCSchemaVersion,\n  WebRPCSchemaHash: WebRPCSchemaHash,\n\n  get ETHTxnStatus() {\n    return ETHTxnStatus;\n  },\n\n  get TransferType() {\n    return TransferType;\n  },\n\n  get FeeTokenType() {\n    return FeeTokenType;\n  },\n\n  get SortOrder() {\n    return SortOrder;\n  },\n\n  Relayer: Relayer\n});\nconst FAILED_STATUSES = [ETHTxnStatus.FAILED, ETHTxnStatus.PARTIALLY_FAILED, ETHTxnStatus.DROPPED];\n\nfunction isRpcRelayerOptions(obj) {\n  return obj.url !== undefined && typeof obj.url === 'string';\n}\n\nclass RpcRelayer extends BaseRelayer {\n  constructor(options) {\n    super(options);\n    this.service = void 0;\n    this.service = new Relayer(options.url, fetchPonyfill().fetch);\n  }\n\n  async waitReceipt(metaTxnHash) {\n    let wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n\n    if (typeof metaTxnHash !== 'string') {\n      logger.info('computing id', metaTxnHash.config, metaTxnHash.context, metaTxnHash.chainId, ...metaTxnHash.transactions);\n      return this.waitReceipt(computeMetaTxnHash(addressOf(metaTxnHash.config, metaTxnHash.context), metaTxnHash.chainId, ...metaTxnHash.transactions));\n    }\n\n    logger.info(`[rpc-relayer/waitReceipt] waiting for ${metaTxnHash}`);\n    let result = await this.service.getMetaTxnReceipt({\n      metaTxID: metaTxnHash\n    }); // TODO: remove check for 'UNKNOWN' status when 'QUEUED' status is supported\n    // TODO: fix backend to not return literal 'null' txnReceipt\n\n    while (!result.receipt || !result.receipt.txnReceipt || result.receipt.txnReceipt === 'null' || result.receipt.status === 'UNKNOWN' || result.receipt.status === 'QUEUED' || result.receipt.status === 'SENT') {\n      await new Promise(r => setTimeout(r, wait));\n      result = await this.service.getMetaTxnReceipt({\n        metaTxID: metaTxnHash\n      });\n    }\n\n    return result;\n  }\n\n  async simulate(wallet) {\n    const coder = ethers.utils.defaultAbiCoder;\n\n    for (var _len5 = arguments.length, transactions = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      transactions[_key5 - 1] = arguments[_key5];\n    }\n\n    const encoded = coder.encode([MetaTransactionsType], [sequenceTxAbiEncode(transactions)]);\n    return (await this.service.simulate({\n      wallet,\n      transactions: encoded\n    })).results;\n  }\n\n  async estimateGasLimits(config, context) {\n    for (var _len6 = arguments.length, transactions = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {\n      transactions[_key6 - 2] = arguments[_key6];\n    }\n\n    logger.info(`[rpc-relayer/estimateGasLimits] estimate gas limits request ${JSON.stringify(transactions)}`);\n\n    if (transactions.length == 0) {\n      return [];\n    }\n\n    const addr = addressOf(config, context);\n    const prevNonce = readSequenceNonce(...transactions); // Set temporal nonce to simulate meta-txn\n\n    if (prevNonce === undefined) {\n      transactions = appendNonce(transactions, await this.getNonce(config, context));\n    }\n\n    const coder = ethers.utils.defaultAbiCoder;\n    const encoded = coder.encode([MetaTransactionsType], [sequenceTxAbiEncode(transactions)]);\n    const res = await this.service.updateMetaTxnGasLimits({\n      walletAddress: addr,\n      walletConfig: {\n        address: addr,\n        signers: config.signers,\n        threshold: config.threshold,\n        chainId: config.chainId\n      },\n      payload: encoded\n    });\n    const decoded = coder.decode([MetaTransactionsType], res.payload)[0];\n    const modTxns = transactions.map((t, i) => _extends({}, t, {\n      gasLimit: decoded[i].gasLimit\n    }));\n    logger.info(`[rpc-relayer/estimateGasLimits] got transactions with gas limits ${JSON.stringify(modTxns)}`); // Remove placeholder nonce if previously defined\n\n    return prevNonce === undefined ? modTxns : appendNonce(modTxns, prevNonce);\n  }\n\n  async getFeeOptions(config, context) {\n    // NOTE/TODO: for a given `service` the feeTokens will not change between execution, so we should memoize this value\n    // for a short-period of time, perhaps for 1 day or in memory. Perhaps one day we can make this happen automatically\n    // with http cache response for this endpoint and service-worker.. lots of approaches\n    const feeTokens = await this.service.feeTokens();\n\n    if (feeTokens.isFeeRequired) {\n      const symbols = feeTokens.tokens.map(token => token.symbol).join(', ');\n      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are required, accepted tokens are ${symbols}`);\n      const wallet = addressOf(config, context);\n\n      for (var _len7 = arguments.length, transactions = new Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) {\n        transactions[_key7 - 2] = arguments[_key7];\n      }\n\n      let nonce = readSequenceNonce(...transactions);\n\n      if (nonce === undefined) {\n        nonce = await this.getNonce(config, context);\n      }\n\n      if (!this.provider) {\n        logger.warn(`[rpc-relayer/getFeeOptions] provider not set, needed for stub signature`);\n        throw new Error('provider is not set');\n      }\n\n      const {\n        to,\n        execute\n      } = await this.prependWalletDeploy({\n        config,\n        context,\n        transactions,\n        nonce,\n        signature: buildStubSignature(this.provider, config)\n      });\n      const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);\n      const data = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]);\n      const {\n        options,\n        quote\n      } = await this.service.feeOptions({\n        wallet,\n        to,\n        data\n      });\n      logger.info(`[rpc-relayer/getFeeOptions] got refund options ${JSON.stringify(options)}`);\n      return {\n        options,\n        quote: {\n          _tag: 'FeeQuote',\n          _quote: quote\n        }\n      };\n    } else {\n      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are not required`);\n      return {\n        options: []\n      };\n    }\n  }\n\n  async gasRefundOptions(config, context) {\n    for (var _len8 = arguments.length, transactions = new Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {\n      transactions[_key8 - 2] = arguments[_key8];\n    }\n\n    const {\n      options\n    } = await this.getFeeOptions(config, context, ...transactions);\n    return options;\n  }\n\n  async getNonce(config, context, space) {\n    const addr = addressOf(config, context);\n    logger.info(`[rpc-relayer/getNonce] get nonce for wallet ${addr} space: ${space}`);\n    const encodedNonce = space !== undefined ? ethers.BigNumber.from(space).toHexString() : undefined;\n    const resp = await this.service.getMetaTxnNonce({\n      walletContractAddress: addr,\n      space: encodedNonce\n    });\n    const nonce = ethers.BigNumber.from(resp.nonce);\n    const [decodedSpace, decodedNonce] = decodeNonce(nonce);\n    logger.info(`[rpc-relayer/getNonce] got next nonce for wallet ${addr} ${decodedNonce} space: ${decodedSpace}`);\n    return nonce;\n  }\n\n  async relay(signedTxs, quote) {\n    logger.info(`[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(signedTxs)} with quote ${JSON.stringify(quote)}`);\n    let typecheckedQuote;\n\n    if (quote !== undefined) {\n      if (typeof quote._quote === 'string') {\n        typecheckedQuote = quote._quote;\n      } else {\n        logger.warn('[rpc-relayer/relay] ignoring invalid fee quote');\n      }\n    }\n\n    if (!this.provider) {\n      logger.warn(`[rpc-relayer/relay] provider not set, failed relay`);\n      throw new Error('provider is not set');\n    }\n\n    const {\n      to: contract,\n      execute\n    } = await this.prependWalletDeploy(signedTxs);\n    const walletAddress = addressOf(signedTxs.config, signedTxs.context);\n    const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);\n    const input = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]);\n    const metaTxn = await this.service.sendMetaTxn({\n      call: {\n        walletAddress,\n        contract,\n        input\n      },\n      quote: typecheckedQuote\n    });\n    logger.info(`[rpc-relayer/relay] got relay result ${JSON.stringify(metaTxn)}`);\n    return this.wait(metaTxn.txnHash);\n  }\n\n  async wait(metaTxnHash) {\n    let wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n\n    var _this = this;\n\n    const {\n      receipt\n    } = await this.waitReceipt(metaTxnHash, wait);\n\n    if (!receipt.txnReceipt || FAILED_STATUSES.includes(receipt.status)) {\n      throw new MetaTransactionResponseException(receipt);\n    }\n\n    const txReceipt = JSON.parse(receipt.txnReceipt);\n    return {\n      blockHash: txReceipt.blockHash,\n      blockNumber: ethers.BigNumber.from(txReceipt.blockNumber).toNumber(),\n      confirmations: 1,\n      from: typeof metaTxnHash === 'string' ? undefined : addressOf(metaTxnHash.config, metaTxnHash.context),\n      hash: txReceipt.transactionHash,\n      raw: receipt.txnReceipt,\n      receipt: txReceipt,\n      // extended type which is Sequence-specific. Contains the decoded metaTxReceipt\n      wait: async function (confirmations) {\n        return _this.provider.waitForTransaction(txReceipt.transactionHash, confirmations);\n      }\n    };\n  }\n\n}\n\nclass MetaTransactionResponseException {\n  constructor(receipt) {\n    this.receipt = receipt;\n  }\n\n}\n\nfunction isRelayer(cand) {\n  return typeof cand === 'object' && typeof cand.simulate === 'function' && typeof cand.estimateGasLimits === 'function' && typeof cand.getFeeOptions === 'function' && typeof cand.gasRefundOptions === 'function' && typeof cand.getNonce === 'function' && typeof cand.relay === 'function' && typeof cand.wait === 'function';\n}\n\nexport { BaseRelayer, BaseRelayerDefaults, LocalRelayer, ProviderRelayer, ProviderRelayerDefaults, RpcRelayer, relayer_gen as RpcRelayerProto, isBaseRelayerOptions, isLocalRelayerOptions, isProviderRelayerOptions, isRelayer, isRpcRelayerOptions, relayer_gen as proto };","map":{"version":3,"names":["ethers","providers","Signer","walletContracts","sequenceTxAbiEncode","readSequenceNonce","encodeNonce","computeMetaTxnHash","MetaTransactionsType","appendNonce","decodeNonce","isBigNumberish","logger","Provider","imageHash","addressOf","encodeSignature","buildStubSignature","Interface","fetchPonyfill","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","isBaseRelayerOptions","obj","bundleCreation","undefined","creationGasLimit","provider","isProvider","BaseRelayerDefaults","constants","Two","pow","BaseRelayer","constructor","options","opts","BigNumber","from","isWalletDeployed","walletAddress","Error","getCode","prepareWalletDeploy","config","context","factoryInterface","factory","abi","to","data","encodeFunctionData","getFunction","mainModule","prependWalletDeploy","signedTransactions","transactions","nonce","signature","walletInterface","encodedSignature","sig","guestModule","execute","delegateCall","revertOnError","gasLimit","value","Zero","prepareTransactions","DEFAULT_GAS_LIMIT","ProviderRelayerDefaults","waitPollRate","deltaBlocksLog","fromBlockLog","isProviderRelayerOptions","ProviderRelayer","simulate","wallet","_this","Promise","all","map","tx","eq","estimateGas","executed","succeeded","toNumber","gasUsed","estimateGasLimits","walletAddr","results","t","getNonce","space","blockTag","addr","module","Contract","readNonce","wait","metaTxnId","timeout","info","chainId","timeoutTime","Date","getTime","lastBlock","block","getBlockNumber","normalMetaTxnId","replace","logs","getLogs","fromBlock","Math","max","toBlock","topics","txs","l","getTransactionReceipt","transactionHash","found","find","startsWith","receipt","getTransaction","r","setTimeout","isLocalRelayerOptions","signer","isSigner","LocalRelayer","txnOptions","deployWallet","walletDeployTxn","sendTransaction","getFeeOptions","_config","_context","gasRefundOptions","setTransactionOptions","transactionRequest","relay","signedTxs","quote","warn","utils","WebRPCVersion","WebRPCSchemaVersion","WebRPCSchemaHash","ETHTxnStatus","TransferType","FeeTokenType","SortOrder","Relayer","hostname","fetch","path","ping","headers","url","createHTTPRequest","then","res","buildResponse","_data","status","version","runtimeStatus","getSequenceContext","getChainID","chainID","sendMetaTxn","args","txnHash","getMetaTxnNonce","getMetaTxnReceipt","updateMetaTxnGasLimits","payload","feeTokens","isFeeRequired","tokens","feeOptions","getMetaTxnNetworkFeeOptions","sentTransactions","page","pendingTransactions","name","body","method","JSON","stringify","text","parse","err","code","msg","ok","relayer_gen","freeze","__proto__","FAILED_STATUSES","FAILED","PARTIALLY_FAILED","DROPPED","isRpcRelayerOptions","RpcRelayer","service","waitReceipt","metaTxnHash","result","metaTxID","txnReceipt","coder","defaultAbiCoder","encoded","encode","prevNonce","walletConfig","address","signers","threshold","decoded","decode","modTxns","symbols","token","symbol","join","_tag","_quote","encodedNonce","toHexString","resp","walletContractAddress","decodedSpace","decodedNonce","typecheckedQuote","contract","input","metaTxn","includes","MetaTransactionResponseException","txReceipt","blockHash","blockNumber","confirmations","hash","raw","waitForTransaction","isRelayer","cand","RpcRelayerProto","proto"],"sources":["C:/Users/rishi/contract-poc/ThriEstate/Brandvilla/node_modules/@0xsequence/relayer/dist/0xsequence-relayer.esm.js"],"sourcesContent":["import { ethers, providers, Signer } from 'ethers';\nimport { walletContracts } from '@0xsequence/abi';\nimport { sequenceTxAbiEncode, readSequenceNonce, encodeNonce, computeMetaTxnHash, MetaTransactionsType, appendNonce, decodeNonce } from '@0xsequence/transactions';\nimport { isBigNumberish, logger } from '@0xsequence/utils';\nimport { Provider } from '@ethersproject/providers';\nimport { imageHash, addressOf, encodeSignature, buildStubSignature } from '@0xsequence/config';\nimport { Interface } from 'ethers/lib/utils';\nimport fetchPonyfill from 'fetch-ponyfill';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction isBaseRelayerOptions(obj) {\n  return obj.bundleCreation !== undefined && typeof obj.bundleCreation === 'boolean' || obj.creationGasLimit !== undefined && isBigNumberish(obj.creationGasLimit) || obj.provider !== undefined && (providers.Provider.isProvider(obj.provider) || typeof obj.provider === 'string');\n}\nconst BaseRelayerDefaults = {\n  bundleCreation: true,\n  creationGasLimit: ethers.constants.Two.pow(17)\n};\nclass BaseRelayer {\n  constructor(options) {\n    this.provider = void 0;\n    this.bundleCreation = void 0;\n    this.creationGasLimit = void 0;\n\n    const opts = _extends({}, BaseRelayerDefaults, options);\n\n    this.bundleCreation = opts.bundleCreation;\n    this.provider = opts.provider;\n    this.creationGasLimit = ethers.BigNumber.from(opts.creationGasLimit);\n  }\n\n  async isWalletDeployed(walletAddress) {\n    if (!this.provider) throw new Error('Bundled creation provider not found');\n    return (await this.provider.getCode(walletAddress)) !== '0x';\n  }\n\n  prepareWalletDeploy(config, context) {\n    const factoryInterface = new Interface(walletContracts.factory.abi);\n    return {\n      to: context.factory,\n      data: factoryInterface.encodeFunctionData(factoryInterface.getFunction('deploy'), [context.mainModule, imageHash(config)])\n    };\n  }\n\n  async prependWalletDeploy(signedTransactions) {\n    const {\n      config,\n      context,\n      transactions,\n      nonce,\n      signature\n    } = signedTransactions;\n    const walletAddress = addressOf(config, context);\n    const walletInterface = new Interface(walletContracts.mainModule.abi);\n\n    const encodedSignature = async function () {\n      const sig = await signature;\n      if (typeof sig === 'string') return sig;\n      return encodeSignature(sig);\n    }();\n\n    if (this.bundleCreation && !(await this.isWalletDeployed(walletAddress))) {\n      return {\n        to: context.guestModule,\n        execute: {\n          transactions: [_extends({}, this.prepareWalletDeploy(config, context), {\n            delegateCall: false,\n            revertOnError: false,\n            gasLimit: this.creationGasLimit,\n            value: ethers.constants.Zero\n          }), {\n            delegateCall: false,\n            revertOnError: true,\n            gasLimit: ethers.constants.Zero,\n            to: walletAddress,\n            value: ethers.constants.Zero,\n            data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(transactions), nonce, await encodedSignature])\n          }],\n          nonce: ethers.constants.Zero,\n          signature: '0x'\n        }\n      };\n    } else {\n      return {\n        to: walletAddress,\n        execute: {\n          transactions,\n          nonce: ethers.BigNumber.from(nonce),\n          signature: await encodedSignature\n        }\n      };\n    }\n  }\n\n  async prepareTransactions(config, context, signature, ...transactions) {\n    //, gasLimit?: ethers.BigNumberish }> {\n    const nonce = readSequenceNonce(...transactions);\n\n    if (!nonce) {\n      throw new Error('Unable to prepare transactions without a defined nonce');\n    }\n\n    const {\n      to,\n      execute\n    } = await this.prependWalletDeploy({\n      config,\n      context,\n      transactions,\n      nonce,\n      signature\n    });\n    const walletInterface = new Interface(walletContracts.mainModule.abi);\n    return {\n      to,\n      data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature])\n    };\n  }\n\n}\n\nconst DEFAULT_GAS_LIMIT = ethers.BigNumber.from(800000);\nconst ProviderRelayerDefaults = {\n  waitPollRate: 1000,\n  deltaBlocksLog: 12,\n  fromBlockLog: -1024\n};\nfunction isProviderRelayerOptions(obj) {\n  return obj.provider !== undefined && Provider.isProvider(obj.provider);\n}\nclass ProviderRelayer extends BaseRelayer {\n  constructor(options) {\n    super(options);\n    this.provider = void 0;\n    this.waitPollRate = void 0;\n    this.deltaBlocksLog = void 0;\n    this.fromBlockLog = void 0;\n\n    const opts = _extends({}, ProviderRelayerDefaults, options);\n\n    this.provider = opts.provider;\n    this.waitPollRate = opts.waitPollRate;\n    this.deltaBlocksLog = opts.deltaBlocksLog;\n    this.fromBlockLog = opts.fromBlockLog;\n  }\n\n  async simulate(wallet, ...transactions) {\n    var _this = this;\n\n    return (await Promise.all(transactions.map(async function (tx) {\n      // Respect gasLimit request of the transaction (as long as its not 0)\n      if (tx.gasLimit && !ethers.BigNumber.from(tx.gasLimit || 0).eq(ethers.constants.Zero)) {\n        return tx.gasLimit;\n      } // Fee can't be estimated locally for delegateCalls\n\n\n      if (tx.delegateCall) {\n        return DEFAULT_GAS_LIMIT;\n      } // Fee can't be estimated for self-called if wallet hasn't been deployed\n\n\n      if (tx.to === wallet && !(await _this.isWalletDeployed(wallet))) {\n        return DEFAULT_GAS_LIMIT;\n      }\n\n      if (!_this.provider) {\n        throw new Error('signer.provider is not set, but is required');\n      } // TODO: If the wallet address has been deployed, gas limits can be\n      // estimated with more accurately by using self-calls with the batch transactions one by one\n\n\n      return _this.provider.estimateGas({\n        from: wallet,\n        to: tx.to,\n        data: tx.data,\n        value: tx.value\n      });\n    }))).map(gasLimit => ({\n      executed: true,\n      succeeded: true,\n      gasLimit: ethers.BigNumber.from(gasLimit).toNumber(),\n      gasUsed: ethers.BigNumber.from(gasLimit).toNumber()\n    }));\n  }\n\n  async estimateGasLimits(config, context, ...transactions) {\n    const walletAddr = addressOf(config, context);\n    const results = await this.simulate(walletAddr, ...transactions);\n    return transactions.map((t, i) => _extends({}, t, {\n      gasLimit: results[i].gasLimit\n    }));\n  }\n\n  async getNonce(config, context, space, blockTag) {\n    if (!this.provider) {\n      throw new Error('provider is not set');\n    }\n\n    const addr = addressOf(config, context);\n\n    if ((await this.provider.getCode(addr)) === '0x') {\n      return 0;\n    }\n\n    if (space === undefined) {\n      space = 0;\n    }\n\n    const module = new ethers.Contract(addr, walletContracts.mainModule.abi, this.provider);\n    const nonce = await module.readNonce(space, {\n      blockTag: blockTag\n    });\n    return encodeNonce(space, nonce);\n  }\n\n  async wait(metaTxnId, timeout) {\n    if (typeof metaTxnId !== 'string') {\n      logger.info(\"computing id\", metaTxnId.config, metaTxnId.context, metaTxnId.chainId, ...metaTxnId.transactions);\n      return this.wait(computeMetaTxnHash(addressOf(metaTxnId.config, metaTxnId.context), metaTxnId.chainId, ...metaTxnId.transactions), timeout);\n    } // Transactions can only get executed on nonce change\n    // get all nonce changes and look for metaTxnIds in between logs\n\n\n    const timeoutTime = new Date().getTime() + timeout;\n    let lastBlock = this.fromBlockLog;\n\n    if (lastBlock < 0) {\n      const block = await this.provider.getBlockNumber();\n      lastBlock = block + lastBlock;\n    }\n\n    const normalMetaTxnId = metaTxnId.replace('0x', '');\n\n    while (new Date().getTime() < timeoutTime) {\n      const block = await this.provider.getBlockNumber();\n      const logs = await this.provider.getLogs({\n        fromBlock: Math.max(0, lastBlock - this.deltaBlocksLog),\n        toBlock: block,\n        // Nonce change event topic\n        topics: ['0x1f180c27086c7a39ea2a7b25239d1ab92348f07ca7bb59d1438fcf527568f881']\n      });\n      lastBlock = block; // Get receipts of all transactions\n\n      const txs = await Promise.all(logs.map(l => this.provider.getTransactionReceipt(l.transactionHash))); // Find a transaction with a TxExecuted log\n\n      const found = txs.find(tx => tx.logs.find(l => l.topics.length === 0 && l.data.replace('0x', '') === normalMetaTxnId || l.topics.length === 1 && // TxFailed event topic\n      l.topics[0] === \"0x3dbd1590ea96dd3253a91f24e64e3a502e1225d602a5731357bc12643070ccd7\" && l.data.length >= 64 && l.data.replace('0x', '').startsWith(normalMetaTxnId))); // If found return that\n\n      if (found) {\n        return _extends({\n          receipt: found\n        }, await this.provider.getTransaction(found.transactionHash));\n      } // Otherwise wait and try again\n\n\n      await new Promise(r => setTimeout(r, this.waitPollRate));\n    }\n\n    throw new Error(`Timeout waiting for transaction receipt ${metaTxnId}`);\n  }\n\n}\n\nfunction isLocalRelayerOptions(obj) {\n  return obj.signer !== undefined && Signer.isSigner(obj.signer);\n}\nclass LocalRelayer extends ProviderRelayer {\n  constructor(options) {\n    super(Signer.isSigner(options) ? {\n      provider: options.provider\n    } : _extends({}, options, {\n      provider: options.signer.provider\n    }));\n    this.signer = void 0;\n    this.txnOptions = void 0;\n    this.signer = Signer.isSigner(options) ? options : options.signer;\n    if (!this.signer.provider) throw new Error(\"Signer must have a provider\");\n  }\n\n  async deployWallet(config, context) {\n    // NOTE: on hardhat some tests fail on HookCallerMock when not passing gasLimit directly as below,\n    // and using eth_gasEstimate. Perhaps review HookCallerMock.sol and fix it to avoid what looks\n    // like an infinite loop?\n    const walletDeployTxn = this.prepareWalletDeploy(config, context); // NOTE: for hardhat to pass, we have to set the gasLimit directly, as its unable to estimate\n\n    return this.signer.sendTransaction(_extends({}, walletDeployTxn, {\n      gasLimit: ethers.constants.Two.pow(17)\n    }));\n  }\n\n  async getFeeOptions(_config, _context, ..._transactions) {\n    return {\n      options: []\n    };\n  }\n\n  async gasRefundOptions(config, context, ...transactions) {\n    const {\n      options\n    } = await this.getFeeOptions(config, context, ...transactions);\n    return options;\n  }\n\n  setTransactionOptions(transactionRequest) {\n    this.txnOptions = transactionRequest;\n  }\n\n  async relay(signedTxs, quote) {\n    if (quote !== undefined) {\n      logger.warn(`LocalRelayer doesn't accept fee quotes`);\n    }\n\n    if (!signedTxs.context.guestModule || signedTxs.context.guestModule.length !== 42) {\n      throw new Error('LocalRelayer requires the context.guestModule address');\n    }\n\n    const {\n      to,\n      execute\n    } = await this.prependWalletDeploy(signedTxs);\n    const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);\n    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]); // TODO: think about computing gas limit individually, summing together and passing across\n    // NOTE: we expect that all txns have set their gasLimit ahead of time through proper estimation\n    // const gasLimit = signedTxs.transactions.reduce((sum, tx) => sum.add(tx.gasLimit), ethers.BigNumber.from(0))\n    // txRequest.gasLimit = gasLimit\n\n    return this.signer.sendTransaction(_extends({\n      to,\n      data\n    }, this.txnOptions));\n  }\n\n}\n\n/* eslint-disable */\n// sequence-relayer v0.4.0 4dca0b91c1531d1166ae2f7ebd8af571b0c0e43b\n// --\n// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript\n// Do not edit by hand. Update your webrpc schema and re-generate.\n// WebRPC description and code-gen version\nconst WebRPCVersion = 'v1'; // Schema version of your RIDL schema\n\nconst WebRPCSchemaVersion = 'v0.4.0'; // Schema hash generated from your RIDL schema\n\nconst WebRPCSchemaHash = '4dca0b91c1531d1166ae2f7ebd8af571b0c0e43b'; //\n// Types\n//\n\nlet ETHTxnStatus;\n\n(function (ETHTxnStatus) {\n  ETHTxnStatus[\"UNKNOWN\"] = \"UNKNOWN\";\n  ETHTxnStatus[\"DROPPED\"] = \"DROPPED\";\n  ETHTxnStatus[\"QUEUED\"] = \"QUEUED\";\n  ETHTxnStatus[\"SENT\"] = \"SENT\";\n  ETHTxnStatus[\"SUCCEEDED\"] = \"SUCCEEDED\";\n  ETHTxnStatus[\"PARTIALLY_FAILED\"] = \"PARTIALLY_FAILED\";\n  ETHTxnStatus[\"FAILED\"] = \"FAILED\";\n})(ETHTxnStatus || (ETHTxnStatus = {}));\n\nlet TransferType;\n\n(function (TransferType) {\n  TransferType[\"SEND\"] = \"SEND\";\n  TransferType[\"RECEIVE\"] = \"RECEIVE\";\n  TransferType[\"BRIDGE_DEPOSIT\"] = \"BRIDGE_DEPOSIT\";\n  TransferType[\"BRIDGE_WITHDRAW\"] = \"BRIDGE_WITHDRAW\";\n  TransferType[\"BURN\"] = \"BURN\";\n  TransferType[\"UNKNOWN\"] = \"UNKNOWN\";\n})(TransferType || (TransferType = {}));\n\nlet FeeTokenType;\n\n(function (FeeTokenType) {\n  FeeTokenType[\"UNKNOWN\"] = \"UNKNOWN\";\n  FeeTokenType[\"ERC20_TOKEN\"] = \"ERC20_TOKEN\";\n  FeeTokenType[\"ERC1155_TOKEN\"] = \"ERC1155_TOKEN\";\n})(FeeTokenType || (FeeTokenType = {}));\n\nlet SortOrder;\n\n(function (SortOrder) {\n  SortOrder[\"DESC\"] = \"DESC\";\n  SortOrder[\"ASC\"] = \"ASC\";\n})(SortOrder || (SortOrder = {}));\n\n//\n// Client\n//\nclass Relayer {\n  constructor(hostname, fetch) {\n    this.hostname = void 0;\n    this.fetch = void 0;\n    this.path = '/rpc/Relayer/';\n\n    this.ping = headers => {\n      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.version = headers => {\n      return this.fetch(this.url('Version'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            version: _data.version\n          };\n        });\n      });\n    };\n\n    this.runtimeStatus = headers => {\n      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.getSequenceContext = headers => {\n      return this.fetch(this.url('GetSequenceContext'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            data: _data.data\n          };\n        });\n      });\n    };\n\n    this.getChainID = headers => {\n      return this.fetch(this.url('GetChainID'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            chainID: _data.chainID\n          };\n        });\n      });\n    };\n\n    this.sendMetaTxn = (args, headers) => {\n      return this.fetch(this.url('SendMetaTxn'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status,\n            txnHash: _data.txnHash\n          };\n        });\n      });\n    };\n\n    this.getMetaTxnNonce = (args, headers) => {\n      return this.fetch(this.url('GetMetaTxnNonce'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            nonce: _data.nonce\n          };\n        });\n      });\n    };\n\n    this.getMetaTxnReceipt = (args, headers) => {\n      return this.fetch(this.url('GetMetaTxnReceipt'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            receipt: _data.receipt\n          };\n        });\n      });\n    };\n\n    this.simulate = (args, headers) => {\n      return this.fetch(this.url('Simulate'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            results: _data.results\n          };\n        });\n      });\n    };\n\n    this.updateMetaTxnGasLimits = (args, headers) => {\n      return this.fetch(this.url('UpdateMetaTxnGasLimits'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            payload: _data.payload\n          };\n        });\n      });\n    };\n\n    this.feeTokens = headers => {\n      return this.fetch(this.url('FeeTokens'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            isFeeRequired: _data.isFeeRequired,\n            tokens: _data.tokens\n          };\n        });\n      });\n    };\n\n    this.feeOptions = (args, headers) => {\n      return this.fetch(this.url('FeeOptions'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            options: _data.options,\n            quote: _data.quote\n          };\n        });\n      });\n    };\n\n    this.getMetaTxnNetworkFeeOptions = (args, headers) => {\n      return this.fetch(this.url('GetMetaTxnNetworkFeeOptions'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            options: _data.options\n          };\n        });\n      });\n    };\n\n    this.sentTransactions = (args, headers) => {\n      return this.fetch(this.url('SentTransactions'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: _data.page,\n            transactions: _data.transactions\n          };\n        });\n      });\n    };\n\n    this.pendingTransactions = (args, headers) => {\n      return this.fetch(this.url('PendingTransactions'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: _data.page,\n            transactions: _data.transactions\n          };\n        });\n      });\n    };\n\n    this.hostname = hostname;\n    this.fetch = fetch;\n  }\n\n  url(name) {\n    return this.hostname + this.path + name;\n  }\n\n}\n\nconst createHTTPRequest = (body = {}, headers = {}) => {\n  return {\n    method: 'POST',\n    headers: _extends({}, headers, {\n      'Content-Type': 'application/json'\n    }),\n    body: JSON.stringify(body || {})\n  };\n};\n\nconst buildResponse = res => {\n  return res.text().then(text => {\n    let data;\n\n    try {\n      data = JSON.parse(text);\n    } catch (err) {\n      throw {\n        code: 'unknown',\n        msg: `expecting JSON, got: ${text}`,\n        status: res.status\n      };\n    }\n\n    if (!res.ok) {\n      throw data; // webrpc error response\n    }\n\n    return data;\n  });\n};\n\nvar relayer_gen = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  WebRPCVersion: WebRPCVersion,\n  WebRPCSchemaVersion: WebRPCSchemaVersion,\n  WebRPCSchemaHash: WebRPCSchemaHash,\n  get ETHTxnStatus () { return ETHTxnStatus; },\n  get TransferType () { return TransferType; },\n  get FeeTokenType () { return FeeTokenType; },\n  get SortOrder () { return SortOrder; },\n  Relayer: Relayer\n});\n\nconst FAILED_STATUSES = [ETHTxnStatus.FAILED, ETHTxnStatus.PARTIALLY_FAILED, ETHTxnStatus.DROPPED];\nfunction isRpcRelayerOptions(obj) {\n  return obj.url !== undefined && typeof obj.url === 'string';\n}\nclass RpcRelayer extends BaseRelayer {\n  constructor(options) {\n    super(options);\n    this.service = void 0;\n    this.service = new Relayer(options.url, fetchPonyfill().fetch);\n  }\n\n  async waitReceipt(metaTxnHash, wait = 1000) {\n    if (typeof metaTxnHash !== 'string') {\n      logger.info('computing id', metaTxnHash.config, metaTxnHash.context, metaTxnHash.chainId, ...metaTxnHash.transactions);\n      return this.waitReceipt(computeMetaTxnHash(addressOf(metaTxnHash.config, metaTxnHash.context), metaTxnHash.chainId, ...metaTxnHash.transactions));\n    }\n\n    logger.info(`[rpc-relayer/waitReceipt] waiting for ${metaTxnHash}`);\n    let result = await this.service.getMetaTxnReceipt({\n      metaTxID: metaTxnHash\n    }); // TODO: remove check for 'UNKNOWN' status when 'QUEUED' status is supported\n    // TODO: fix backend to not return literal 'null' txnReceipt\n\n    while (!result.receipt || !result.receipt.txnReceipt || result.receipt.txnReceipt === 'null' || result.receipt.status === 'UNKNOWN' || result.receipt.status === 'QUEUED' || result.receipt.status === 'SENT') {\n      await new Promise(r => setTimeout(r, wait));\n      result = await this.service.getMetaTxnReceipt({\n        metaTxID: metaTxnHash\n      });\n    }\n\n    return result;\n  }\n\n  async simulate(wallet, ...transactions) {\n    const coder = ethers.utils.defaultAbiCoder;\n    const encoded = coder.encode([MetaTransactionsType], [sequenceTxAbiEncode(transactions)]);\n    return (await this.service.simulate({\n      wallet,\n      transactions: encoded\n    })).results;\n  }\n\n  async estimateGasLimits(config, context, ...transactions) {\n    logger.info(`[rpc-relayer/estimateGasLimits] estimate gas limits request ${JSON.stringify(transactions)}`);\n\n    if (transactions.length == 0) {\n      return [];\n    }\n\n    const addr = addressOf(config, context);\n    const prevNonce = readSequenceNonce(...transactions); // Set temporal nonce to simulate meta-txn\n\n    if (prevNonce === undefined) {\n      transactions = appendNonce(transactions, await this.getNonce(config, context));\n    }\n\n    const coder = ethers.utils.defaultAbiCoder;\n    const encoded = coder.encode([MetaTransactionsType], [sequenceTxAbiEncode(transactions)]);\n    const res = await this.service.updateMetaTxnGasLimits({\n      walletAddress: addr,\n      walletConfig: {\n        address: addr,\n        signers: config.signers,\n        threshold: config.threshold,\n        chainId: config.chainId\n      },\n      payload: encoded\n    });\n    const decoded = coder.decode([MetaTransactionsType], res.payload)[0];\n    const modTxns = transactions.map((t, i) => _extends({}, t, {\n      gasLimit: decoded[i].gasLimit\n    }));\n    logger.info(`[rpc-relayer/estimateGasLimits] got transactions with gas limits ${JSON.stringify(modTxns)}`); // Remove placeholder nonce if previously defined\n\n    return prevNonce === undefined ? modTxns : appendNonce(modTxns, prevNonce);\n  }\n\n  async getFeeOptions(config, context, ...transactions) {\n    // NOTE/TODO: for a given `service` the feeTokens will not change between execution, so we should memoize this value\n    // for a short-period of time, perhaps for 1 day or in memory. Perhaps one day we can make this happen automatically\n    // with http cache response for this endpoint and service-worker.. lots of approaches\n    const feeTokens = await this.service.feeTokens();\n\n    if (feeTokens.isFeeRequired) {\n      const symbols = feeTokens.tokens.map(token => token.symbol).join(', ');\n      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are required, accepted tokens are ${symbols}`);\n      const wallet = addressOf(config, context);\n      let nonce = readSequenceNonce(...transactions);\n\n      if (nonce === undefined) {\n        nonce = await this.getNonce(config, context);\n      }\n\n      if (!this.provider) {\n        logger.warn(`[rpc-relayer/getFeeOptions] provider not set, needed for stub signature`);\n        throw new Error('provider is not set');\n      }\n\n      const {\n        to,\n        execute\n      } = await this.prependWalletDeploy({\n        config,\n        context,\n        transactions,\n        nonce,\n        signature: buildStubSignature(this.provider, config)\n      });\n      const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);\n      const data = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]);\n      const {\n        options,\n        quote\n      } = await this.service.feeOptions({\n        wallet,\n        to,\n        data\n      });\n      logger.info(`[rpc-relayer/getFeeOptions] got refund options ${JSON.stringify(options)}`);\n      return {\n        options,\n        quote: {\n          _tag: 'FeeQuote',\n          _quote: quote\n        }\n      };\n    } else {\n      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are not required`);\n      return {\n        options: []\n      };\n    }\n  }\n\n  async gasRefundOptions(config, context, ...transactions) {\n    const {\n      options\n    } = await this.getFeeOptions(config, context, ...transactions);\n    return options;\n  }\n\n  async getNonce(config, context, space) {\n    const addr = addressOf(config, context);\n    logger.info(`[rpc-relayer/getNonce] get nonce for wallet ${addr} space: ${space}`);\n    const encodedNonce = space !== undefined ? ethers.BigNumber.from(space).toHexString() : undefined;\n    const resp = await this.service.getMetaTxnNonce({\n      walletContractAddress: addr,\n      space: encodedNonce\n    });\n    const nonce = ethers.BigNumber.from(resp.nonce);\n    const [decodedSpace, decodedNonce] = decodeNonce(nonce);\n    logger.info(`[rpc-relayer/getNonce] got next nonce for wallet ${addr} ${decodedNonce} space: ${decodedSpace}`);\n    return nonce;\n  }\n\n  async relay(signedTxs, quote) {\n    logger.info(`[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(signedTxs)} with quote ${JSON.stringify(quote)}`);\n    let typecheckedQuote;\n\n    if (quote !== undefined) {\n      if (typeof quote._quote === 'string') {\n        typecheckedQuote = quote._quote;\n      } else {\n        logger.warn('[rpc-relayer/relay] ignoring invalid fee quote');\n      }\n    }\n\n    if (!this.provider) {\n      logger.warn(`[rpc-relayer/relay] provider not set, failed relay`);\n      throw new Error('provider is not set');\n    }\n\n    const {\n      to: contract,\n      execute\n    } = await this.prependWalletDeploy(signedTxs);\n    const walletAddress = addressOf(signedTxs.config, signedTxs.context);\n    const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);\n    const input = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]);\n    const metaTxn = await this.service.sendMetaTxn({\n      call: {\n        walletAddress,\n        contract,\n        input\n      },\n      quote: typecheckedQuote\n    });\n    logger.info(`[rpc-relayer/relay] got relay result ${JSON.stringify(metaTxn)}`);\n    return this.wait(metaTxn.txnHash);\n  }\n\n  async wait(metaTxnHash, wait = 1000) {\n    var _this = this;\n\n    const {\n      receipt\n    } = await this.waitReceipt(metaTxnHash, wait);\n\n    if (!receipt.txnReceipt || FAILED_STATUSES.includes(receipt.status)) {\n      throw new MetaTransactionResponseException(receipt);\n    }\n\n    const txReceipt = JSON.parse(receipt.txnReceipt);\n    return {\n      blockHash: txReceipt.blockHash,\n      blockNumber: ethers.BigNumber.from(txReceipt.blockNumber).toNumber(),\n      confirmations: 1,\n      from: typeof metaTxnHash === 'string' ? undefined : addressOf(metaTxnHash.config, metaTxnHash.context),\n      hash: txReceipt.transactionHash,\n      raw: receipt.txnReceipt,\n      receipt: txReceipt,\n      // extended type which is Sequence-specific. Contains the decoded metaTxReceipt\n      wait: async function (confirmations) {\n        return _this.provider.waitForTransaction(txReceipt.transactionHash, confirmations);\n      }\n    };\n  }\n\n}\n\nclass MetaTransactionResponseException {\n  constructor(receipt) {\n    this.receipt = receipt;\n  }\n\n}\n\nfunction isRelayer(cand) {\n  return typeof cand === 'object' && typeof cand.simulate === 'function' && typeof cand.estimateGasLimits === 'function' && typeof cand.getFeeOptions === 'function' && typeof cand.gasRefundOptions === 'function' && typeof cand.getNonce === 'function' && typeof cand.relay === 'function' && typeof cand.wait === 'function';\n}\n\nexport { BaseRelayer, BaseRelayerDefaults, LocalRelayer, ProviderRelayer, ProviderRelayerDefaults, RpcRelayer, relayer_gen as RpcRelayerProto, isBaseRelayerOptions, isLocalRelayerOptions, isProviderRelayerOptions, isRelayer, isRpcRelayerOptions, relayer_gen as proto };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}