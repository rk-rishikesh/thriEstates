{"ast":null,"code":"import { EventEmitter2 } from 'eventemitter2';\nimport { logger, shallowCopy, resolveProperties, encodeMessageDigest, encodeTypedDataDigest, packMessageData, sanitizeNumberString, sanitizeHost, sanitizeAlphanumeric, base64EncodeObject, base64DecodeObject } from '@0xsequence/utils';\nimport { ethers, BigNumber } from 'ethers';\nimport { addressOf, isConfigEqual } from '@0xsequence/config';\nimport { Web3Provider as Web3Provider$1, JsonRpcProvider } from '@ethersproject/providers';\nimport { JsonRpcSender, maybeChainId, allowProviderMiddleware, networkProviderMiddleware, CachedProvider, JsonRpcRouter, loggingProviderMiddleware, exceptionProviderMiddleware, findNetworkConfig, EagerProvider, SigningProvider, updateNetworkConfig, ensureValidNetworks } from '@0xsequence/network';\nimport { Signer, resolveArrayProperties, isValidSignature as isValidSignature$1, recoverConfig } from '@0xsequence/wallet';\nimport { isSignedTransactions } from '@0xsequence/transactions';\nimport { signAuthorization } from '@0xsequence/auth';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n} // ProviderMessageCallback is used to respond to ProviderMessage requests. The error\n// argument is for exceptions during the execution, and response is the response payload\n// which may contain the result or an error payload from the wallet.\n\n\nclass WindowSessionParams extends URLSearchParams {\n  static new(init) {\n    return new URLSearchParams(init);\n  }\n\n}\n\nlet EventType;\n\n(function (EventType) {\n  EventType[\"OPEN\"] = \"open\";\n  EventType[\"CLOSE\"] = \"close\";\n  EventType[\"MESSAGE\"] = \"message\";\n  EventType[\"CONNECT\"] = \"connect\";\n  EventType[\"DISCONNECT\"] = \"disconnect\";\n  EventType[\"ACCOUNTS_CHANGED\"] = \"accountsChanged\";\n  EventType[\"CHAIN_CHANGED\"] = \"chainChanged\";\n  EventType[\"NETWORKS\"] = \"networks\";\n  EventType[\"WALLET_CONTEXT\"] = \"walletContext\";\n  EventType[\"INIT\"] = \"init\";\n  EventType[\"DEBUG\"] = \"_debug\";\n})(EventType || (EventType = {}));\n\nlet OpenState;\n\n(function (OpenState) {\n  OpenState[OpenState[\"CLOSED\"] = 0] = \"CLOSED\";\n  OpenState[OpenState[\"OPENING\"] = 1] = \"OPENING\";\n  OpenState[OpenState[\"OPENED\"] = 2] = \"OPENED\";\n})(OpenState || (OpenState = {}));\n\nlet InitState;\n\n(function (InitState) {\n  InitState[InitState[\"NIL\"] = 0] = \"NIL\";\n  InitState[InitState[\"SENT_NONCE\"] = 1] = \"SENT_NONCE\";\n  InitState[InitState[\"OK\"] = 2] = \"OK\";\n})(InitState || (InitState = {}));\n\nclass ProviderError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ProviderError';\n  }\n\n}\n\nconst ErrSignedInRequired = new ProviderError('Wallet is not signed in. Connect a wallet and try again.'); // TODO: lets build some nice error handling tools, prob in /utils ...\n\nconst PROVIDER_OPEN_TIMEOUT = 30000; // in ms\n\nlet _messageIdx = 0;\n\nconst nextMessageIdx = () => ++_messageIdx;\n\nclass BaseProviderTransport {\n  constructor() {\n    var _this = this;\n\n    this.pendingMessageRequests = [];\n    this.responseCallbacks = new Map();\n    this.state = void 0;\n    this.confirmationOnly = false;\n    this.events = new EventEmitter2();\n    this.openPayload = void 0;\n    this.connectPayload = void 0;\n    this.accountsChangedPayload = void 0;\n    this.networksPayload = void 0;\n    this.walletContextPayload = void 0;\n    this._sessionId = void 0;\n    this._init = void 0;\n    this._registered = void 0;\n\n    this.sendAsync = async function (request, callback, chainId) {\n      // here, we receive the message from the dapp provider call\n      if (_this.state === OpenState.CLOSED) {\n        // flag the wallet to auto-close once user submits input. ie.\n        // prompting to sign a message or transaction\n        _this.confirmationOnly = true;\n      } // open/focus the wallet.\n      // automatically open the wallet when a provider request makes it here.\n      //\n      // NOTE: if we're not signed in, then the provider will fail, users must first connect+sign in.\n      //\n      // TODO: how does this behave with a session has expired?\n\n\n      _this.openWallet(undefined, {\n        type: 'jsonRpcRequest',\n        method: request.method\n      }, chainId); // send message request, await, and then execute callback after receiving the response\n\n\n      try {\n        if (!_this.isOpened()) {\n          await _this.waitUntilOpened(); // will throw on timeout\n        }\n\n        const response = await _this.sendMessageRequest({\n          idx: nextMessageIdx(),\n          type: EventType.MESSAGE,\n          data: request,\n          chainId: chainId\n        });\n        callback(undefined, response.data);\n      } catch (err) {\n        callback(err);\n      }\n    };\n\n    this.sendMessageRequest = async function (message) {\n      return new Promise((resolve, reject) => {\n        if ((!message.idx || message.idx <= 0) && message.type !== 'init') {\n          reject(new Error('message idx not set'));\n        }\n\n        const responseCallback = (error, response) => {\n          if (error) {\n            reject(error);\n          } else if (response) {\n            resolve(response);\n          } else {\n            throw new Error('no valid response to return');\n          }\n        };\n\n        const idx = message.idx;\n\n        if (!_this.responseCallbacks.get(idx)) {\n          _this.responseCallbacks.set(idx, responseCallback);\n        } else {\n          reject(new Error('duplicate message idx, should never happen'));\n        }\n\n        if (!_this.isOpened()) {\n          logger.debug('pushing to pending requests', message);\n\n          _this.pendingMessageRequests.push(message);\n        } else {\n          _this.sendMessage(message);\n        }\n      });\n    };\n\n    this.waitUntilOpened = async function () {\n      let openTimeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PROVIDER_OPEN_TIMEOUT;\n      let opened = false;\n      return Promise.race([new Promise((_, reject) => {\n        const timeout = setTimeout(() => {\n          clearTimeout(timeout); // only emit close if the timeout wins the race\n\n          if (!opened) {\n            _this.state = OpenState.CLOSED;\n\n            _this.events.emit('close', {\n              code: 1005,\n              message: 'opening wallet timed out'\n            });\n          }\n\n          reject(new Error('opening wallet timed out'));\n        }, openTimeout);\n      }), new Promise(resolve => {\n        if (_this.isOpened()) {\n          var _this$openPayload;\n\n          opened = true;\n          resolve((_this$openPayload = _this.openPayload) == null ? void 0 : _this$openPayload.session);\n          return;\n        }\n\n        _this.events.once('open', openInfo => {\n          _this.openPayload = openInfo;\n          opened = true;\n          resolve(openInfo.session);\n        });\n      })]);\n    };\n\n    this.waitUntilConnected = async function () {\n      await _this.waitUntilOpened();\n      const connect = new Promise(resolve => {\n        if (_this.connectPayload) {\n          resolve(_this.connectPayload);\n          return;\n        }\n\n        _this.events.once('connect', connectDetails => {\n          _this.connectPayload = connectDetails;\n          resolve(connectDetails);\n        });\n      });\n      const closeWallet = new Promise((_, reject) => {\n        _this.events.once('close', error => {\n          if (error) {\n            reject(new Error(`wallet closed due to ${JSON.stringify(error)}`));\n          } else {\n            reject(new Error(`user closed the wallet`));\n          }\n        });\n      });\n      return Promise.race([connect, closeWallet]);\n    };\n\n    this.state = OpenState.CLOSED;\n    this._registered = false;\n    this._init = InitState.NIL;\n  }\n\n  get registered() {\n    return this._registered;\n  }\n\n  register() {\n    throw new Error('abstract method');\n  }\n\n  unregister() {\n    throw new Error('abstract method');\n  }\n\n  openWallet(path, intent, networkId) {\n    throw new Error('abstract method');\n  }\n\n  closeWallet() {\n    throw new Error('abstract method');\n  }\n\n  isOpened() {\n    return this.registered && this.state === OpenState.OPENED;\n  }\n\n  isConnected() {\n    var _this$openPayload2; // if we're registered, and we have the account details, then we are connected\n\n\n    const session = (_this$openPayload2 = this.openPayload) == null ? void 0 : _this$openPayload2.session;\n    return this.registered && session !== undefined && !!session.accountAddress && session.accountAddress.length === 42 && !!session.networks && session.networks.length > 0;\n  } // handleMessage will handle message received from the remote wallet\n\n\n  handleMessage(message) {\n    var _this2 = this; // init incoming for initial handshake with transport.\n    // always respond to INIT messages, e.g. on popup window reload\n\n\n    if (message.type === EventType.INIT) {\n      logger.debug('MessageProvider, received INIT message', message);\n      const {\n        nonce\n      } = message.data;\n\n      if (!nonce || nonce.length == 0) {\n        logger.error('invalid init nonce');\n        return;\n      }\n\n      this._init = InitState.OK;\n      this.sendMessage({\n        idx: -1,\n        type: EventType.INIT,\n        data: {\n          sessionId: this._sessionId,\n          nonce: nonce\n        }\n      });\n    }\n\n    if (this._init !== InitState.OK) {\n      // if provider is not init'd, then we drop any received messages. the only\n      // message we will process is of event type 'init', as our acknowledgement\n      return;\n    } // message is either a notification, or its a ProviderMessageResponse\n\n\n    logger.debug('RECEIVED MESSAGE FROM WALLET', message.idx, message);\n    const requestIdx = message.idx;\n    const responseCallback = this.responseCallbacks.get(requestIdx);\n\n    if (requestIdx) {\n      this.responseCallbacks.delete(requestIdx);\n    } // OPEN response\n    //\n    // Flip opened flag, and flush the pending queue\n\n\n    if (message.type === EventType.OPEN && !this.isOpened()) {\n      var _message$data, _message$data2;\n\n      if (this._sessionId && this._sessionId !== ((_message$data = message.data) == null ? void 0 : _message$data.sessionId)) {\n        logger.debug('open event received from wallet, but does not match sessionId', this._sessionId);\n        return;\n      } // check if open error occured due to invalid defaultNetworkId\n\n\n      if ((_message$data2 = message.data) != null && _message$data2.error) {\n        var _message$data3;\n\n        const err = new Error(`opening wallet failed: received ${(_message$data3 = message.data) == null ? void 0 : _message$data3.error}`);\n        logger.error(err);\n        this.close();\n        throw err;\n      } // success!\n\n\n      this.state = OpenState.OPENED;\n      this.openPayload = message.data;\n      this.events.emit('open', this.openPayload); // flush pending requests when connected\n\n      if (this.pendingMessageRequests.length !== 0) {\n        const pendingMessageRequests = this.pendingMessageRequests.splice(0, this.pendingMessageRequests.length);\n        pendingMessageRequests.forEach(async function (pendingMessageRequest) {\n          _this2.sendMessage(pendingMessageRequest);\n        });\n      }\n\n      return;\n    } // MESSAGE resposne\n\n\n    if (message.type === EventType.MESSAGE) {\n      // Require user confirmation, bring up wallet to prompt for input then close\n      // TODO: perhaps apply technique like in multicall to queue messages within\n      // a period of time, then close the window if responseCallbacks is empty, this is better.\n      if (this.confirmationOnly) {\n        setTimeout(() => {\n          if (this.responseCallbacks.size === 0) {\n            this.closeWallet();\n          }\n        }, 500); // TODO: be smarter about timer as we're processing the response callbacks..\n      }\n\n      if (!responseCallback) {\n        // NOTE: this would occur if 'idx' isn't set, which should never happen\n        // or when we register two handler, or duplicate messages with the same idx are sent,\n        // all of which should be prevented prior to getting to this point\n        throw new Error('impossible state');\n      } // Callback to original caller\n\n\n      if (responseCallback) {\n        this.events.emit('message', message);\n        responseCallback(message.data.error, message);\n        return;\n      }\n    } // ACCOUNTS_CHANGED -- when a user logs in or out\n\n\n    if (message.type === EventType.ACCOUNTS_CHANGED) {\n      this.accountsChangedPayload = {\n        accounts: []\n      };\n\n      if (message.data && message.data.length > 0) {\n        this.accountsChangedPayload = {\n          accounts: [ethers.utils.getAddress(message.data[0])],\n          origin: message.origin\n        };\n        this.events.emit('accountsChanged', this.accountsChangedPayload.accounts, this.accountsChangedPayload.origin);\n      } else {\n        this.events.emit('accountsChanged', [], message.origin);\n      }\n\n      return;\n    } // CHAIN_CHANGED -- when a user changes their default chain\n\n\n    if (message.type === EventType.CHAIN_CHANGED) {\n      this.events.emit('chainChanged', message.data);\n      return;\n    } // NOTIFY NETWORKS -- when a user connects or logs in\n\n\n    if (message.type === EventType.NETWORKS) {\n      this.networksPayload = message.data;\n      this.events.emit('networks', this.networksPayload);\n      return;\n    } // NOTIFY WALLET_CONTEXT -- when a user connects or logs in\n\n\n    if (message.type === EventType.WALLET_CONTEXT) {\n      this.walletContextPayload = message.data;\n      this.events.emit('walletContext', this.walletContextPayload);\n      return;\n    } // NOTIFY CLOSE -- when wallet instructs to close\n\n\n    if (message.type === EventType.CLOSE) {\n      if (this.state !== OpenState.CLOSED) {\n        this.close(message.data);\n      }\n    } // NOTIFY CONNECT -- when wallet instructs we've connected\n\n\n    if (message.type === EventType.CONNECT) {\n      this.connectPayload = message.data;\n      this.events.emit('connect', this.connectPayload);\n    } // NOTIFY DISCONNECT -- when wallet instructs to disconnect\n\n\n    if (message.type === EventType.DISCONNECT) {\n      if (this.isConnected()) {\n        this.events.emit('disconnect', message.data);\n        this.close();\n      }\n    }\n  } // sendMessageRequest sends a ProviderMessageRequest over the wire to the wallet\n\n\n  sendMessage(message) {\n    throw new Error('abstract method');\n  }\n\n  on(event, fn) {\n    this.events.on(event, fn);\n  }\n\n  once(event, fn) {\n    this.events.once(event, fn);\n  }\n\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return this.events.emit(event, ...args);\n  }\n\n  close(error) {\n    if (this.state === OpenState.CLOSED) return;\n    this.state = OpenState.CLOSED;\n    this.confirmationOnly = false;\n    this._sessionId = undefined;\n    logger.info('closing wallet and flushing!'); // flush pending requests and return error to all callbacks\n\n    this.pendingMessageRequests.length = 0;\n    this.responseCallbacks.forEach(responseCallback => {\n      responseCallback(_extends({}, new Error('wallet closed'), {\n        code: 4001\n      }));\n    });\n    this.responseCallbacks.clear();\n    this.connectPayload = undefined;\n    this.openPayload = undefined;\n    this.accountsChangedPayload = undefined;\n    this.networksPayload = undefined;\n    this.walletContextPayload = undefined;\n    this.events.emit('close', error);\n  }\n\n}\n\nconst SIGNER_READY_TIMEOUT = 10000;\n\nclass WalletRequestHandler {\n  // signer interface of the wallet. A null value means there is no signer (ie. user not signed in). An undefined\n  // value means the signer state is unknown, usually meaning the wallet app is booting up and initializing. Of course\n  // a Signer value is the actually interface to a signed-in account\n  constructor(_signer, prompter, mainnetNetworks) {\n    let testnetNetworks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    var _this = this;\n\n    this.signer = void 0;\n    this.signerReadyCallbacks = [];\n    this.prompter = void 0;\n    this.mainnetNetworks = void 0;\n    this.testnetNetworks = void 0;\n    this._openIntent = void 0;\n    this._connectOptions = void 0;\n    this._defaultNetworkId = void 0;\n    this._chainId = void 0;\n    this.events = new EventEmitter2();\n\n    this.promptConnect = async function (options) {\n      if (!options && !_this._connectOptions) {\n        // this is an unexpected state and should not happen\n        throw new Error('prompter connect options are empty');\n      }\n\n      if (!_this.prompter) {\n        // if prompter is null, we'll auto connect\n        return _this.connect(options);\n      }\n\n      const promptConnectDetails = await _this.prompter.promptConnect(options || _this._connectOptions).catch(_ => {\n        return {\n          connected: false\n        };\n      });\n      const connectDetails = promptConnectDetails;\n\n      if (connectDetails.connected && !connectDetails.session) {\n        connectDetails.session = await _this.walletSession();\n      }\n\n      return promptConnectDetails;\n    };\n\n    this.sendAsync = async function (request, callback, chainId) {\n      const response = {\n        jsonrpc: '2.0',\n        id: request.id,\n        result: null\n      };\n      await _this.getSigner();\n\n      try {\n        // only allow public json rpc method to the provider when user is not logged in, aka signer is not set\n        if ((!_this.signer || _this.signer === null) && !permittedJsonRpcMethods.includes(request.method)) {\n          // throw new Error(`not logged in. ${request.method} is unavailable`)\n          throw ErrSignedInRequired;\n        } // wallet signer\n\n\n        const signer = _this.signer;\n        if (!signer) throw new Error('WalletRequestHandler: wallet signer is not configured'); // fetch the provider for the specific chain, or undefined will select defaultChain\n\n        const provider = await signer.getProvider(chainId);\n        if (!provider) throw new Error(`WalletRequestHandler: wallet provider is not configured for chainId ${chainId}`);\n\n        switch (request.method) {\n          case 'net_version':\n            {\n              const result = await provider.send('net_version', []);\n              response.result = result;\n              break;\n            }\n\n          case 'eth_chainId':\n            {\n              const result = await provider.send('eth_chainId', []);\n              response.result = result;\n              break;\n            }\n\n          case 'eth_accounts':\n            {\n              const walletAddress = await signer.getAddress();\n              response.result = [walletAddress];\n              break;\n            }\n\n          case 'eth_getBalance':\n            {\n              const [accountAddress, blockTag] = request.params;\n              const walletBalance = await provider.getBalance(accountAddress, blockTag);\n              response.result = walletBalance.toHexString();\n              break;\n            }\n\n          case 'personal_sign':\n          case 'eth_sign':\n            {\n              // note: message from json-rpc input is in hex format\n              let message; // there is a difference in the order of the params:\n              // personal_sign: [data, address]\n              // eth_sign: [address, data]\n\n              if (request.method === 'personal_sign') {\n                const [data, address] = request.params;\n                message = data;\n              } else {\n                const [address, data] = request.params;\n                message = data;\n              }\n\n              let sig = ''; // Message must be prefixed with \"\\x19Ethereum Signed Message:\\n\"\n              // as defined by EIP-191\n\n              message = prefixEIP191Message(message); // TODO:\n              // if (process.env.TEST_MODE === 'true' && this.prompter === null) {\n\n              if (_this.prompter === null) {\n                // prompter is null, so we'll sign from here\n                sig = await signer.signMessage(ethers.utils.arrayify(message), chainId);\n              } else {\n                const promptResultForDeployment = await _this.handleConfirmWalletDeployPrompt(_this.prompter, signer, chainId);\n\n                if (promptResultForDeployment) {\n                  sig = await _this.prompter.promptSignMessage({\n                    chainId: chainId,\n                    message\n                  }, _this.connectOptions);\n                }\n              }\n\n              if (sig && sig.length > 0) {\n                response.result = sig;\n              } else {\n                // The user has declined the request when value is null\n                throw new Error('declined by user');\n              }\n\n              break;\n            }\n\n          case 'eth_signTypedData':\n          case 'eth_signTypedData_v4':\n            {\n              // note: signingAddress from json-rpc input is in hex format, and typedDataObject\n              // should be an object, but in some instances may be double string encoded\n              const [signingAddress, typedDataObject] = request.params;\n              let typedData = undefined;\n\n              if (typeof typedDataObject === 'string') {\n                try {\n                  typedData = JSON.parse(typedDataObject);\n                } catch (e) {}\n              } else {\n                typedData = typedDataObject;\n              }\n\n              if (!typedData || !typedData.domain || !typedData.types || !typedData.message) {\n                throw new Error('invalid typedData object');\n              }\n\n              let sig = '';\n\n              if (_this.prompter === null) {\n                // prompter is null, so we'll sign from here\n                sig = await signer.signTypedData(typedData.domain, typedData.types, typedData.message, chainId);\n              } else {\n                const promptResultForDeployment = await _this.handleConfirmWalletDeployPrompt(_this.prompter, signer, chainId);\n\n                if (promptResultForDeployment) {\n                  sig = await _this.prompter.promptSignMessage({\n                    chainId: chainId,\n                    typedData: typedData\n                  }, _this.connectOptions);\n                }\n              }\n\n              if (sig && sig.length > 0) {\n                response.result = sig;\n              } else {\n                // The user has declined the request when value is null\n                throw new Error('declined by user');\n              }\n\n              break;\n            }\n\n          case 'eth_sendTransaction':\n            {\n              // https://eth.wiki/json-rpc/API#eth_sendtransaction\n              const [transactionParams] = request.params;\n              let txnHash = '';\n\n              if (_this.prompter === null) {\n                // prompter is null, so we'll send from here\n                const txnResponse = await signer.sendTransaction(transactionParams, chainId);\n                txnHash = txnResponse.hash;\n              } else {\n                // prompt user to provide the response\n                txnHash = await _this.prompter.promptSendTransaction(transactionParams, chainId, _this.connectOptions);\n              }\n\n              if (txnHash) {\n                response.result = txnHash;\n              } else {\n                // The user has declined the request when value is null\n                throw new Error('declined by user');\n              }\n\n              break;\n            }\n\n          case 'eth_signTransaction':\n            {\n              // https://eth.wiki/json-rpc/API#eth_signTransaction\n              const [transaction] = request.params;\n              const sender = ethers.utils.getAddress(transaction.from);\n\n              if (sender !== (await signer.getAddress())) {\n                throw new Error('sender address does not match wallet');\n              }\n\n              if (_this.prompter === null) {\n                // The eth_signTransaction method expects a `string` return value we instead return a `SignedTransactions` object,\n                // this can only be broadcasted using an RPC provider with support for signed Sequence transactions, like this one.\n                //\n                // TODO: verify serializing / transporting the SignedTransaction object works as expected, most likely however\n                // we will want to resolveProperties the bignumber values to hex strings\n                response.result = await signer.signTransactions(transaction, chainId);\n              } else {\n                response.result = await _this.prompter.promptSignTransaction(transaction, chainId, _this.connectOptions);\n              }\n\n              break;\n            }\n\n          case 'eth_sendRawTransaction':\n            {\n              // NOTE: we're not using a prompter here as the transaction is already signed\n              // and would have prompted the user upon signing.\n              // https://eth.wiki/json-rpc/API#eth_sendRawTransaction\n              if (isSignedTransactions(request.params[0])) {\n                const txChainId = BigNumber.from(request.params[0].chainId).toNumber();\n                const tx = await (await signer.getRelayer(txChainId)).relay(request.params[0]);\n                response.result = (await tx).hash;\n              } else {\n                const tx = await provider.sendTransaction(request.params[0]);\n                response.result = tx.hash;\n              }\n\n              break;\n            }\n\n          case 'eth_getTransactionCount':\n            {\n              const address = ethers.utils.getAddress(request.params[0]);\n              const tag = request.params[1];\n              const walletAddress = ethers.utils.getAddress(await signer.getAddress());\n\n              if (address === walletAddress) {\n                const count = await signer.getTransactionCount(tag);\n                response.result = ethers.BigNumber.from(count).toHexString();\n              } else {\n                const count = await provider.getTransactionCount(address, tag);\n                response.result = ethers.BigNumber.from(count).toHexString();\n              }\n\n              break;\n            }\n\n          case 'eth_blockNumber':\n            {\n              response.result = await provider.getBlockNumber();\n              break;\n            }\n\n          case 'eth_getBlockByNumber':\n            {\n              response.result = await provider.getBlock(request.params[0]\n              /* , jsonRpcRequest.params[1] */\n              );\n              break;\n            }\n\n          case 'eth_getBlockByHash':\n            {\n              response.result = await provider.getBlock(request.params[0]\n              /* , jsonRpcRequest.params[1] */\n              );\n              break;\n            }\n\n          case 'eth_getTransactionByHash':\n            {\n              response.result = await provider.getTransaction(request.params[0]);\n              break;\n            }\n\n          case 'eth_call':\n            {\n              const [transactionObject, blockTag] = request.params;\n              response.result = await provider.call(transactionObject, blockTag);\n              break;\n            }\n\n          case 'eth_getCode':\n            {\n              const [contractAddress, blockTag] = request.params;\n              response.result = await provider.getCode(contractAddress, blockTag);\n              break;\n            }\n\n          case 'eth_estimateGas':\n            {\n              const [transactionObject] = request.params;\n              response.result = await provider.estimateGas(transactionObject);\n              break;\n            }\n\n          case 'eth_gasPrice':\n            {\n              const gasPrice = await provider.getGasPrice();\n              response.result = gasPrice.toHexString();\n              break;\n            }\n\n          case 'wallet_switchEthereumChain':\n            {\n              const [switchParams] = request.params;\n\n              if (!switchParams.chainId || switchParams.chainId.length === 0) {\n                throw new Error('invalid chainId');\n              }\n\n              const _chainId = ethers.BigNumber.from(switchParams.chainId);\n\n              const ok = await _this.setDefaultNetwork(_chainId.toString(), true);\n\n              if (!ok) {\n                throw new Error(`unable to set chainId ${_chainId}`);\n              }\n\n              response.result = null; // success\n\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_getWalletContext':\n            {\n              response.result = await signer.getWalletContext();\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_getWalletConfig':\n            {\n              const [_chainId2] = request.params;\n              response.result = await signer.getWalletConfig(_chainId2);\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_getWalletState':\n            {\n              const [_chainId3] = request.params;\n              response.result = await signer.getWalletState(_chainId3);\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_getNetworks':\n            {\n              // NOTE: must ensure that the response result below returns clean serialized data, which is to omit\n              // the provider and relayer objects and only return the urls so can be reinstantiated on dapp side.\n              // This is handled by this.getNetworks() but noted here for future readers.\n              response.result = await _this.getNetworks(true);\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_updateConfig':\n            {\n              throw new Error('sequence_updateConfig method is not allowed from a dapp'); // NOTE: method is disabled as we don't need a dapp to request to update a config.\n              // However, if we ever want this, we can enable it but must also use the prompter\n              // for confirmation.\n              //\n              // const [newConfig] = request.params\n              // response.result = await signer.updateConfig(newConfig)\n\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_publishConfig':\n            {\n              throw new Error('sequence_publishConfig method is not allowed from a dapp');\n              break;\n            }\n          // relayer method\n\n          case 'sequence_estimateGasLimits':\n            {\n              // TODO\n              break;\n            }\n          // relayer method\n\n          case 'sequence_gasRefundOptions':\n            {\n              // TODO\n              break;\n            }\n          // relayer method\n\n          case 'sequence_getNonce':\n            {\n              // TODO\n              break;\n            }\n          // relayer method\n\n          case 'sequence_relay':\n            {\n              // TODO\n              break;\n            }\n          // set default network of wallet\n\n          case 'sequence_setDefaultNetwork':\n            {\n              const [defaultNetworkId] = request.params;\n\n              if (!defaultNetworkId) {\n                throw new Error('invalid request, method argument defaultNetworkId cannot be empty');\n              }\n\n              const ok = await _this.setDefaultNetwork(defaultNetworkId);\n\n              if (!ok) {\n                throw new Error(`unable to set default network ${defaultNetworkId}`);\n              }\n\n              response.result = await _this.getNetworks(true);\n              break;\n            }\n\n          default:\n            {\n              // NOTE: provider here will be chain-bound if chainId is provided\n              const providerResponse = await provider.send(request.method, request.params);\n              response.result = providerResponse;\n            }\n        }\n      } catch (err) {\n        logger.error(err); // See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md#rpc-errors\n\n        response.result = null;\n        response.error = _extends({}, new Error(err), {\n          code: 4001\n        });\n      }\n\n      callback(undefined, response);\n    };\n\n    this.isSignedIn = async function () {\n      await _this.signerReady();\n      return !!_this.signer;\n    };\n\n    this.getSigner = async function () {\n      await _this.signerReady();\n\n      if (_this.signer === undefined) {\n        throw new Error('signerReady failed resolve');\n      }\n\n      return _this.signer;\n    };\n\n    this.signer = _signer;\n    this.prompter = prompter;\n    this.mainnetNetworks = mainnetNetworks;\n    this.testnetNetworks = testnetNetworks;\n  }\n\n  async signIn(signer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.setSigner(signer);\n    const {\n      connect,\n      mainnetNetworks,\n      testnetNetworks,\n      defaultNetworkId\n    } = options;\n\n    if (mainnetNetworks && mainnetNetworks.length > 0) {\n      this.mainnetNetworks = mainnetNetworks;\n    }\n\n    if (testnetNetworks && testnetNetworks.length > 0) {\n      this.testnetNetworks = testnetNetworks;\n    }\n\n    if ((!this.mainnetNetworks || this.mainnetNetworks.length === 0) && (!this.testnetNetworks || this.testnetNetworks.length === 0)) {\n      throw new Error('signIn failed as network configuration is empty');\n    }\n\n    const networkId = defaultNetworkId || this._defaultNetworkId;\n\n    if (networkId) {\n      if (!(await this.setDefaultNetwork(networkId, false))) {\n        throw new Error(`WalletRequestHandler setup unable to set defaultNetworkId ${networkId}`);\n      }\n    } // Optionally, connect the dapp and wallet. In case connectOptions are provided, we will perform\n    // necessary auth request, and then notify the dapp of the 'connect' details.\n    //\n    // NOTE: if a user is signing into a dapp from a fresh state, and and auth request is made\n    // we don't trigger the promptConnect flow, as we consider the user just authenticated\n    // for this dapp, so its safe to authorize in the connect() method without the prompt.\n    //\n    // NOTE: signIn can optionally connect and notify dapp at this time for new signIn flows\n\n\n    if (connect) {\n      const connectOptions = this._connectOptions;\n      const connectDetails = await this.connect(connectOptions);\n      this.notifyConnect(connectDetails);\n\n      if (!connectOptions || connectOptions.keepWalletOpened !== true) {\n        this.notifyClose();\n      }\n    }\n  }\n\n  signOut() {\n    // signed out state\n    this.setSigner(null);\n  }\n\n  signerReset() {\n    // resetting signer puts the wallet in an uninitialized state, which requires the app to\n    // re-initiatize and set the signer either as \"null\" (ie. no signer) or \"Signer\" (ie. signed in).\n    this.signer = undefined;\n  }\n\n  signerReady() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SIGNER_READY_TIMEOUT;\n    return new Promise((resolve, reject) => {\n      if (this.signer !== undefined) {\n        resolve();\n      } else {\n        setTimeout(() => {\n          if (this.signer === undefined) {\n            this.signerReadyCallbacks = [];\n            reject(`signerReady timed out`);\n          }\n        }, timeout);\n        this.signerReadyCallbacks.push(resolve);\n      }\n    });\n  }\n\n  async connect(options) {\n    if (!this.signer) {\n      return {\n        connected: false,\n        chainId: '0x0',\n        error: 'unable to connect without signed in account'\n      };\n    }\n\n    const connectDetails = {\n      connected: true,\n      chainId: ethers.utils.hexlify(await this.getChainId())\n    };\n\n    if (options && options.authorize) {\n      // Perform ethauth eip712 request and construct the ConnectDetails response\n      // including the auth proof\n      const authOptions = {\n        app: options.app,\n        origin: options.origin,\n        expiry: options.expiry\n      }; // if (typeof(options.authorize) === 'object') {\n      //   authOptions = { ...authOptions, ...options.authorize }\n      // }\n\n      try {\n        connectDetails.proof = await signAuthorization(this.signer, authOptions);\n      } catch (err) {\n        logger.warn(`connect, signAuthorization failed for options: ${JSON.stringify(options)}, due to: ${err.message}`);\n        return {\n          connected: false,\n          chainId: '0x0',\n          error: `signAuthorization failed: ${err.message}`\n        };\n      }\n    } // Build session response for connect details\n\n\n    connectDetails.session = await this.walletSession();\n    return connectDetails;\n  } // sendMessageRequest will unwrap the ProviderMessageRequest and send it to the JsonRpcHandler\n  // (aka, the signer in this instance) and then responds with a wrapped response of\n  // ProviderMessageResponse to be sent over the transport\n\n\n  sendMessageRequest(message) {\n    return new Promise(resolve => {\n      this.sendAsync(message.data, (error, response) => {\n        // TODO: if response includes data.error, why do we need a separate error argument here?\n        const responseMessage = _extends({}, message, {\n          data: response\n        }); // NOTE: we always resolve here, are the sendAsync call will wrap any exceptions\n        // in the error field of the response to ensure we send back to the user\n\n\n        resolve(responseMessage);\n      }, message.chainId);\n    });\n  } // sendAsync implements the JsonRpcHandler interface for sending JsonRpcRequests to the wallet\n\n\n  on(event, fn) {\n    this.events.on(event, fn);\n  }\n\n  once(event, fn) {\n    this.events.once(event, fn);\n  }\n\n  async getAddress() {\n    if (!this.signer) {\n      return '';\n    } else {\n      return this.signer.getAddress();\n    }\n  }\n\n  async getChainId() {\n    if (!this.signer) {\n      return 0;\n    } else {\n      if (this._chainId) return this._chainId; // memoized\n\n      this._chainId = await this.signer.getChainId();\n      return this._chainId;\n    }\n  }\n\n  get openIntent() {\n    return this._openIntent;\n  }\n\n  setOpenIntent(intent) {\n    this._openIntent = intent;\n  }\n\n  get connectOptions() {\n    return this._connectOptions;\n  }\n\n  setConnectOptions(options) {\n    this._connectOptions = options;\n  }\n\n  get defaultNetworkId() {\n    return this._defaultNetworkId;\n  }\n\n  async setDefaultNetwork(chainId) {\n    let notifyNetworks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (!chainId) return undefined;\n    this._defaultNetworkId = chainId;\n    this._chainId = undefined;\n\n    if (this.signer && this.signer.setNetworks) {\n      const defaultChainId = this.signer.setNetworks(this.mainnetNetworks, this.testnetNetworks, chainId);\n\n      if (defaultChainId && notifyNetworks) {\n        await this.notifyNetworks();\n      }\n\n      return defaultChainId;\n    } else {\n      return undefined;\n    }\n  }\n\n  async getNetworks(jsonRpcResponse) {\n    if (!this.signer) {\n      logger.warn('signer not set: getNetworks is returning an empty list');\n      return [];\n    }\n\n    const networks = await this.signer.getNetworks();\n\n    if (jsonRpcResponse) {\n      // omit provider and relayer objects as they are not serializable\n      return networks.map(n => {\n        const network = _extends({}, n);\n\n        network.provider = undefined;\n        network.relayer = undefined;\n        return network;\n      });\n    } else {\n      return networks;\n    }\n  }\n\n  async walletSession() {\n    return !this.signer ? undefined : {\n      walletContext: await this.signer.getWalletContext(),\n      accountAddress: await this.signer.getAddress(),\n      networks: await this.getNetworks(true)\n    };\n  }\n\n  notifyConnect(connectDetails, origin) {\n    var _connectDetails$sessi;\n\n    this.events.emit('connect', connectDetails);\n\n    if ((_connectDetails$sessi = connectDetails.session) != null && _connectDetails$sessi.accountAddress) {\n      var _connectDetails$sessi2;\n\n      this.events.emit('accountsChanged', [(_connectDetails$sessi2 = connectDetails.session) == null ? void 0 : _connectDetails$sessi2.accountAddress], origin);\n    }\n  }\n\n  notifyDisconnect(origin) {\n    this.events.emit('accountsChanged', [], origin);\n    this.events.emit('disconnect');\n  }\n\n  async notifyNetworks(networks) {\n    const n = networks || (await this.getNetworks(true));\n    this.events.emit('networks', n);\n\n    if (n.length > 0) {\n      const defaultNetwork = n.find(network => network.isDefaultChain);\n\n      if (defaultNetwork) {\n        this.events.emit('chainChanged', ethers.utils.hexlify(defaultNetwork.chainId));\n      }\n    } else {\n      this.events.emit('chainChanged', '0x0');\n    }\n  }\n\n  async notifyWalletContext() {\n    if (!this.signer) {\n      logger.warn('signer not set: skipping to notify wallet context');\n      return;\n    }\n\n    const walletContext = await this.signer.getWalletContext();\n    this.events.emit('walletContext', walletContext);\n  }\n\n  notifyClose(error) {\n    this.events.emit('close', error);\n  }\n\n  setSigner(signer) {\n    this.signer = signer;\n\n    if (signer !== undefined) {\n      for (let i = 0; i < this.signerReadyCallbacks.length; i++) {\n        this.signerReadyCallbacks[i]();\n      }\n\n      this.signerReadyCallbacks = [];\n    }\n  }\n\n  async handleConfirmWalletDeployPrompt(prompter, signer, chainId) {\n    // check if wallet is deployed and up to date, if not, prompt user to deploy\n    // if no chainId is provided, we'll assume the wallet is auth chain wallet and is up to date\n    if (!chainId) {\n      return true;\n    }\n\n    const isUpToDate = await isWalletUpToDate(signer, chainId);\n\n    if (isUpToDate) {\n      return true;\n    }\n\n    const promptResult = await prompter.promptConfirmWalletDeploy(chainId, this.connectOptions); // if client returned true, check again to make sure wallet is deployed and up to date\n\n    if (promptResult) {\n      const isPromptResultCorrect = await isWalletUpToDate(signer, chainId);\n\n      if (!isPromptResultCorrect) {\n        logger.error('WalletRequestHandler: result for promptConfirmWalletDeploy is not correct');\n        return false;\n      } else {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nconst permittedJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_getBalance', 'eth_getTransactionCount', 'eth_blockNumber', 'eth_getBlockByNumber', 'eth_getBlockByHash', 'eth_getTransactionByHash', 'eth_getCode', 'eth_estimateGas', 'eth_gasPrice', 'sequence_getWalletContext', 'sequence_getNetworks', 'sequence_setDefaultNetwork'];\n\nclass Web3Provider extends Web3Provider$1 {\n  static isSequenceProvider(cand) {\n    return isSequenceProvider(cand);\n  }\n\n  constructor(provider, defaultChainId) {\n    const sender = new JsonRpcSender(provider, maybeChainId(defaultChainId));\n    provider = sender;\n    super(provider, 'any');\n    this._sender = void 0;\n    this._isSequenceProvider = void 0;\n    this._defaultChainId = void 0;\n    this._sender = sender;\n    this._isSequenceProvider = true;\n    this._defaultChainId = maybeChainId(defaultChainId);\n  }\n\n  sendAsync(request, callback, chainId) {\n    this._sender.sendAsync(request, callback, chainId);\n  }\n\n  send(method, params, chainId) {\n    return this._sender.send(method, params, chainId);\n  }\n\n  request(request) {\n    return this.send(request.method, request.params || [], request.chainId);\n  }\n\n  getSigner() {\n    return new Web3Signer(this, this._defaultChainId);\n  }\n\n  async getChainId() {\n    // TODO: is it safe to memoize this?\n    const result = await this.send('eth_chainId', []);\n    const chainId = ethers.BigNumber.from(result).toNumber();\n\n    if (this._defaultChainId && this._defaultChainId !== chainId) {\n      throw new Error(`provider chainId (${chainId}) does not match provider-bound chainId ${this._defaultChainId}`);\n    }\n\n    return chainId;\n  }\n\n}\n\nfunction isSequenceProvider(provider) {\n  const cand = provider;\n  return cand && cand.send !== undefined && cand._isSequenceProvider === true;\n}\n\nclass LocalWeb3Provider extends Web3Provider {\n  constructor(signer, networks) {\n    const walletRequestHandler = new WalletRequestHandler(signer, null, networks || []);\n    super(walletRequestHandler);\n  }\n\n}\n\nclass Web3Signer extends Signer {\n  constructor(provider, defaultChainId) {\n    super();\n    this.provider = void 0;\n    this.defaultChainId = void 0;\n    this._address = void 0;\n    this._index = void 0;\n    this._context = void 0;\n    this._networks = void 0;\n    this._providers = {};\n    this.provider = provider;\n    this.defaultChainId = defaultChainId;\n  } // memoized\n  //\n  // ethers AbstractSigner methods\n  //\n\n\n  async getAddress() {\n    if (this._address) return this._address;\n    const accounts = await this.provider.send('eth_accounts', []);\n    this._address = accounts[0];\n    this._index = 0;\n    return ethers.utils.getAddress(this._address);\n  }\n\n  signTransaction(transaction) {\n    // TODO .. since ethers isn't using this method, perhaps we will?\n    throw new Error('signTransaction is unsupported, use signTransactions instead');\n  }\n\n  connect(provider) {\n    throw new Error('unsupported: cannot alter JSON-RPC Signer connection');\n  } //\n  // Sequence Signer methods\n  //\n  // getProvider returns a Web3Provider instance for the current chain. Note that this method\n  // and signer is bound to a particular chain to prevent misuse. If you'd like a provider\n  // for a specific chain, try getSender(chainId), or wallet.getProvider(chainId).\n\n\n  async getProvider(chainId) {\n    if (chainId) {\n      const currentChainId = await this.getChainId();\n\n      if (currentChainId !== chainId) {\n        throw new Error(`signer is attempting to access chain ${chainId}, but is already bound to chain ${currentChainId}`);\n      }\n    }\n\n    return this.provider;\n  } // getSender returns a Web3Provider instance via the signer transport. Note: for our case\n  // the of sequence wallet, this will bring up the wallet window whenever using it, as the json-rpc\n  // requests are sent to the window transport. Therefore, for anything non-signing related\n  // you can write a higher-order JsonRpcRouter sender to route to the public provider endpoints\n  // as we do in the WalletProvider.\n  //\n  // This method is primarily utilized internally when routing requests to a particular chainId.\n\n\n  async getSender(chainId) {\n    if (!chainId || chainId && chainId === this.defaultChainId) {\n      return this.provider;\n    }\n\n    if (!this._providers[chainId]) {\n      this._providers[chainId] = new Web3Provider(new JsonRpcSender(this.provider, chainId), chainId);\n    }\n\n    return this._providers[chainId];\n  }\n\n  getRelayer(chainId) {\n    // TODO: JsonRpcRelayer ......? or, Web3Relayer.. or SequenceRelayer?\n    // sequence_estimateGasLimits\n    // sequence_gasRefundOptions\n    // sequence_getNonce\n    // sequence_relay\n    throw new Error('TODO');\n  }\n\n  async getWalletContext() {\n    if (!this._context) {\n      this._context = await this.provider.send('sequence_getWalletContext', []);\n    }\n\n    return this._context;\n  }\n\n  async getWalletConfig(chainId) {\n    return await this.provider.send('sequence_getWalletConfig', [maybeChainId(chainId)], maybeChainId(chainId) || this.defaultChainId);\n  }\n\n  async getWalletState(chainId) {\n    return await this.provider.send('sequence_getWalletState', [maybeChainId(chainId)], maybeChainId(chainId) || this.defaultChainId);\n  }\n\n  async getNetworks() {\n    if (!this._networks) {\n      this._networks = await this.provider.send('sequence_getNetworks', []);\n    }\n\n    return this._networks;\n  }\n\n  async getSigners() {\n    const networks = await this.getNetworks();\n    const authChainId = networks.find(n => n.isAuthChain);\n\n    if (!authChainId) {\n      throw new Error('authChainId could not be determined from network list');\n    }\n\n    const walletConfig = await this.getWalletConfig(authChainId);\n\n    if (!walletConfig || walletConfig.length === 0) {\n      throw new Error(`walletConfig returned zero results for authChainId {authChainId}`);\n    }\n\n    return walletConfig[0].signers.map(s => s.address);\n  } // signMessage matches implementation from ethers JsonRpcSigner for compatibility, but with\n  // multi-chain support.\n\n\n  async signMessage(message, chainId, allSigners) {\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);\n    const data = typeof message === 'string' ? ethers.utils.toUtf8Bytes(message) : message;\n    const address = await this.getAddress(); // NOTE: as of ethers v5.5, it switched to using personal_sign, see\n    // https://github.com/ethers-io/ethers.js/pull/1542 and see\n    // https://github.com/WalletConnect/walletconnect-docs/issues/32 for additional info.\n\n    return await provider.send('personal_sign', [ethers.utils.hexlify(data), address]);\n  } // signTypedData matches implementation from ethers JsonRpcSigner for compatibility, but with\n  // multi-chain support.\n\n\n  async signTypedData(domain, types, message, chainId, allSigners) {\n    // Populate any ENS names (in-place)\n    // const populated = await ethers.utils._TypedDataEncoder.resolveNames(domain, types, message, (name: string) => {\n    //   return this.provider.resolveName(name)\n    // })\n    return await this.provider.send('eth_signTypedData_v4', [await this.getAddress(), ethers.utils._TypedDataEncoder.getPayload(domain, types, message)], maybeChainId(chainId) || this.defaultChainId);\n  } // sendTransaction matches implementation from ethers JsonRpcSigner for compatibility, but with\n  // multi-chain support.\n\n\n  async sendTransaction(transaction, chainId, allSigners) {\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);\n    const tx = this.sendUncheckedTransaction(transaction, chainId).then(hash => {\n      return ethers.utils.poll(() => {\n        return provider.getTransaction(hash).then(tx => {\n          if (tx === null) {\n            return undefined;\n          }\n\n          return provider._wrapTransaction(tx, hash);\n        });\n      }, {\n        onceBlock: this.provider\n      }).catch(error => {\n        error.transactionHash = hash;\n        throw error;\n      });\n    }); // @ts-ignore\n\n    return tx;\n  } // sendTransactionBatch is a convenience method to call sendTransaction in a batch format, allowing you to\n  // send multiple transaction as a single payload and just one on-chain transaction.\n\n\n  async sendTransactionBatch(transactions, chainId, allSigners) {\n    const batch = await resolveArrayProperties(transactions);\n\n    if (!batch || batch.length === 0) {\n      throw new Error('cannot send empty batch');\n    } // sendTransactionBatch only accepts TransactionRequest, not TransactionResponses\n\n\n    if (batch.find(v => v.wait !== undefined && v.wait !== null)) {\n      throw new Error('transaction request expected for sendTransactionBatch, transaction response found');\n    }\n\n    const tx = _extends({}, batch[0]);\n\n    if (batch.length > 1) {\n      tx.auxiliary = batch.splice(1);\n    }\n\n    return this.sendTransaction(tx, chainId, allSigners);\n  }\n\n  signTransactions(transaction, chainId, allSigners) {\n    transaction = shallowCopy(transaction); // TODO: transaction argument..? make sure to resolve any properties and serialize property before sending over\n    // the wire.. see sendUncheckedTransaction and resolveProperties\n\n    return this.provider.send('eth_signTransaction', [transaction], maybeChainId(chainId) || this.defaultChainId);\n  }\n\n  sendSignedTransactions(signedTxs, chainId) {\n    // sequence_relay\n    throw new Error('TODO');\n  } // updateConfig..\n  // NOTE: this is not supported by the remote wallet by default.\n\n\n  async updateConfig(newConfig) {\n    // sequence_updateConfig\n    const [config, tx] = await this.provider.send('sequence_updateConfig', [newConfig], this.defaultChainId);\n\n    if (tx === null) {\n      return [config, undefined];\n    }\n\n    const provider = await this.getSender(this.defaultChainId);\n    return [config, provider._wrapTransaction(tx, tx.hash)];\n  } // publishConfig..\n  // NOTE: this is not supported by the remote wallet by default.\n\n\n  async publishConfig() {\n    const provider = await this.getSender(this.defaultChainId);\n    const tx = await provider.send('sequence_publishConfig', []);\n\n    if (tx === null) {\n      return undefined;\n    }\n\n    return provider._wrapTransaction(tx, tx.hash);\n  }\n\n  async isDeployed(chainId) {\n    const provider = await this.getSender(maybeChainId(chainId));\n    const walletCode = await provider.getCode(await this.getAddress());\n    return !!walletCode && walletCode !== '0x';\n  } //\n  // ethers JsonRpcSigner methods\n  //\n\n\n  async _legacySignMessage(message, chainId, allSigners) {\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);\n    const data = typeof message === 'string' ? ethers.utils.toUtf8Bytes(message) : message;\n    const address = await this.getAddress(); // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    // NOTE: ethers since 5.5 has switched to using personal_sign, we should review, etc.\n\n    return await provider.send('eth_sign', [address, ethers.utils.hexlify(data)]);\n  }\n\n  async _signTypedData(domain, types, message, chainId, allSigners) {\n    return this.signTypedData(domain, types, message, chainId, allSigners);\n  }\n\n  async sendUncheckedTransaction(transaction, chainId) {\n    transaction = shallowCopy(transaction);\n    const fromAddress = this.getAddress(); // NOTE: we do not use provider estimation, and instead rely on our relayer to determine the gasLimit and gasPrice\n    //\n    // TODO: alternatively/one day, we could write a provider middleware to eth_estimateGas\n    // and send it to our relayer url instead for estimation..\n    //\n    // if (!transaction.gasLimit) {\n    //   const estimate = shallowCopy(transaction)\n    //   estimate.from = fromAddress\n    //   transaction.gasLimit = this.provider.estimateGas(estimate)\n    // }\n\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);\n    return resolveProperties({\n      tx: resolveProperties(transaction),\n      sender: await fromAddress\n    }).then(_ref => {\n      let {\n        tx,\n        sender\n      } = _ref;\n\n      if (tx.from != null) {\n        if (ethers.utils.getAddress(tx.from) !== sender) {\n          // logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction)\n          throw new Error(`from address mismatch for transaction ${transaction}`);\n        }\n      } else {\n        tx.from = sender;\n      }\n\n      const hexTx = hexlifyTransaction(tx);\n      return provider.send('eth_sendTransaction', [hexTx]).then(hash => {\n        return hash;\n      }, error => {\n        // return checkError(\"sendTransaction\", error, hexTx)\n        throw new Error(`sendTransaction ${error}`);\n      });\n    });\n  }\n\n  connectUnchecked() {\n    throw new Error('connectUnchecked is unsupported');\n  }\n\n  async unlock(password) {\n    const address = await this.getAddress();\n    return this.provider.send('personal_unlockAccount', [address, password, null]);\n  }\n\n} // NOTE: method has been copied + modified from ethers.js JsonRpcProvider\n// Convert an ethers.js transaction into a JSON-RPC transaction\n\n\nconst allowedTransactionKeys = {\n  chainId: true,\n  data: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  value: true,\n  from: true,\n  auxiliary: true,\n  expiration: true,\n  afterNonce: true,\n  delegateCall: true,\n  revertOnError: true\n};\n\nconst hexlifyTransaction = (transaction, allowExtra) => {\n  // Check only allowed properties are given\n  const allowed = shallowCopy(allowedTransactionKeys);\n\n  if (allowExtra) {\n    for (const key in allowExtra) {\n      if (allowExtra[key]) {\n        allowed[key] = true;\n      }\n    }\n  }\n\n  ethers.utils.checkProperties(transaction, allowed);\n  const result = {} // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n  ;\n  ['gasLimit', 'gasPrice', 'nonce', 'value'].forEach(key => {\n    if (!transaction[key]) {\n      return;\n    }\n\n    const value = ethers.utils.hexValue(transaction[key]);\n\n    if (key === 'gasLimit') {\n      key = 'gas';\n    }\n\n    result[key] = value;\n  });\n  ['from', 'to', 'data'].forEach(key => {\n    if (!transaction[key]) {\n      return;\n    }\n\n    result[key] = ethers.utils.hexlify(transaction[key]);\n  });\n  const auxiliary = transaction['auxiliary'];\n\n  if (auxiliary && auxiliary.length > 0) {\n    result['auxiliary'] = [];\n    auxiliary.forEach(a => {\n      result['auxiliary'].push(hexlifyTransaction(a));\n    });\n  }\n\n  return result;\n};\n\nconst eip191prefix = ethers.utils.toUtf8Bytes('\\x19Ethereum Signed Message:\\n');\n\nconst messageToBytes = message => {\n  if (ethers.utils.isBytes(message) || ethers.utils.isHexString(message)) {\n    return ethers.utils.arrayify(message);\n  }\n\n  return ethers.utils.toUtf8Bytes(message);\n};\n\nconst prefixEIP191Message = message => {\n  const messageBytes = messageToBytes(message);\n  return ethers.utils.concat([eip191prefix, ethers.utils.toUtf8Bytes(String(messageBytes.length)), messageBytes]);\n};\n\nconst isValidSignature = async (address, digest, sig, provider, chainId, walletContext) => {\n  if (!chainId) {\n    var _await$provider$getNe;\n\n    chainId = (_await$provider$getNe = await provider.getNetwork()) == null ? void 0 : _await$provider$getNe.chainId;\n  }\n\n  if (!walletContext && Web3Provider.isSequenceProvider(provider)) {\n    walletContext = await provider.getSigner().getWalletContext();\n  }\n\n  return isValidSignature$1(address, digest, sig, provider, walletContext, chainId);\n};\n\nconst isValidMessageSignature = async (address, message, signature, provider, chainId, walletContext) => {\n  const prefixed = prefixEIP191Message(message);\n  const digest = encodeMessageDigest(prefixed);\n  return isValidSignature(address, digest, signature, provider, chainId, walletContext);\n};\n\nconst isValidTypedDataSignature = (address, typedData, signature, provider, chainId, walletContext) => {\n  return isValidSignature(address, encodeTypedDataDigest(typedData), signature, provider, chainId, walletContext);\n};\n\nconst recoverWalletConfig = async (address, digest, signature, chainId, walletContext) => {\n  const subDigest = packMessageData(address, chainId, digest);\n  const config = await recoverConfig(subDigest, signature);\n\n  if (walletContext) {\n    const recoveredWalletAddress = addressOf(config, walletContext);\n\n    if (config.address && config.address !== recoveredWalletAddress) {\n      throw new Error('recovered address does not match the WalletConfig address, check the WalletContext');\n    } else {\n      config.address = recoveredWalletAddress;\n    }\n  }\n\n  return config;\n};\n\nconst isBrowserExtension = () => window.location.protocol === 'chrome-extension:' || window.location.protocol === 'moz-extension:';\n/**\n * Returns the status of a signer's wallet on given chain by checking wallet deployment and config status\n *\n * @param {Signer} signer\n * @param {number} chainId\n * @return {Promise<boolean>} Promise that returns true if the wallet is up to date, false otherwise\n */\n\n\nconst isWalletUpToDate = async (signer, chainId) => {\n  var _walletState$find;\n\n  const walletState = await signer.getWalletState();\n  const networks = await signer.getNetworks();\n  const walletStateForRequiredChain = walletState.find(state => state.chainId === chainId);\n\n  if (!walletStateForRequiredChain) {\n    throw new Error(`WalletRequestHandler: could not find wallet state for chainId ${chainId}`);\n  }\n\n  const isDeployed = walletStateForRequiredChain.deployed;\n\n  if (!networks) {\n    throw new Error(`isWalletUpToDate util: could not get networks from signer`);\n  }\n\n  const authChain = networks.find(network => network.isAuthChain);\n\n  if (!authChain) {\n    throw new Error(`isWalletUpToDate util: could not get auth chain network information`);\n  }\n\n  const authChainId = authChain.chainId;\n  const authChainConfig = (_walletState$find = walletState.find(state => state.chainId === authChainId)) == null ? void 0 : _walletState$find.config;\n\n  if (!authChainConfig) {\n    throw new Error(`isWalletUpToDate util: could not get auth chain config`);\n  }\n\n  const requiredChainConfig = walletStateForRequiredChain.config;\n\n  if (!requiredChainConfig) {\n    throw new Error(`isWalletUpToDate util: could not get config for chainId ${chainId}`);\n  }\n\n  const isUpToDate = isConfigEqual(authChainConfig, requiredChainConfig);\n  return isDeployed && isUpToDate;\n};\n\nclass LocalStorage {\n  constructor() {}\n\n  static getInstance() {\n    if (!LocalStorage._instance) {\n      LocalStorage._instance = {\n        getItem: key => Promise.resolve(window.localStorage.getItem(key)),\n        setItem: (key, value) => Promise.resolve(window.localStorage.setItem(key, value)),\n        removeItem: key => Promise.resolve(window.localStorage.removeItem(key))\n      };\n    }\n\n    return this._instance;\n  }\n\n  static use(instance) {\n    LocalStorage._instance = instance;\n  }\n\n} // window.localstorage helper\n\n\nLocalStorage._instance = void 0;\n\nclass LocalStore {\n  constructor(key, def) {\n    this.def = def;\n    this.key = void 0;\n    this.key = key;\n  }\n\n  async get() {\n    const val = await LocalStorage.getInstance().getItem(this.key);\n\n    if (val === null) {\n      return this.def;\n    }\n\n    try {\n      return JSON.parse(val);\n    } catch (err) {\n      console.error(err);\n    }\n\n    return;\n  }\n\n  set(val) {\n    val ? LocalStorage.getInstance().setItem(this.key, JSON.stringify(val)) : LocalStorage.getInstance().removeItem(this.key);\n  }\n\n  del() {\n    LocalStorage.getInstance().removeItem(this.key);\n  }\n\n}\n\nconst TRANSPORT_SESSION_LS_KEY = '@sequence.transportSession';\n\nclass BaseWalletTransport {\n  // appOrigin identifies the dapp's origin which opened the app. A transport\n  // will auto-detect and set this value if it can. This is determined\n  // as the parent app/window which opened the wallet.\n  constructor(walletRequestHandler) {\n    var _this = this;\n\n    this.walletRequestHandler = void 0;\n    this._sessionId = void 0;\n    this._registered = void 0;\n    this._init = void 0;\n    this._initNonce = void 0;\n    this._initCallback = void 0;\n    this.appOrigin = void 0;\n\n    this.sendAsync = async function (request, callback, chainId) {\n      throw new Error('abstract method');\n    };\n\n    this.handleMessage = async function (message) {\n      const request = message; // ensure initial handshake is complete before accepting\n      // other kinds of messages.\n\n      if (_this._init !== InitState.OK) {\n        if (request.type === EventType.INIT) {\n          if (_this.isValidInitAck(message)) {\n            // successful init\n            if (_this._initCallback) _this._initCallback();\n          } else {\n            // failed init\n            if (_this._initCallback) _this._initCallback('invalid init');\n            return;\n          }\n        }\n\n        return;\n      } // ensure signer is ready to handle requests\n      // if (this.walletRequestHandler.getSigner() === undefined) {\n      //   await this.walletRequestHandler.signerReady()\n      // }\n      // handle request\n\n\n      switch (request.type) {\n        case EventType.OPEN:\n          {\n            if (_this._init !== InitState.OK) return;\n            const session = {\n              sessionId: request.data.sessionId,\n              intent: request.data.intent,\n              networkId: request.data.networkId\n            };\n            await _this.open(session);\n            return;\n          }\n\n        case EventType.CLOSE:\n          {\n            if (_this._init !== InitState.OK) return; // noop. just here to capture the message so event emitters may be notified\n\n            return;\n          }\n\n        case EventType.MESSAGE:\n          {\n            const response = await _this.walletRequestHandler.sendMessageRequest(request);\n\n            _this.sendMessage(response);\n\n            if (response.data.error) ;\n            return;\n          }\n\n        default:\n          {\n            logger.error(`unexpected payload type ${request.type}`);\n          }\n      }\n    };\n\n    this.sendMessageRequest = async function (message) {\n      return _this.walletRequestHandler.sendMessageRequest(message);\n    };\n\n    this.open = async function (_ref2) {\n      let {\n        sessionId,\n        intent,\n        networkId\n      } = _ref2;\n\n      if (sessionId) {\n        _this._sessionId = sanitizeNumberString(sessionId); // persist transport session in localstorage for restoring after redirect/reload\n\n        _this.saveTransportSession({\n          sessionId,\n          intent,\n          networkId\n        });\n      }\n\n      _this.walletRequestHandler.setOpenIntent(intent); // init handshake for certain transports, before we can open the communication.\n      //\n      // for example, with the window-transport, we have to exchange messages to determine the\n      // origin host of the dapp.\n\n\n      await _this.init(); // Prepare connect options from intent\n\n      if (intent && intent.type === 'connect' && intent.options) {\n        const connectOptions = intent.options;\n        const authorizeOptions = connectOptions; // overlapping types\n        // Sanity/integrity check the intent payload, and set authorization origin\n        // if its been determined as part of the init handshake from earlier.\n\n        if (_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {\n          if (!isBrowserExtension()) {\n            if (authorizeOptions.origin !== _this.appOrigin) {\n              throw new Error('origin is invalid');\n            }\n          }\n        } else if (!_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {\n          // ie. when we can't determine the origin in our transport, but dapp provides it to us.\n          // we just sanitize the origin host.\n          connectOptions.origin = sanitizeHost(authorizeOptions.origin);\n        } else if (_this.appOrigin) {\n          // ie. when we auto-determine the origin such as in window-transport\n          connectOptions.origin = _this.appOrigin;\n        }\n\n        if (connectOptions.app) {\n          connectOptions.app = sanitizeAlphanumeric(connectOptions.app);\n        } // Set connect options on the walletRequestHandler as our primary\n        // wallet controller\n\n\n        _this.walletRequestHandler.setConnectOptions(connectOptions);\n\n        if (connectOptions.networkId) {\n          networkId = connectOptions.networkId;\n        }\n      } else {\n        _this.walletRequestHandler.setConnectOptions(undefined);\n      } // ensure signer is ready\n\n\n      await _this.walletRequestHandler.getSigner(); // Notify open and proceed to prompt for connection if intended\n\n      if (!(await _this.walletRequestHandler.isSignedIn())) {\n        // open wallet without a specific connected chainId, as the user is not signed in\n        _this.notifyOpen({\n          sessionId: _this._sessionId\n        });\n\n        return true;\n      } else {\n        // Set default network, in case of error chainId will be undefined or 0\n        let chainId = undefined;\n\n        try {\n          if (networkId) {\n            chainId = await _this.walletRequestHandler.setDefaultNetwork(networkId, false);\n          } else {\n            chainId = await _this.walletRequestHandler.getChainId();\n          }\n        } catch (err) {\n          console.error(err);\n        } // Failed to set default network on open -- quit + close\n\n\n        if (!chainId || chainId <= 0) {\n          _this.notifyOpen({\n            sessionId: _this._sessionId,\n            error: `failed to open wallet on network ${networkId}`\n          });\n\n          return false;\n        } // prompt user with a connect request. the options will be used as previously set above.\n        // upon success, the walletRequestHandler will notify the dapp with the ConnectDetails.\n        // upon cancellation by user, the walletRequestHandler will throw an error\n\n\n        if (intent && intent.type === 'connect') {\n          // notify wallet is opened, without session details\n          _this.notifyOpen({\n            sessionId: _this._sessionId\n          });\n\n          try {\n            const connectDetails = await _this.walletRequestHandler.promptConnect(intent.options);\n\n            if (connectDetails.connected) {\n              _this.walletRequestHandler.notifyConnect(connectDetails);\n            }\n          } catch (err) {\n            logger.warn('promptConnect not connected:', err);\n          } finally {\n            // auto-close by default, unless intent is to keep open\n            if (!intent.options || intent.options.keepWalletOpened !== true) {\n              _this.notifyClose();\n            }\n          }\n        } else {\n          // user is already connected, notify session details.\n          // TODO: in future, keep list if 'connected' dapps / sessions in the session\n          // controller, and only sync with allowed apps\n          _this.notifyOpen({\n            sessionId: _this._sessionId,\n            chainId: `${chainId}`,\n            session: await _this.walletRequestHandler.walletSession()\n          });\n        }\n      }\n\n      return true;\n    };\n\n    this.saveTransportSession = session => {\n      LocalStorage.getInstance().setItem(TRANSPORT_SESSION_LS_KEY, JSON.stringify(session));\n    };\n\n    this.getCachedTransportSession = async function () {\n      const session = await LocalStorage.getInstance().getItem(TRANSPORT_SESSION_LS_KEY);\n\n      try {\n        return session ? JSON.parse(session) : null;\n      } catch (err) {\n        console.error(`unable to parse transport session: ${session}`);\n        return null;\n      }\n    };\n\n    this.walletRequestHandler = walletRequestHandler;\n    this._init = InitState.NIL;\n    this.walletRequestHandler.on('connect', connectDetails => {\n      if (!this.registered) return; // means user has logged in and wallet is connected to the app\n\n      this.notifyConnect(connectDetails);\n    });\n    this.walletRequestHandler.on('disconnect', error => {\n      if (!this.registered) return; // means user has logged out the app / disconnected wallet from the app\n\n      this.notifyDisconnect(error);\n    });\n    this.walletRequestHandler.on('accountsChanged', (accounts, origin) => {\n      if (!this.registered) return;\n      this.notifyAccountsChanged(accounts, origin);\n    });\n    this.walletRequestHandler.on('networks', networks => {\n      if (!this.registered) return;\n      this.notifyNetworks(networks);\n\n      if (!networks || networks.length === 0) {\n        this.notifyChainChanged('0x0');\n      } else {\n        this.notifyChainChanged(ethers.utils.hexlify(networks.find(network => network.isDefaultChain).chainId));\n      }\n    });\n    this.walletRequestHandler.on('walletContext', walletContext => {\n      if (!this.registered || !walletContext) return;\n      this.notifyWalletContext(walletContext);\n    });\n    this.walletRequestHandler.on('close', error => {\n      if (!this.registered) return;\n      this.notifyClose(error);\n    });\n  }\n\n  get registered() {\n    return this._registered;\n  }\n\n  register() {\n    throw new Error('abstract method');\n  }\n\n  unregister() {\n    throw new Error('abstract method');\n  }\n\n  sendMessage(message) {\n    throw new Error('abstract method');\n  }\n\n  notifyOpen(openInfo) {\n    const {\n      chainId,\n      sessionId,\n      session,\n      error\n    } = openInfo;\n    this.sendMessage({\n      idx: -1,\n      type: EventType.OPEN,\n      data: {\n        chainId,\n        sessionId,\n        session,\n        error\n      }\n    });\n  }\n\n  notifyClose(error) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CLOSE,\n      data: error ? {\n        error\n      } : null\n    });\n  }\n\n  notifyConnect(connectDetails) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CONNECT,\n      data: connectDetails\n    });\n  }\n\n  notifyDisconnect(error) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.DISCONNECT,\n      data: error ? {\n        error\n      } : null\n    });\n  }\n\n  notifyAccountsChanged(accounts, origin) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.ACCOUNTS_CHANGED,\n      data: accounts,\n      origin: origin\n    });\n  }\n\n  notifyChainChanged(chainIdHex) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CHAIN_CHANGED,\n      data: chainIdHex\n    });\n  }\n\n  notifyNetworks(networks) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.NETWORKS,\n      data: networks\n    });\n  }\n\n  notifyWalletContext(walletContext) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.WALLET_CONTEXT,\n      data: walletContext\n    });\n  }\n\n  isValidInitAck(message) {\n    if (this._init === InitState.OK) {\n      // we're already in init state, we shouldn't handle this message\n      logger.warn(\"isValidInitAck, already in init'd state, so inquiry is invalid.\");\n      return false;\n    }\n\n    if (message.type !== EventType.INIT) {\n      logger.warn('isValidInitAck, invalid message type, expecting init');\n      return false;\n    }\n\n    const {\n      sessionId,\n      nonce\n    } = message.data;\n\n    if (!sessionId || sessionId.length === 0 || !nonce || nonce.length === 0) {\n      logger.error('invalid init ack');\n      return false;\n    }\n\n    if (sessionId !== this._sessionId || nonce !== this._initNonce) {\n      logger.error('invalid init ack match');\n      return false;\n    } // all checks pass, its true\n\n\n    return true;\n  }\n\n  init() {\n    return new Promise((resolve, reject) => {\n      // avoid re-init`ing, or if there is a transport which doesn't require\n      // it, then it may set this._init to OK in its constructor.\n      if (this._init === InitState.OK) {\n        resolve();\n        return;\n      }\n\n      if (this._init !== InitState.NIL || this._initCallback) {\n        reject('transport init is in progress');\n        return;\n      } // start init timeout, if we don't receive confirmation\n      // from provider within this amount of time, then we timeout\n\n\n      const initTimeout = setTimeout(() => {\n        logger.warn('transport init timed out');\n\n        if (this._initCallback) {\n          this._initCallback('transport init timed out');\n        }\n      }, PROVIDER_OPEN_TIMEOUT / 2); // setup callback as we receive the init message async in the handleMessage function\n\n      this._initCallback = error => {\n        this._initCallback = undefined; // reset\n\n        clearTimeout(initTimeout);\n\n        if (error) {\n          reject(error);\n        } else {\n          this._init = InitState.OK;\n          resolve();\n        }\n      }; // send init request with random nonce to the provider, where we expect\n      // for the provider to echo it back to us as complete handshake\n\n\n      this._initNonce = `${performance.now()}`;\n      this.sendMessage({\n        idx: -1,\n        type: EventType.INIT,\n        data: {\n          nonce: this._initNonce\n        }\n      });\n      this._init = InitState.SENT_NONCE; // NOTE: the promise will resolve in the _initCallback method\n      // which will be called from either handleMessage or the initTimeout\n    });\n  }\n\n}\n\nclass ProxyMessageChannel {\n  constructor() {\n    this.app = void 0;\n    this.wallet = void 0;\n    const port1 = new ProxyMessageChannelPort();\n    const port2 = new ProxyMessageChannelPort();\n    port1.conn = port2;\n    port2.conn = port1;\n    this.app = port1;\n    this.wallet = port2;\n  }\n\n}\n\nclass ProxyMessageChannelPort {\n  constructor() {\n    this.conn = void 0;\n    this.events = new EventEmitter2();\n\n    this.handleMessage = message => {\n      throw new Error('ProxyMessageChannelPort is not registered');\n    };\n\n    this.sendMessage = message => {\n      this.conn.handleMessage(message); // trigger events\n\n      if (message.type === 'open') {\n        this.events.emit('open', message);\n      }\n\n      if (message.type === 'close') {\n        this.events.emit('close', message);\n      }\n\n      if (message.type === 'connect') {\n        this.events.emit('connect', message);\n      }\n\n      if (message.type === 'disconnect') {\n        this.events.emit('disconnect', message);\n      }\n    };\n  }\n\n  on(event, fn) {\n    this.events.on(event, fn);\n  }\n\n  once(event, fn) {\n    this.events.once(event, fn);\n  }\n\n}\n\nclass ProxyMessageProvider extends BaseProviderTransport {\n  constructor(port) {\n    var _this3;\n\n    super();\n    _this3 = this;\n    this.port = void 0;\n\n    this.register = () => {\n      this.port.handleMessage = message => {\n        this.handleMessage(message);\n      };\n\n      this.on('open', function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        _this3.port.events.emit('open', ...args);\n      });\n      this.on('close', function () {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        _this3.port.events.emit('close', ...args);\n      });\n      this.on('connect', function () {\n        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n\n        _this3.port.events.emit('connect', ...args);\n      });\n      this.on('disconnect', function () {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n\n        _this3.port.events.emit('disconnect', ...args);\n      });\n      this._registered = true;\n    };\n\n    this.unregister = () => {\n      this._registered = false;\n      this.closeWallet();\n      this.events.removeAllListeners(); // @ts-ignore\n\n      this.port.handleMessage = undefined;\n    };\n\n    this.openWallet = (path, intent, networkId) => {\n      if (this.state === OpenState.CLOSED) {\n        this.state = OpenState.OPENING;\n        const sessionId = `${performance.now()}`;\n        this._sessionId = sessionId;\n        this.sendMessage({\n          idx: -1,\n          type: EventType.OPEN,\n          data: {\n            path,\n            intent,\n            networkId,\n            sessionId\n          }\n        });\n      }\n    };\n\n    this.state = OpenState.CLOSED;\n    this.port = port;\n\n    if (!port) {\n      throw new Error('port argument cannot be empty');\n    } // disable init handshake for proxy-transport, we set it to OK, to\n    // consider it in completed state.\n\n\n    this._init = InitState.OK;\n  }\n\n  closeWallet() {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CLOSE,\n      data: null\n    });\n    this.close();\n  }\n\n  sendMessage(message) {\n    if (!message.idx) {\n      throw new Error('message idx is empty');\n    }\n\n    this.port.sendMessage(message);\n  }\n\n}\n\nclass ProxyMessageHandler extends BaseWalletTransport {\n  constructor(walletRequestHandler, port) {\n    super(walletRequestHandler);\n    this.port = void 0;\n    this.port = port;\n    this._init = InitState.OK;\n  }\n\n  register() {\n    this.port.handleMessage = message => {\n      this.handleMessage(message);\n    };\n\n    this._registered = true;\n  } // note: we can't decide whether to restore the session within register(), because session info is\n  // received asyncronously via EventType.OPEN after register() is executed.\n  // And in the case of a redirect/reload, EventType.OPEN is not sent at all,\n  // because the wallet is already open.\n  //\n  // call this method from wallet redirect hander when a session restore is needed\n\n\n  async restoreSession() {\n    const cachedSession = await this.getCachedTransportSession();\n\n    if (cachedSession) {\n      this.open(cachedSession);\n    }\n  }\n\n  unregister() {\n    // @ts-ignore\n    this.port.handleMessage = undefined;\n    this._registered = false;\n  }\n\n  sendMessage(message) {\n    this.port.sendMessage(message);\n  }\n\n}\n\nclass MuxMessageProvider {\n  constructor() {\n    var _this = this;\n\n    this.messageProviders = void 0;\n    this.provider = void 0;\n\n    this.register = () => {\n      if (this.messageProviders.length === 1) {\n        this.provider = this.messageProviders[0];\n        this.provider.register();\n        return;\n      } // REVIEW/NOTE: ........ this method does not work for the chrome-extension. The issue becomes\n      // when the browser quits or restarts, the \"open\" event is never triggered. Perhaps the code here is fine,\n      // or maybe its not. What should happen is when a dapp makes a request, it will call openWallet\n      // below, in which case one of the events will register. So perhaps this is fine.\n\n\n      this.messageProviders.forEach(m => {\n        m.register();\n        m.once('open', () => {\n          // the first one to open is the winner, and others will be unregistered\n          if (!this.provider) {\n            this.provider = m; // unregister other providers\n\n            this.messageProviders.forEach(m => {\n              if (this.provider !== m) {\n                m.unregister();\n              }\n            });\n          }\n        });\n      });\n    };\n\n    this.unregister = () => {\n      this.messageProviders.forEach(m => m.unregister());\n      this.provider = undefined;\n    };\n\n    this.openWallet = (path, intent, networkId) => {\n      if (this.provider) {\n        this.provider.openWallet(path, intent, networkId);\n        return;\n      }\n\n      this.messageProviders.forEach(m => m.openWallet(path, intent, networkId));\n    };\n\n    this.sendAsync = async function (request, callback, chainId) {\n      if (_this.provider) {\n        _this.provider.sendAsync(request, callback, chainId);\n\n        return;\n      }\n\n      throw new Error('impossible state, wallet must be opened first');\n    };\n\n    this.sendMessageRequest = async function (message) {\n      if (_this.provider) {\n        return _this.provider.sendMessageRequest(message);\n      }\n\n      throw new Error('impossible state, wallet must be opened first');\n    };\n\n    this.waitUntilOpened = async function () {\n      if (_this.provider) {\n        return _this.provider.waitUntilOpened();\n      }\n\n      return Promise.race(_this.messageProviders.map(p => p.waitUntilOpened()));\n    };\n\n    this.waitUntilConnected = async function () {\n      if (_this.provider) {\n        return _this.provider.waitUntilConnected();\n      }\n\n      throw new Error('impossible state, wallet must be opened first');\n    };\n\n    for (var _len6 = arguments.length, messageProviders = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      messageProviders[_key6] = arguments[_key6];\n    }\n\n    this.messageProviders = messageProviders;\n    this.provider = undefined;\n  }\n\n  add() {\n    this.messageProviders.push(...arguments);\n  }\n\n  closeWallet() {\n    if (this.provider) {\n      this.provider.closeWallet();\n    }\n  }\n\n  isOpened() {\n    if (this.provider) {\n      return this.provider.isOpened();\n    }\n\n    return false;\n  }\n\n  isConnected() {\n    if (this.provider) {\n      return this.provider.isConnected();\n    }\n\n    return false;\n  }\n\n  on(event, fn) {\n    if (this.provider) {\n      this.provider.on(event, fn);\n      return;\n    }\n\n    this.messageProviders.forEach(m => {\n      m.on(event, fn);\n    });\n  }\n\n  once(event, fn) {\n    if (this.provider) {\n      this.provider.once(event, fn);\n      return;\n    }\n\n    this.messageProviders.forEach(m => {\n      m.once(event, fn);\n    });\n  }\n\n  emit(event) {\n    for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      args[_key7 - 1] = arguments[_key7];\n    }\n\n    if (this.provider) {\n      return this.provider.emit(event, ...args);\n    }\n\n    for (let i = 0; i < this.messageProviders.length; i++) {\n      this.messageProviders[i].emit(event, ...args);\n    }\n\n    return true;\n  }\n\n  sendMessage(message) {\n    if (!message.idx || message.idx <= 0) {\n      throw new Error('message idx is empty');\n    }\n\n    if (this.provider) {\n      this.provider.sendMessage(message);\n    } else {\n      throw new Error('impossible state, wallet must be opened first');\n    }\n  }\n\n  handleMessage(message) {\n    if (this.provider) {\n      this.provider.handleMessage(message);\n      return;\n    }\n\n    throw new Error('impossible state, wallet must be opened first');\n  }\n\n}\n\nlet registeredWindowMessageProvider;\n\nclass WindowMessageProvider extends BaseProviderTransport {\n  constructor(walletAppURL) {\n    super();\n    this.walletURL = void 0;\n    this.walletWindow = void 0;\n\n    this.register = () => {\n      if (registeredWindowMessageProvider) {\n        // overriding the registered message provider\n        registeredWindowMessageProvider.unregister();\n        registeredWindowMessageProvider = this;\n      } // listen for incoming messages from wallet\n\n\n      window.addEventListener('message', this.onWindowEvent);\n      registeredWindowMessageProvider = this; // open heartbeat\n\n      this.on('open', () => {\n        // Heartbeat to track if window closed\n        const popup = this.walletWindow;\n        const interval = setInterval(() => {\n          if (popup && popup.closed) {\n            clearInterval(interval);\n            this.close();\n          }\n        }, 500);\n      }); // close clean up\n\n      this.on('close', () => {\n        if (this.walletWindow) {\n          this.walletWindow.close();\n          this.walletWindow = null;\n        }\n      });\n      this._registered = true;\n    };\n\n    this.unregister = () => {\n      this._registered = false;\n      this.closeWallet(); // disable message listener\n\n      if (registeredWindowMessageProvider === this) {\n        registeredWindowMessageProvider = undefined;\n      }\n\n      window.removeEventListener('message', this.onWindowEvent); // clear event listeners\n\n      this.events.removeAllListeners();\n    };\n\n    this.openWallet = (path, intent, networkId) => {\n      if (this.walletWindow && this.isOpened()) {\n        // TODO: update the location of window to path\n        this.walletWindow.focus();\n        return;\n      } // Instantiate new walletURL for this call\n\n\n      const walletURL = new URL(this.walletURL.href);\n      const windowSessionParams = new WindowSessionParams();\n\n      if (path && path !== '') {\n        walletURL.pathname = path.toLowerCase();\n      } // Set session, intent and network id on walletURL\n\n\n      this._init = InitState.NIL;\n      this._sessionId = `${performance.now()}`;\n      windowSessionParams.set('sid', this._sessionId);\n\n      if (intent) {\n        // for the window-transport, we eagerly/optimistically set the origin host\n        // when connecting to the wallet, however, this will be verified and enforced\n        // on the wallet-side, so if a dapp provides the wrong origin, it will be dropped.\n        if (intent.type === 'connect') {\n          if (!intent.options) intent.options = {}; // skip setting origin host if we're in an browser extension execution context\n          // allow origin that is passed in\n\n          if (!isBrowserExtension()) {\n            intent.options.origin = window.location.origin;\n          }\n        } // encode intent as base64 url-encoded param\n\n\n        windowSessionParams.set('intent', base64EncodeObject(intent));\n      }\n\n      if (networkId) {\n        windowSessionParams.set('net', `${networkId}`);\n      } // Open popup window on center of the app window\n\n\n      let windowSize;\n      let windowPos;\n\n      if (isBrowserExtension()) {\n        windowSize = [450, 750];\n        windowPos = [Math.abs(window.screen.width / 2 - windowSize[0] / 2), Math.abs(window.screen.height / 2 - windowSize[1] / 2)];\n      } else {\n        windowSize = [450, 750];\n        windowPos = [Math.abs(window.screenX + window.innerWidth / 2 - windowSize[0] / 2), Math.abs(window.screenY + window.innerHeight / 2 - windowSize[1] / 2)];\n      }\n\n      const windowFeatures = `toolbar=0,location=0,menubar=0,scrollbars=yes,status=yes` + `,width=${windowSize[0]},height=${windowSize[1]}` + `,left=${windowPos[0]},top=${windowPos[1]}`; // serialize params\n\n      walletURL.search = windowSessionParams.toString();\n      this.walletWindow = window.open(walletURL.href, 'sequence.app', windowFeatures); // TODO: move this somewhere else\n      // TODO: perhaps we trigger a .on('openTimeout') event..? maybe.. could help.\n      // Popup blocking detection and notice\n      // let warned = false\n      // const warnPopupBlocked = () => {\n      //   if (warned) return\n      //   warned = true\n      //   // alert('popup is blocked! hey yo') // NOTE: for debug purposes only\n      //   throw new Error('popup is blocked')\n      // }\n      // const popupCheck = setTimeout(() => {\n      //   if (!popup || popup.closed || typeof popup.closed === 'undefined') {\n      //     // popup is definitely blocked if we reach here.\n      //     warnPopupBlocked()\n      //   }\n      // }, 1000)\n      // const popupBlocked = popup === null || popup === undefined\n      // if (popupBlocked) {\n      //   warnPopupBlocked()\n      //   return\n      // }\n    };\n\n    this.onWindowEvent = event => {\n      // Security check, ensure message is coming from wallet origin url\n      if (event.origin !== this.walletURL.origin) {\n        // Safetly can skip events not from the wallet\n        return;\n      }\n\n      let message;\n\n      try {\n        message = JSON.parse(event.data);\n      } catch (err) {\n        // event is not a ProviderMessage JSON object, skip\n        return;\n      }\n\n      if (!message) {\n        throw new Error('ProviderMessage object is empty');\n      } // handle message with base message provider\n\n\n      this.handleMessage(message);\n    };\n\n    this.walletURL = new URL(walletAppURL);\n  }\n\n  closeWallet() {\n    var _this$walletWindow;\n\n    this.close();\n    (_this$walletWindow = this.walletWindow) == null ? void 0 : _this$walletWindow.close();\n  } // onmessage, receives ProviderMessageResponse from the wallet post-message transport\n\n\n  sendMessage(message) {\n    if (!this.walletWindow) {\n      logger.warn('WindowMessageProvider: sendMessage failed as walletWindow is unavailable');\n      return;\n    }\n\n    const postedMessage = typeof message !== 'string' ? JSON.stringify(message) : message;\n    this.walletWindow.postMessage(postedMessage, this.walletURL.origin);\n  }\n\n}\n\nclass WindowMessageHandler extends BaseWalletTransport {\n  constructor(walletRequestHandler) {\n    var _this;\n\n    super(walletRequestHandler);\n    _this = this;\n    this.parentWindow = void 0;\n    this._isPopup = false;\n\n    this.onWindowEvent = async function (event) {\n      if (!event.origin || event.origin === '') {\n        // skip same-origin or when event.origin is empty/undefined\n        return;\n      }\n\n      if (_this.appOrigin && event.origin !== _this.appOrigin) {\n        // skip message as not from expected app origin\n        return;\n      } // Wallet always expects json-rpc request messages from a dapp\n\n\n      let request;\n\n      try {\n        request = JSON.parse(event.data);\n      } catch (err) {\n        // event is not a ProviderMessage JSON object, skip\n        return;\n      }\n\n      logger.debug('RECEIVED MESSAGE', request); // Record event origin for valid init ack\n\n      if (_this._init !== InitState.OK && _this.isValidInitAck(request)) {\n        _this.appOrigin = event.origin;\n      }\n\n      if (_this._init === InitState.OK && (!_this.appOrigin || _this.appOrigin.length < 8)) {\n        // impossible state\n        logger.error('impossible state, init.OK and appOrigin required');\n        return;\n      } // Handle message via the base transport\n\n\n      _this.handleMessage(request);\n    };\n\n    this.getWindowTransportSession = windowParams => {\n      const params = new WindowSessionParams(windowParams);\n      return {\n        sessionId: params.get('sid'),\n        networkId: params.get('net'),\n        intent: base64DecodeObject(params.get('intent'))\n      };\n    };\n\n    this._init = InitState.NIL;\n  }\n\n  async register(windowHref) {\n    const isPopup = parent.window.opener !== null;\n    this._isPopup = isPopup;\n\n    if (isPopup !== true) {\n      return;\n    } // record open details (sessionId + default network) from the window url\n\n\n    const {\n      pathname,\n      search: rawParams\n    } = new URL(windowHref || window.location.href);\n    let session = this.getWindowTransportSession(rawParams); // provider should always include sid when opening a new window\n\n    const isNewWindowSession = !!session.sessionId; // attempt to restore previous session in the case of a redirect or window reload\n\n    if (!isNewWindowSession) {\n      session = await this.getCachedTransportSession();\n    }\n\n    if (!session) {\n      logger.error('window session is undefined');\n      return;\n    } // record parent window instance for communication\n\n\n    this.parentWindow = parent.window.opener; // listen for window-transport requests\n\n    window.addEventListener('message', this.onWindowEvent, false);\n    this._registered = true; // send open event to the app which opened us\n\n    this.open(session).then(opened => {\n      if (!opened) {\n        var _session;\n\n        const err = `failed to open to network ${(_session = session) == null ? void 0 : _session.networkId}`;\n        logger.error(err);\n        this.notifyClose({\n          message: err\n        });\n        window.close();\n      }\n    }).catch(e => {\n      var _session2;\n\n      const err = `failed to open to network ${(_session2 = session) == null ? void 0 : _session2.networkId}, due to: ${e}`;\n      logger.error(err);\n      this.notifyClose({\n        message: err\n      });\n      window.close();\n    });\n  }\n\n  unregister() {\n    window.removeEventListener('message', this.onWindowEvent);\n    this._registered = false;\n  } // onmessage is called when (the wallet) receives request messages from the dapp\n  // over the window post-messaging transport\n  // postMessage sends message to the dapp window\n\n\n  sendMessage(message) {\n    // prepare payload\n    const payload = JSON.stringify(message); // post-message to app.\n    // only for init requests, we send to '*' origin\n\n    if (message.type === EventType.INIT) {\n      this.postMessage(payload, true);\n    } else {\n      this.postMessage(payload);\n    }\n  }\n\n  get isPopup() {\n    return this._isPopup;\n  }\n\n  postMessage(message) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (init !== true && this._init !== InitState.OK) {\n      logger.error('impossible state, should not be calling postMessage until inited');\n      return;\n    }\n\n    if (init) {\n      // init message transmission to global target -- for 'init' payloads only\n      this.parentWindow.postMessage(message, '*');\n    } else {\n      // open message transmission\n      if (this.appOrigin && this.appOrigin.length > 4) {\n        // just above '.com'\n        this.parentWindow.postMessage(message, this.appOrigin);\n      } else {\n        logger.error('unable to postMessage as parentOrigin is invalid');\n      }\n    }\n  }\n\n}\n\nconst CHANNEL_ID = 'sequence-extension-message-handler';\n\nclass ExtensionMessageHandler extends BaseWalletTransport {\n  constructor(walletRequestHandler, runtime) {\n    super(walletRequestHandler);\n    this.runtime = runtime;\n    this.port = void 0;\n    this._init = InitState.OK;\n  }\n\n  register() {\n    this._registered = true;\n    this.port = this.runtime.connect({\n      name: CHANNEL_ID\n    });\n  }\n\n  sendMessage(message) {\n    logger.info('[ExtensionMessageHandler send]', message);\n    this.port.postMessage(message);\n  }\n\n}\n\nclass ExtensionMessageProvider extends BaseProviderTransport {\n  constructor(runtime) {\n    super();\n\n    this.register = () => {\n      this._registered = true;\n    };\n\n    runtime.onConnect.addListener(port => {\n      if (port.name === CHANNEL_ID) {\n        this._init = InitState.OK;\n        port.onMessage.addListener(message => {\n          this.handleMessage(message);\n        });\n      }\n    });\n  }\n\n  sendMessage(message) {//noop\n  }\n\n  unregister() {//noop\n  }\n\n  openWallet(path, intent, networkId) {//noop\n  }\n\n  closeWallet() {//noop\n  }\n\n} // to be used on injected window.ethereum EIP1193 proxy\n\n\nclass BaseInjectedTransport extends EventEmitter2 {\n  constructor(stream) {\n    var _this;\n\n    super();\n    _this = this;\n    this.stream = stream;\n    this.responseCallbacks = new Map();\n    this._messageIdx = 0;\n\n    this.nextMessageIdx = () => ++this._messageIdx;\n\n    this.handleMessage = message => {\n      if (!message.type || !message.data) {\n        return;\n      }\n\n      logger.info('[received message]', message);\n      const requestIdx = message.idx;\n      const responseCallback = this.responseCallbacks.get(requestIdx);\n\n      if (requestIdx) {\n        this.responseCallbacks.delete(requestIdx);\n      }\n\n      switch (message.type) {\n        case EventType.MESSAGE:\n          if (responseCallback) {\n            this.emit(EventType.MESSAGE, message);\n            responseCallback(message.data.error, message);\n          } else {\n            // NOTE: this would occur if 'idx' isn't set, which should never happen\n            // or when we register two handler, or duplicate messages with the same idx are sent,\n            // all of which should be prevented prior to getting to this point\n            throw new Error('impossible state');\n          }\n\n          break;\n\n        case EventType.DISCONNECT:\n        case EventType.ACCOUNTS_CHANGED:\n        case EventType.CHAIN_CHANGED:\n          this.emit(message.type, message.data);\n          break;\n\n        default:\n          console.error('unknown message type', message);\n          break;\n      }\n    };\n\n    this.sendMessageRequest = async function (message) {\n      return new Promise((resolve, reject) => {\n        if (!message.idx || message.idx <= 0) {\n          reject(new Error('message idx not set'));\n        }\n\n        const responseCallback = (error, response) => {\n          if (error) {\n            reject(error);\n          } else if (response) {\n            resolve(response);\n          } else {\n            throw new Error('no valid response to return');\n          }\n        };\n\n        const {\n          idx\n        } = message;\n\n        if (!_this.responseCallbacks.get(idx)) {\n          _this.responseCallbacks.set(idx, responseCallback);\n        } else {\n          reject(new Error('duplicate message idx, should never happen'));\n        }\n\n        _this.sendMessage(message);\n      });\n    };\n\n    this.stream.on('data', this.handleMessage);\n  }\n\n  sendMessage(message) {\n    if (!this.stream.writable) {\n      console.error('window post message stream is not writable');\n    }\n\n    this.stream.write(message);\n  }\n\n}\n\nclass WalletUtils {\n  constructor(walletProvider) {\n    var _this = this;\n\n    this.wallet = void 0;\n\n    this.recoverWalletConfig = async function (address, digest, signature, chainId, walletContext) {\n      walletContext = walletContext || (await _this.wallet.getWalletContext());\n      return recoverWalletConfig(address, digest, signature, chainId, walletContext);\n    };\n\n    this.recoverWalletConfigFromMessage = async function (address, message, signature, chainId, walletContext) {\n      walletContext = walletContext || (await _this.wallet.getWalletContext());\n      return recoverWalletConfig(address, encodeMessageDigest(prefixEIP191Message(message)), signature, chainId, walletContext);\n    };\n\n    this.recoverWalletConfigFromTypedData = async function (address, typedData, signature, chainId, walletContext) {\n      walletContext = walletContext || (await _this.wallet.getWalletContext());\n      return recoverWalletConfig(address, encodeTypedDataDigest(typedData), signature, chainId, walletContext);\n    };\n\n    this.wallet = walletProvider;\n  } // Sign message on a specified chain, or DefaultChain by default\n\n\n  signMessage(message, chainId, allSigners) {\n    const signer = this.wallet.getSigner();\n    if (!signer) throw new Error('unable to get signer');\n    return signer.signMessage(message, chainId, allSigners);\n  } // Sign message on the AuthChain\n\n\n  async signAuthMessage(message, allSigners) {\n    const signer = await this.wallet.getAuthSigner();\n    if (!signer) throw new Error('unable to get AuthChain signer');\n    return signer.signMessage(message, await signer.getChainId(), allSigners);\n  } // Sign EIP-712 TypedData on a specified chain, or DefaultChain by default\n\n\n  signTypedData(domain, types, message, chainId, allSigners) {\n    const signer = this.wallet.getSigner();\n    if (!signer) throw new Error('unable to get signer');\n    return signer.signTypedData(domain, types, message, chainId, allSigners);\n  } // Sign EIP-712 TypedData on the AuthChain\n\n\n  async signAuthTypedData(domain, types, message, allSigners) {\n    const signer = await this.wallet.getAuthSigner();\n    if (!signer) throw new Error('unable to get AuthChain signer');\n    return signer.signTypedData(domain, types, message, await signer.getChainId(), allSigners);\n  } // Verify signature of a digest, one of a message, typedData or other\n\n\n  async isValidSignature(address, digest, signature, chainId, walletContext) {\n    const provider = this.wallet.getProvider(chainId);\n    if (!provider) throw new Error(`unable to get provider for chainId ${chainId}`);\n    return isValidSignature(address, digest, signature, provider, chainId, walletContext);\n  } // Verify message signature\n\n\n  async isValidMessageSignature(address, message, signature, chainId, walletContext) {\n    const provider = this.wallet.getProvider(chainId);\n    if (!provider) throw new Error(`unable to get provider for chainId ${chainId}`);\n    const prefixed = prefixEIP191Message(message);\n    const digest = encodeMessageDigest(prefixed);\n    return isValidSignature(address, digest, signature, provider, chainId, walletContext);\n  } // Verify typedData signature\n\n\n  isValidTypedDataSignature(address, typedData, signature, chainId, walletContext) {\n    return this.isValidSignature(address, encodeTypedDataDigest(typedData), signature, chainId, walletContext);\n  } // Recover the WalletConfig from a signature + digest combo\n  // sendTransaction()\n  // sendTransactions()\n  // sendETH()\n  // sendToken()\n  // sendCoin() -- sugar for sendToken()\n  // sendCollectible() -- sugar for sendToken()\n  // callContract()\n  // transactionHistory()\n  // getReceipt()\n  // getLogs()\n  // // ..\n  // isWalletDeployed()\n  // deployWallet()\n  // validateSignature()\n  // recoverWalletConfig()\n  // recoverAddress()\n\n\n}\n\nclass Wallet {\n  constructor(_network, config) {\n    var _this = this;\n\n    this.utils = void 0;\n    this.config = void 0;\n    this.session = void 0;\n    this.connectedSites = void 0;\n    this.transport = void 0;\n    this.networks = void 0;\n    this.providers = void 0;\n\n    this.init = () => {\n      var _this$config$transpor, _this$config$transpor2, _this$config$transpor3, _this$config$transpor4, _this$config$transpor5, _this$config$transpor6;\n\n      if (this.transport.provider) {\n        // init must have already been called\n        return;\n      } // Setup provider\n\n\n      this.transport.messageProvider = new MuxMessageProvider(); // multiple message provider setup, first one to connect will be the main transport\n\n      if ((_this$config$transpor = this.config.transports) != null && (_this$config$transpor2 = _this$config$transpor.windowTransport) != null && _this$config$transpor2.enabled) {\n        this.transport.windowMessageProvider = new WindowMessageProvider(this.config.walletAppURL);\n        this.transport.messageProvider.add(this.transport.windowMessageProvider);\n      }\n\n      if ((_this$config$transpor3 = this.config.transports) != null && (_this$config$transpor4 = _this$config$transpor3.proxyTransport) != null && _this$config$transpor4.enabled) {\n        this.transport.proxyMessageProvider = new ProxyMessageProvider(this.config.transports.proxyTransport.appPort);\n        this.transport.messageProvider.add(this.transport.proxyMessageProvider);\n      }\n\n      if ((_this$config$transpor5 = this.config.transports) != null && (_this$config$transpor6 = _this$config$transpor5.extensionTransport) != null && _this$config$transpor6.enabled) {\n        this.transport.extensionMessageProvider = new ExtensionMessageProvider(this.config.transports.extensionTransport.runtime); // this.transport.extensionMessageProvider.register()\n\n        this.transport.messageProvider.add(this.transport.extensionMessageProvider); // NOTE/REVIEW: see note in mux-message-provider\n        //\n        // We don't add the extensionMessageProvider here because we don't send requests to it anyways, we seem to\n        // send all requests to the WindowMessageProvider anyways. By allowing it, if browser restarts, it will break\n        // the entire extension because messageProvider.provider will be undefined. So this is a hack to fix it.\n        //\n        // this.transport.messageProvider.add(this.transport.extensionMessageProvider)\n      }\n\n      this.transport.messageProvider.register(); // .....\n\n      this.transport.allowProvider = allowProviderMiddleware(request => {\n        if (request.method === 'sequence_setDefaultNetwork') return true;\n        const isConnected = this.isConnected();\n\n        if (!isConnected) {\n          throw new Error('Sequence: wallet not connected');\n        }\n\n        return isConnected;\n      }); // ...\n\n      this.transport.networkProvider = networkProviderMiddleware(request => {\n        // return stub chainId of 0 when not connected to any\n        if (!this.networks || this.networks.length === 0) return 0; // return the default chainId as we're connected\n\n        return this.networks.find(network => network.isDefaultChain).chainId;\n      }); // Provider proxy to support middleware stack of logging, caching and read-only rpc calls\n\n      this.transport.cachedProvider = new CachedProvider();\n      this.transport.cachedProvider.onUpdate(() => {\n        if (!this.session) this.session = {\n          providerCache: {}\n        };\n        this.session.providerCache = this.transport.cachedProvider.getCache();\n        this.saveSession(this.session);\n      }); // ..\n\n      this.transport.router = new JsonRpcRouter([loggingProviderMiddleware, this.transport.networkProvider, this.transport.allowProvider, exceptionProviderMiddleware, this.transport.cachedProvider], this.transport.messageProvider);\n      this.transport.provider = new Web3Provider(this.transport.router); // NOTE: we don't listen on 'connect' even here as we handle it within connect() method\n      // in more synchronous flow.\n      // below will update the wallet session object and persist it. In case the session\n      // is undefined, we consider the session to have been removed by the user, so we clear it.\n\n      this.transport.messageProvider.on('open', openInfo => {\n        const {\n          session\n        } = openInfo;\n\n        if (!session) {\n          if (this.session && this.session.accountAddress) {\n            // emit disconnect even if previously we had a session, and now we don't.\n            this.transport.messageProvider.emit('disconnect');\n          }\n\n          this.clearSession();\n        } else {\n          this.useSession(session, true);\n        }\n      }); // below will update the account upon wallet connect/disconnect - aka, login/logout.\n      // if an origin is provided, this operation should be performed only on that origin\n      // and shouldn't affect the session of the wallet.\n\n      this.transport.messageProvider.on('accountsChanged', (accounts, origin) => {\n        if (origin) {\n          if (accounts.length > 0) {\n            this.useSession({\n              accountAddress: accounts[0]\n            }, true);\n          }\n\n          return;\n        }\n\n        if (!accounts || accounts.length === 0 || accounts[0] === '') {\n          this.clearSession();\n        } else {\n          this.useSession({\n            accountAddress: accounts[0]\n          }, true);\n        }\n      }); // below will update the networks automatically when the wallet networks change\n\n      this.transport.messageProvider.on('networks', networks => {\n        this.useSession({\n          networks: networks\n        }, true);\n      }); // below will update the wallet context automatically\n\n      this.transport.messageProvider.on('walletContext', walletContext => {\n        this.useSession({\n          walletContext: walletContext\n        }, true);\n      });\n    };\n\n    this.loadSession = async function () {\n      const data = await LocalStorage.getInstance().getItem('@sequence.session');\n\n      if (!data || data === '') {\n        return undefined;\n      }\n\n      try {\n        const session = JSON.parse(data);\n\n        if (session) {\n          _this.useSession(session, false);\n        }\n\n        return session;\n      } catch (err) {\n        logger.warn('loadSession failed, unable to parse session payload from storage.');\n        return undefined;\n      }\n    };\n\n    this.connect = async function (options) {\n      if ((options == null ? void 0 : options.refresh) === true) {\n        _this.disconnect();\n      }\n\n      if (_this.isConnected() && (await _this.isSiteConnected(options == null ? void 0 : options.origin)) && !!_this.session && !(options != null && options.authorize) && !(options != null && options.askForEmail)) {\n        return {\n          connected: true,\n          session: _this.session,\n          chainId: ethers.utils.hexlify(await _this.getChainId())\n        };\n      }\n\n      if (options) {\n        if (options.authorize && (!options.app || options.app === '')) {\n          throw new Error(`connecting with 'authorize' option also requires 'app' to be set`);\n        }\n      }\n\n      await _this.openWallet(undefined, {\n        type: 'connect',\n        options\n      });\n      const connectDetails = await _this.transport.messageProvider.waitUntilConnected().catch(_ => {\n        return {\n          connected: false\n        };\n      });\n\n      if (connectDetails.connected) {\n        if (!!connectDetails.session) {\n          _this.useSession(connectDetails.session, true);\n\n          _this.addConnectedSite(options == null ? void 0 : options.origin);\n        } else {\n          throw new Error('impossible state, connect response is missing session');\n        }\n      }\n\n      return connectDetails;\n    };\n\n    this.authorize = async function (options) {\n      return _this.connect(_extends({}, options, {\n        authorize: true\n      }));\n    };\n\n    this.getSession = () => {\n      if (!this.isConnected()) {\n        return undefined;\n      }\n\n      return this.session;\n    };\n\n    this.getAddress = async function () {\n      if (!_this.isConnected()) {\n        throw new Error('connect first');\n      }\n\n      const session = _this.getSession();\n\n      return session.accountAddress;\n    };\n\n    this.getNetworks = async function (chainId) {\n      if (!_this.isConnected() || !_this.networks) {\n        throw new Error('connect first');\n      }\n\n      if (chainId) {\n        // filter list to just the specific chain requested\n        const network = findNetworkConfig(_this.networks, chainId);\n        return network ? [network] : [];\n      }\n\n      return _this.networks;\n    };\n\n    this.getChainId = async function () {\n      if (!_this.networks || _this.networks.length < 1) {\n        throw new Error('networks have not been set by session. connect first.');\n      }\n\n      const network = _this.networks.find(network => network.isDefaultChain);\n\n      if (!network) {\n        throw new Error('networks must have a default chain specified');\n      }\n\n      return network.chainId;\n    };\n\n    this.getAuthChainId = async function () {\n      if (!_this.networks || _this.networks.length < 1) {\n        throw new Error('networks have not been set by session. connect first.');\n      }\n\n      const network = _this.networks.find(network => network.isAuthChain);\n\n      if (!network) {\n        throw new Error('networks must have an auth chain specified');\n      }\n\n      return network.chainId;\n    };\n\n    this.openWallet = async function (path, intent, networkId) {\n      if ((intent == null ? void 0 : intent.type) !== 'connect' && !_this.isConnected()) {\n        throw new Error('connect first');\n      }\n\n      let currentNetworkId;\n\n      if (!_this.networks || _this.networks.length < 1) {\n        currentNetworkId = _this.config.defaultNetworkId;\n      } else {\n        currentNetworkId = await _this.getChainId();\n      }\n\n      _this.transport.messageProvider.openWallet(path, intent, networkId || currentNetworkId);\n\n      await _this.transport.messageProvider.waitUntilOpened();\n      return true;\n    };\n\n    this.closeWallet = () => {\n      this.transport.messageProvider.closeWallet();\n    };\n\n    this.saveSession = async function (session) {\n      logger.debug('wallet provider: saving session');\n      const data = JSON.stringify(session);\n      await LocalStorage.getInstance().setItem('@sequence.session', data);\n    };\n\n    this.useSession = async function (session) {\n      let autoSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (!_this.session) _this.session = {}; // setup wallet context\n\n      if (_this.config.walletContext) {\n        _this.session.walletContext = _this.config.walletContext;\n      } else if (session.walletContext) {\n        _this.session.walletContext = session.walletContext;\n      } // setup account\n\n\n      if (session.accountAddress) {\n        _this.useAccountAddress(session.accountAddress);\n      } // setup networks\n\n\n      if (session.networks) {\n        _this.useNetworks(session.networks);\n      } // setup provider cache\n\n\n      if (session.providerCache) {\n        _this.transport.cachedProvider.setCache(session.providerCache);\n      } // persist\n\n\n      if (autoSave) {\n        _this.saveSession(_this.session);\n      }\n    }; // config is a Partial, so that we may intersect it with the DefaultProviderConfig,\n    // which allows easy overriding and control of the config.\n\n\n    this.config = _extends({}, DefaultProviderConfig);\n\n    if (config) {\n      this.config = _extends({}, this.config, config);\n    }\n\n    if (_network) {\n      this.config.defaultNetworkId = _network;\n    } else if (!this.config.defaultNetworkId) {\n      this.config.defaultNetworkId = 'mainnet';\n    }\n\n    if (config != null && config.localStorage) {\n      LocalStorage.use(config.localStorage);\n    }\n\n    this.transport = {};\n    this.networks = [];\n    this.providers = {};\n    this.connectedSites = new LocalStore('@sequence.connectedSites', []);\n    this.utils = new WalletUtils(this);\n    this.init();\n  }\n\n  async addConnectedSite(origin) {\n    origin = origin || window.location.origin;\n    const connectedSites = await this.connectedSites.get();\n\n    if (connectedSites) {\n      if (connectedSites.includes(origin)) {\n        return;\n      }\n\n      this.connectedSites.set([...connectedSites, origin]);\n    } else {\n      this.connectedSites.set([origin]);\n    }\n  }\n\n  async removeConnectedSite(origin) {\n    const authorized = await this.connectedSites.get();\n\n    if (authorized) {\n      this.connectedSites.set(authorized.filter(domain => domain !== origin));\n    }\n  }\n\n  getConnectedSites() {\n    return this.connectedSites.get();\n  }\n\n  async isSiteConnected(origin) {\n    const authorized = await this.connectedSites.get();\n    return !!authorized && authorized.includes(origin || window.location.origin);\n  }\n\n  disconnect() {\n    if (this.isOpened()) {\n      this.closeWallet();\n    }\n\n    this.clearSession();\n  } // TODO: add switchNetwork(network: string | number) which will call wallet_switchEthereumChain\n  // and on successful response, will update the provider info here, etc.\n\n\n  getProviderConfig() {\n    return this.config;\n  }\n\n  isOpened() {\n    return this.transport.messageProvider.isOpened();\n  }\n\n  isConnected() {\n    return this.session !== undefined && this.session.networks !== undefined && this.session.networks.length > 0 && this.networks !== undefined && this.networks.length > 0 && !!this.session.accountAddress && this.session.accountAddress.startsWith('0x');\n  }\n\n  getProvider(chainId) {\n    // return the top-level provider message transport when chainId is unspecified\n    // and user has not logged in\n    if (!this.isConnected()) {\n      if (chainId) {\n        throw new Error(`session is empty. connect and try again.`);\n      } else {\n        return this.transport.provider;\n      }\n    }\n\n    let network = this.networks.find(network => network.isDefaultChain);\n\n    if (chainId) {\n      network = findNetworkConfig(this.networks, chainId);\n\n      if (!network) {\n        throw new Error(`network ${chainId} is not in the network list`);\n      }\n    } // return memoized network provider\n\n\n    if (this.providers[network.chainId]) {\n      return this.providers[network.chainId];\n    } // builder web3 provider stack\n\n\n    let provider; // network.provider may be set by the ProviderConfig override\n\n    const rpcProvider = network.provider ? network.provider : new JsonRpcProvider(network.rpcUrl, network.chainId);\n\n    if (network.isDefaultChain) {\n      // communicating with defaultChain will prioritize the wallet message transport\n      const router = new JsonRpcRouter([loggingProviderMiddleware, exceptionProviderMiddleware, new EagerProvider({\n        accountAddress: this.session.accountAddress,\n        walletContext: this.session.walletContext\n      }), new SigningProvider(this.transport.provider), this.transport.cachedProvider], new JsonRpcSender(rpcProvider));\n      provider = new Web3Provider(router, network.chainId);\n    } else {\n      // communicating with another chain will bind to that network, but will forward\n      // any signing-related requests to the wallet message transport\n      const router = new JsonRpcRouter([loggingProviderMiddleware, exceptionProviderMiddleware, new EagerProvider({\n        accountAddress: this.session.accountAddress,\n        walletContext: this.session.walletContext,\n        chainId: network.chainId\n      }), new SigningProvider(this.transport.provider), new CachedProvider(network.chainId)], new JsonRpcSender(rpcProvider));\n      provider = new Web3Provider(router, network.chainId);\n    }\n\n    this.providers[network.chainId] = provider;\n    return provider;\n  }\n\n  async getAuthProvider() {\n    return this.getProvider((await this.getAuthNetwork()).chainId);\n  }\n\n  async getAuthNetwork() {\n    return (await this.getNetworks()).find(n => n.isAuthChain);\n  }\n\n  getAllProviders() {\n    return this.providers;\n  }\n\n  getSigner(chainId) {\n    return this.getProvider(chainId).getSigner();\n  }\n\n  async getAuthSigner() {\n    return (await this.getAuthProvider()).getSigner();\n  }\n\n  getWalletConfig(chainId) {\n    return this.getSigner().getWalletConfig(chainId);\n  }\n\n  getWalletState(chainId) {\n    return this.getSigner().getWalletState(chainId);\n  }\n\n  getWalletContext() {\n    return this.getSigner().getWalletContext();\n  }\n\n  isDeployed(chainId) {\n    return this.getSigner(chainId).isDeployed();\n  }\n\n  on(event, fn) {\n    this.transport.messageProvider.on(event, fn);\n  }\n\n  once(event, fn) {\n    this.transport.messageProvider.once(event, fn);\n  }\n\n  useAccountAddress(accountAddress) {\n    if (!this.session) this.session = {};\n    this.session.accountAddress = ethers.utils.getAddress(accountAddress);\n  }\n\n  useNetworks(networks) {\n    // set networks in the session\n    if (!this.session) this.session = {}; // set networks on session object\n\n    this.session.networks = networks; // short-circuit if setting empty network list (aka logged out state)\n\n    if (!this.session.networks || this.session.networks.length === 0) {\n      return;\n    } // check if any custom network settings, otherwise return early\n\n\n    if (!this.config.networks && !this.config.networkRpcUrl) {\n      this.networks = networks;\n      return;\n    } // init networks\n\n\n    this.networks = networks; // combine custom network config with networks in the session\n\n    if (this.config.networks) {\n      this.networks = networks.map(n => _extends({}, n)); // copy\n\n      this.config.networks.forEach(n => {\n        const network = findNetworkConfig(this.networks, n.chainId || n.name);\n        if (!network) return;\n        updateNetworkConfig(n, network);\n      });\n      ensureValidNetworks(this.networks, true);\n    } // an extra override for convenience\n\n\n    if (this.config.networkRpcUrl) {\n      const network = this.networks.find(network => network.isDefaultChain);\n\n      if (network) {\n        network.rpcUrl = this.config.networkRpcUrl;\n      }\n    }\n  }\n\n  clearSession() {\n    var _this$transport$cache;\n\n    logger.debug('wallet provider: clearing session');\n    LocalStorage.getInstance().removeItem('@sequence.session');\n    this.session = undefined;\n    this.networks = [];\n    this.providers = {};\n    (_this$transport$cache = this.transport.cachedProvider) == null ? void 0 : _this$transport$cache.clearCache();\n  }\n\n}\n\nconst DefaultProviderConfig = {\n  walletAppURL: 'https://sequence.app',\n  // walletSessionURL: 'https://session.sequence.app',\n  transports: {\n    windowTransport: {\n      enabled: true\n    },\n    proxyTransport: {\n      enabled: false\n    }\n  }\n};\nlet walletInstance;\n\nconst initWallet = async (network, config) => {\n  if (walletInstance && walletInstance.isOpened()) {\n    walletInstance.closeWallet();\n  }\n\n  walletInstance = new Wallet(network, config);\n  await walletInstance.loadSession();\n  return walletInstance;\n};\n\nconst getWallet = () => {\n  if (!walletInstance) {\n    throw new Error('Wallet has not been initialized, call sequence.initWallet(network, config) first.');\n  }\n\n  return walletInstance;\n};\n\nexport { BaseInjectedTransport, BaseProviderTransport, BaseWalletTransport, CHANNEL_ID, DefaultProviderConfig, ErrSignedInRequired, EventType, ExtensionMessageHandler, ExtensionMessageProvider, InitState, LocalStorage, LocalStore, LocalWeb3Provider, MuxMessageProvider, OpenState, PROVIDER_OPEN_TIMEOUT, ProviderError, ProxyMessageChannel, ProxyMessageChannelPort, ProxyMessageHandler, ProxyMessageProvider, Wallet, WalletRequestHandler, Web3Provider, Web3Signer, WindowMessageHandler, WindowMessageProvider, WindowSessionParams, getWallet, initWallet, isBrowserExtension, isSequenceProvider, isValidMessageSignature, isValidSignature, isValidTypedDataSignature, isWalletUpToDate, messageToBytes, nextMessageIdx, prefixEIP191Message, recoverWalletConfig };","map":{"version":3,"names":["EventEmitter2","logger","shallowCopy","resolveProperties","encodeMessageDigest","encodeTypedDataDigest","packMessageData","sanitizeNumberString","sanitizeHost","sanitizeAlphanumeric","base64EncodeObject","base64DecodeObject","ethers","BigNumber","addressOf","isConfigEqual","Web3Provider","Web3Provider$1","JsonRpcProvider","JsonRpcSender","maybeChainId","allowProviderMiddleware","networkProviderMiddleware","CachedProvider","JsonRpcRouter","loggingProviderMiddleware","exceptionProviderMiddleware","findNetworkConfig","EagerProvider","SigningProvider","updateNetworkConfig","ensureValidNetworks","Signer","resolveArrayProperties","isValidSignature","isValidSignature$1","recoverConfig","isSignedTransactions","signAuthorization","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","WindowSessionParams","URLSearchParams","new","init","EventType","OpenState","InitState","ProviderError","Error","constructor","message","name","ErrSignedInRequired","PROVIDER_OPEN_TIMEOUT","_messageIdx","nextMessageIdx","BaseProviderTransport","_this","pendingMessageRequests","responseCallbacks","Map","state","confirmationOnly","events","openPayload","connectPayload","accountsChangedPayload","networksPayload","walletContextPayload","_sessionId","_init","_registered","sendAsync","request","callback","chainId","CLOSED","openWallet","undefined","type","method","isOpened","waitUntilOpened","response","sendMessageRequest","idx","MESSAGE","data","err","Promise","resolve","reject","responseCallback","error","get","set","debug","push","sendMessage","openTimeout","opened","race","_","timeout","setTimeout","clearTimeout","emit","code","_this$openPayload","session","once","openInfo","waitUntilConnected","connect","connectDetails","closeWallet","JSON","stringify","NIL","registered","register","unregister","path","intent","networkId","OPENED","isConnected","_this$openPayload2","accountAddress","networks","handleMessage","_this2","INIT","nonce","OK","sessionId","requestIdx","delete","OPEN","_message$data","_message$data2","_message$data3","close","splice","forEach","pendingMessageRequest","size","ACCOUNTS_CHANGED","accounts","utils","getAddress","origin","CHAIN_CHANGED","NETWORKS","WALLET_CONTEXT","CLOSE","CONNECT","DISCONNECT","on","event","fn","args","info","clear","SIGNER_READY_TIMEOUT","WalletRequestHandler","_signer","prompter","mainnetNetworks","testnetNetworks","signer","signerReadyCallbacks","_openIntent","_connectOptions","_defaultNetworkId","_chainId","promptConnect","options","promptConnectDetails","catch","connected","walletSession","jsonrpc","id","result","getSigner","permittedJsonRpcMethods","includes","provider","getProvider","send","walletAddress","blockTag","params","walletBalance","getBalance","toHexString","address","sig","prefixEIP191Message","signMessage","arrayify","promptResultForDeployment","handleConfirmWalletDeployPrompt","promptSignMessage","connectOptions","signingAddress","typedDataObject","typedData","parse","e","domain","types","signTypedData","transactionParams","txnHash","txnResponse","sendTransaction","hash","promptSendTransaction","transaction","sender","from","signTransactions","promptSignTransaction","txChainId","toNumber","tx","getRelayer","relay","tag","count","getTransactionCount","getBlockNumber","getBlock","getTransaction","transactionObject","contractAddress","getCode","estimateGas","gasPrice","getGasPrice","switchParams","ok","setDefaultNetwork","toString","getWalletContext","_chainId2","getWalletConfig","_chainId3","getWalletState","getNetworks","defaultNetworkId","providerResponse","isSignedIn","signerReady","signIn","setSigner","notifyConnect","keepWalletOpened","notifyClose","signOut","signerReset","hexlify","getChainId","authorize","authOptions","app","expiry","proof","warn","responseMessage","openIntent","setOpenIntent","setConnectOptions","notifyNetworks","setNetworks","defaultChainId","jsonRpcResponse","map","n","network","relayer","walletContext","_connectDetails$sessi","_connectDetails$sessi2","notifyDisconnect","defaultNetwork","find","isDefaultChain","notifyWalletContext","isUpToDate","isWalletUpToDate","promptResult","promptConfirmWalletDeploy","isPromptResultCorrect","isSequenceProvider","cand","_sender","_isSequenceProvider","_defaultChainId","Web3Signer","LocalWeb3Provider","walletRequestHandler","_address","_index","_context","_networks","_providers","signTransaction","currentChainId","getSender","getSigners","authChainId","isAuthChain","walletConfig","signers","s","allSigners","toUtf8Bytes","_TypedDataEncoder","getPayload","sendUncheckedTransaction","then","poll","_wrapTransaction","onceBlock","transactionHash","sendTransactionBatch","transactions","batch","v","wait","auxiliary","sendSignedTransactions","signedTxs","updateConfig","newConfig","config","publishConfig","isDeployed","walletCode","_legacySignMessage","_signTypedData","fromAddress","hexTx","hexlifyTransaction","connectUnchecked","unlock","password","allowedTransactionKeys","gasLimit","to","value","expiration","afterNonce","delegateCall","revertOnError","allowExtra","allowed","checkProperties","hexValue","a","eip191prefix","messageToBytes","isBytes","isHexString","messageBytes","concat","String","digest","_await$provider$getNe","getNetwork","isValidMessageSignature","signature","prefixed","isValidTypedDataSignature","recoverWalletConfig","subDigest","recoveredWalletAddress","isBrowserExtension","window","location","protocol","_walletState$find","walletState","walletStateForRequiredChain","deployed","authChain","authChainConfig","requiredChainConfig","LocalStorage","getInstance","_instance","getItem","localStorage","setItem","removeItem","use","instance","LocalStore","def","val","console","del","TRANSPORT_SESSION_LS_KEY","BaseWalletTransport","_initNonce","_initCallback","appOrigin","isValidInitAck","open","saveTransportSession","authorizeOptions","notifyOpen","getCachedTransportSession","notifyAccountsChanged","notifyChainChanged","chainIdHex","initTimeout","performance","now","SENT_NONCE","ProxyMessageChannel","wallet","port1","ProxyMessageChannelPort","port2","conn","ProxyMessageProvider","port","removeAllListeners","OPENING","ProxyMessageHandler","restoreSession","cachedSession","MuxMessageProvider","messageProviders","m","p","add","registeredWindowMessageProvider","WindowMessageProvider","walletAppURL","walletURL","walletWindow","addEventListener","onWindowEvent","popup","interval","setInterval","closed","clearInterval","removeEventListener","focus","URL","href","windowSessionParams","pathname","toLowerCase","windowSize","windowPos","Math","abs","screen","width","height","screenX","innerWidth","screenY","innerHeight","windowFeatures","search","_this$walletWindow","postedMessage","postMessage","WindowMessageHandler","parentWindow","_isPopup","getWindowTransportSession","windowParams","windowHref","isPopup","parent","opener","rawParams","isNewWindowSession","_session","_session2","payload","CHANNEL_ID","ExtensionMessageHandler","runtime","ExtensionMessageProvider","onConnect","addListener","onMessage","BaseInjectedTransport","stream","writable","write","WalletUtils","walletProvider","recoverWalletConfigFromMessage","recoverWalletConfigFromTypedData","signAuthMessage","getAuthSigner","signAuthTypedData","Wallet","_network","connectedSites","transport","providers","_this$config$transpor","_this$config$transpor2","_this$config$transpor3","_this$config$transpor4","_this$config$transpor5","_this$config$transpor6","messageProvider","transports","windowTransport","enabled","windowMessageProvider","proxyTransport","proxyMessageProvider","appPort","extensionTransport","extensionMessageProvider","allowProvider","networkProvider","cachedProvider","onUpdate","providerCache","getCache","saveSession","router","clearSession","useSession","loadSession","refresh","disconnect","isSiteConnected","askForEmail","addConnectedSite","getSession","getAuthChainId","currentNetworkId","autoSave","useAccountAddress","useNetworks","setCache","DefaultProviderConfig","removeConnectedSite","authorized","filter","getConnectedSites","getProviderConfig","startsWith","rpcProvider","rpcUrl","getAuthProvider","getAuthNetwork","getAllProviders","networkRpcUrl","_this$transport$cache","clearCache","walletInstance","initWallet","getWallet"],"sources":["C:/Users/rishi/contract-poc/ThriEstate/Brandvilla/node_modules/@0xsequence/provider/dist/0xsequence-provider.esm.js"],"sourcesContent":["import { EventEmitter2 } from 'eventemitter2';\nimport { logger, shallowCopy, resolveProperties, encodeMessageDigest, encodeTypedDataDigest, packMessageData, sanitizeNumberString, sanitizeHost, sanitizeAlphanumeric, base64EncodeObject, base64DecodeObject } from '@0xsequence/utils';\nimport { ethers, BigNumber } from 'ethers';\nimport { addressOf, isConfigEqual } from '@0xsequence/config';\nimport { Web3Provider as Web3Provider$1, JsonRpcProvider } from '@ethersproject/providers';\nimport { JsonRpcSender, maybeChainId, allowProviderMiddleware, networkProviderMiddleware, CachedProvider, JsonRpcRouter, loggingProviderMiddleware, exceptionProviderMiddleware, findNetworkConfig, EagerProvider, SigningProvider, updateNetworkConfig, ensureValidNetworks } from '@0xsequence/network';\nimport { Signer, resolveArrayProperties, isValidSignature as isValidSignature$1, recoverConfig } from '@0xsequence/wallet';\nimport { isSignedTransactions } from '@0xsequence/transactions';\nimport { signAuthorization } from '@0xsequence/auth';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n// ProviderMessageCallback is used to respond to ProviderMessage requests. The error\n// argument is for exceptions during the execution, and response is the response payload\n// which may contain the result or an error payload from the wallet.\nclass WindowSessionParams extends URLSearchParams {\n  static new(init) {\n    return new URLSearchParams(init);\n  }\n\n}\nlet EventType;\n\n(function (EventType) {\n  EventType[\"OPEN\"] = \"open\";\n  EventType[\"CLOSE\"] = \"close\";\n  EventType[\"MESSAGE\"] = \"message\";\n  EventType[\"CONNECT\"] = \"connect\";\n  EventType[\"DISCONNECT\"] = \"disconnect\";\n  EventType[\"ACCOUNTS_CHANGED\"] = \"accountsChanged\";\n  EventType[\"CHAIN_CHANGED\"] = \"chainChanged\";\n  EventType[\"NETWORKS\"] = \"networks\";\n  EventType[\"WALLET_CONTEXT\"] = \"walletContext\";\n  EventType[\"INIT\"] = \"init\";\n  EventType[\"DEBUG\"] = \"_debug\";\n})(EventType || (EventType = {}));\n\nlet OpenState;\n\n(function (OpenState) {\n  OpenState[OpenState[\"CLOSED\"] = 0] = \"CLOSED\";\n  OpenState[OpenState[\"OPENING\"] = 1] = \"OPENING\";\n  OpenState[OpenState[\"OPENED\"] = 2] = \"OPENED\";\n})(OpenState || (OpenState = {}));\n\nlet InitState;\n\n(function (InitState) {\n  InitState[InitState[\"NIL\"] = 0] = \"NIL\";\n  InitState[InitState[\"SENT_NONCE\"] = 1] = \"SENT_NONCE\";\n  InitState[InitState[\"OK\"] = 2] = \"OK\";\n})(InitState || (InitState = {}));\n\nclass ProviderError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ProviderError';\n  }\n\n}\nconst ErrSignedInRequired = new ProviderError('Wallet is not signed in. Connect a wallet and try again.'); // TODO: lets build some nice error handling tools, prob in /utils ...\n\nconst PROVIDER_OPEN_TIMEOUT = 30000; // in ms\n\nlet _messageIdx = 0;\nconst nextMessageIdx = () => ++_messageIdx;\nclass BaseProviderTransport {\n  constructor() {\n    var _this = this;\n\n    this.pendingMessageRequests = [];\n    this.responseCallbacks = new Map();\n    this.state = void 0;\n    this.confirmationOnly = false;\n    this.events = new EventEmitter2();\n    this.openPayload = void 0;\n    this.connectPayload = void 0;\n    this.accountsChangedPayload = void 0;\n    this.networksPayload = void 0;\n    this.walletContextPayload = void 0;\n    this._sessionId = void 0;\n    this._init = void 0;\n    this._registered = void 0;\n\n    this.sendAsync = async function (request, callback, chainId) {\n      // here, we receive the message from the dapp provider call\n      if (_this.state === OpenState.CLOSED) {\n        // flag the wallet to auto-close once user submits input. ie.\n        // prompting to sign a message or transaction\n        _this.confirmationOnly = true;\n      } // open/focus the wallet.\n      // automatically open the wallet when a provider request makes it here.\n      //\n      // NOTE: if we're not signed in, then the provider will fail, users must first connect+sign in.\n      //\n      // TODO: how does this behave with a session has expired?\n\n\n      _this.openWallet(undefined, {\n        type: 'jsonRpcRequest',\n        method: request.method\n      }, chainId); // send message request, await, and then execute callback after receiving the response\n\n\n      try {\n        if (!_this.isOpened()) {\n          await _this.waitUntilOpened(); // will throw on timeout\n        }\n\n        const response = await _this.sendMessageRequest({\n          idx: nextMessageIdx(),\n          type: EventType.MESSAGE,\n          data: request,\n          chainId: chainId\n        });\n        callback(undefined, response.data);\n      } catch (err) {\n        callback(err);\n      }\n    };\n\n    this.sendMessageRequest = async function (message) {\n      return new Promise((resolve, reject) => {\n        if ((!message.idx || message.idx <= 0) && message.type !== 'init') {\n          reject(new Error('message idx not set'));\n        }\n\n        const responseCallback = (error, response) => {\n          if (error) {\n            reject(error);\n          } else if (response) {\n            resolve(response);\n          } else {\n            throw new Error('no valid response to return');\n          }\n        };\n\n        const idx = message.idx;\n\n        if (!_this.responseCallbacks.get(idx)) {\n          _this.responseCallbacks.set(idx, responseCallback);\n        } else {\n          reject(new Error('duplicate message idx, should never happen'));\n        }\n\n        if (!_this.isOpened()) {\n          logger.debug('pushing to pending requests', message);\n\n          _this.pendingMessageRequests.push(message);\n        } else {\n          _this.sendMessage(message);\n        }\n      });\n    };\n\n    this.waitUntilOpened = async function (openTimeout = PROVIDER_OPEN_TIMEOUT) {\n      let opened = false;\n      return Promise.race([new Promise((_, reject) => {\n        const timeout = setTimeout(() => {\n          clearTimeout(timeout); // only emit close if the timeout wins the race\n\n          if (!opened) {\n            _this.state = OpenState.CLOSED;\n\n            _this.events.emit('close', {\n              code: 1005,\n              message: 'opening wallet timed out'\n            });\n          }\n\n          reject(new Error('opening wallet timed out'));\n        }, openTimeout);\n      }), new Promise(resolve => {\n        if (_this.isOpened()) {\n          var _this$openPayload;\n\n          opened = true;\n          resolve((_this$openPayload = _this.openPayload) == null ? void 0 : _this$openPayload.session);\n          return;\n        }\n\n        _this.events.once('open', openInfo => {\n          _this.openPayload = openInfo;\n          opened = true;\n          resolve(openInfo.session);\n        });\n      })]);\n    };\n\n    this.waitUntilConnected = async function () {\n      await _this.waitUntilOpened();\n      const connect = new Promise(resolve => {\n        if (_this.connectPayload) {\n          resolve(_this.connectPayload);\n          return;\n        }\n\n        _this.events.once('connect', connectDetails => {\n          _this.connectPayload = connectDetails;\n          resolve(connectDetails);\n        });\n      });\n      const closeWallet = new Promise((_, reject) => {\n        _this.events.once('close', error => {\n          if (error) {\n            reject(new Error(`wallet closed due to ${JSON.stringify(error)}`));\n          } else {\n            reject(new Error(`user closed the wallet`));\n          }\n        });\n      });\n      return Promise.race([connect, closeWallet]);\n    };\n\n    this.state = OpenState.CLOSED;\n    this._registered = false;\n    this._init = InitState.NIL;\n  }\n\n  get registered() {\n    return this._registered;\n  }\n\n  register() {\n    throw new Error('abstract method');\n  }\n\n  unregister() {\n    throw new Error('abstract method');\n  }\n\n  openWallet(path, intent, networkId) {\n    throw new Error('abstract method');\n  }\n\n  closeWallet() {\n    throw new Error('abstract method');\n  }\n\n  isOpened() {\n    return this.registered && this.state === OpenState.OPENED;\n  }\n\n  isConnected() {\n    var _this$openPayload2;\n\n    // if we're registered, and we have the account details, then we are connected\n    const session = (_this$openPayload2 = this.openPayload) == null ? void 0 : _this$openPayload2.session;\n    return this.registered && session !== undefined && !!session.accountAddress && session.accountAddress.length === 42 && !!session.networks && session.networks.length > 0;\n  }\n\n  // handleMessage will handle message received from the remote wallet\n  handleMessage(message) {\n    var _this2 = this;\n\n    // init incoming for initial handshake with transport.\n    // always respond to INIT messages, e.g. on popup window reload\n    if (message.type === EventType.INIT) {\n      logger.debug('MessageProvider, received INIT message', message);\n      const {\n        nonce\n      } = message.data;\n\n      if (!nonce || nonce.length == 0) {\n        logger.error('invalid init nonce');\n        return;\n      }\n\n      this._init = InitState.OK;\n      this.sendMessage({\n        idx: -1,\n        type: EventType.INIT,\n        data: {\n          sessionId: this._sessionId,\n          nonce: nonce\n        }\n      });\n    }\n\n    if (this._init !== InitState.OK) {\n      // if provider is not init'd, then we drop any received messages. the only\n      // message we will process is of event type 'init', as our acknowledgement\n      return;\n    } // message is either a notification, or its a ProviderMessageResponse\n\n\n    logger.debug('RECEIVED MESSAGE FROM WALLET', message.idx, message);\n    const requestIdx = message.idx;\n    const responseCallback = this.responseCallbacks.get(requestIdx);\n\n    if (requestIdx) {\n      this.responseCallbacks.delete(requestIdx);\n    } // OPEN response\n    //\n    // Flip opened flag, and flush the pending queue\n\n\n    if (message.type === EventType.OPEN && !this.isOpened()) {\n      var _message$data, _message$data2;\n\n      if (this._sessionId && this._sessionId !== ((_message$data = message.data) == null ? void 0 : _message$data.sessionId)) {\n        logger.debug('open event received from wallet, but does not match sessionId', this._sessionId);\n        return;\n      } // check if open error occured due to invalid defaultNetworkId\n\n\n      if ((_message$data2 = message.data) != null && _message$data2.error) {\n        var _message$data3;\n\n        const err = new Error(`opening wallet failed: received ${(_message$data3 = message.data) == null ? void 0 : _message$data3.error}`);\n        logger.error(err);\n        this.close();\n        throw err;\n      } // success!\n\n\n      this.state = OpenState.OPENED;\n      this.openPayload = message.data;\n      this.events.emit('open', this.openPayload); // flush pending requests when connected\n\n      if (this.pendingMessageRequests.length !== 0) {\n        const pendingMessageRequests = this.pendingMessageRequests.splice(0, this.pendingMessageRequests.length);\n        pendingMessageRequests.forEach(async function (pendingMessageRequest) {\n          _this2.sendMessage(pendingMessageRequest);\n        });\n      }\n\n      return;\n    } // MESSAGE resposne\n\n\n    if (message.type === EventType.MESSAGE) {\n      // Require user confirmation, bring up wallet to prompt for input then close\n      // TODO: perhaps apply technique like in multicall to queue messages within\n      // a period of time, then close the window if responseCallbacks is empty, this is better.\n      if (this.confirmationOnly) {\n        setTimeout(() => {\n          if (this.responseCallbacks.size === 0) {\n            this.closeWallet();\n          }\n        }, 500); // TODO: be smarter about timer as we're processing the response callbacks..\n      }\n\n      if (!responseCallback) {\n        // NOTE: this would occur if 'idx' isn't set, which should never happen\n        // or when we register two handler, or duplicate messages with the same idx are sent,\n        // all of which should be prevented prior to getting to this point\n        throw new Error('impossible state');\n      } // Callback to original caller\n\n\n      if (responseCallback) {\n        this.events.emit('message', message);\n        responseCallback(message.data.error, message);\n        return;\n      }\n    } // ACCOUNTS_CHANGED -- when a user logs in or out\n\n\n    if (message.type === EventType.ACCOUNTS_CHANGED) {\n      this.accountsChangedPayload = {\n        accounts: []\n      };\n\n      if (message.data && message.data.length > 0) {\n        this.accountsChangedPayload = {\n          accounts: [ethers.utils.getAddress(message.data[0])],\n          origin: message.origin\n        };\n        this.events.emit('accountsChanged', this.accountsChangedPayload.accounts, this.accountsChangedPayload.origin);\n      } else {\n        this.events.emit('accountsChanged', [], message.origin);\n      }\n\n      return;\n    } // CHAIN_CHANGED -- when a user changes their default chain\n\n\n    if (message.type === EventType.CHAIN_CHANGED) {\n      this.events.emit('chainChanged', message.data);\n      return;\n    } // NOTIFY NETWORKS -- when a user connects or logs in\n\n\n    if (message.type === EventType.NETWORKS) {\n      this.networksPayload = message.data;\n      this.events.emit('networks', this.networksPayload);\n      return;\n    } // NOTIFY WALLET_CONTEXT -- when a user connects or logs in\n\n\n    if (message.type === EventType.WALLET_CONTEXT) {\n      this.walletContextPayload = message.data;\n      this.events.emit('walletContext', this.walletContextPayload);\n      return;\n    } // NOTIFY CLOSE -- when wallet instructs to close\n\n\n    if (message.type === EventType.CLOSE) {\n      if (this.state !== OpenState.CLOSED) {\n        this.close(message.data);\n      }\n    } // NOTIFY CONNECT -- when wallet instructs we've connected\n\n\n    if (message.type === EventType.CONNECT) {\n      this.connectPayload = message.data;\n      this.events.emit('connect', this.connectPayload);\n    } // NOTIFY DISCONNECT -- when wallet instructs to disconnect\n\n\n    if (message.type === EventType.DISCONNECT) {\n      if (this.isConnected()) {\n        this.events.emit('disconnect', message.data);\n        this.close();\n      }\n    }\n  } // sendMessageRequest sends a ProviderMessageRequest over the wire to the wallet\n\n\n  sendMessage(message) {\n    throw new Error('abstract method');\n  }\n\n  on(event, fn) {\n    this.events.on(event, fn);\n  }\n\n  once(event, fn) {\n    this.events.once(event, fn);\n  }\n\n  emit(event, ...args) {\n    return this.events.emit(event, ...args);\n  }\n\n  close(error) {\n    if (this.state === OpenState.CLOSED) return;\n    this.state = OpenState.CLOSED;\n    this.confirmationOnly = false;\n    this._sessionId = undefined;\n    logger.info('closing wallet and flushing!'); // flush pending requests and return error to all callbacks\n\n    this.pendingMessageRequests.length = 0;\n    this.responseCallbacks.forEach(responseCallback => {\n      responseCallback(_extends({}, new Error('wallet closed'), {\n        code: 4001\n      }));\n    });\n    this.responseCallbacks.clear();\n    this.connectPayload = undefined;\n    this.openPayload = undefined;\n    this.accountsChangedPayload = undefined;\n    this.networksPayload = undefined;\n    this.walletContextPayload = undefined;\n    this.events.emit('close', error);\n  }\n\n}\n\nconst SIGNER_READY_TIMEOUT = 10000;\nclass WalletRequestHandler {\n  // signer interface of the wallet. A null value means there is no signer (ie. user not signed in). An undefined\n  // value means the signer state is unknown, usually meaning the wallet app is booting up and initializing. Of course\n  // a Signer value is the actually interface to a signed-in account\n  constructor(_signer, prompter, mainnetNetworks, testnetNetworks = []) {\n    var _this = this;\n\n    this.signer = void 0;\n    this.signerReadyCallbacks = [];\n    this.prompter = void 0;\n    this.mainnetNetworks = void 0;\n    this.testnetNetworks = void 0;\n    this._openIntent = void 0;\n    this._connectOptions = void 0;\n    this._defaultNetworkId = void 0;\n    this._chainId = void 0;\n    this.events = new EventEmitter2();\n\n    this.promptConnect = async function (options) {\n      if (!options && !_this._connectOptions) {\n        // this is an unexpected state and should not happen\n        throw new Error('prompter connect options are empty');\n      }\n\n      if (!_this.prompter) {\n        // if prompter is null, we'll auto connect\n        return _this.connect(options);\n      }\n\n      const promptConnectDetails = await _this.prompter.promptConnect(options || _this._connectOptions).catch(_ => {\n        return {\n          connected: false\n        };\n      });\n      const connectDetails = promptConnectDetails;\n\n      if (connectDetails.connected && !connectDetails.session) {\n        connectDetails.session = await _this.walletSession();\n      }\n\n      return promptConnectDetails;\n    };\n\n    this.sendAsync = async function (request, callback, chainId) {\n      const response = {\n        jsonrpc: '2.0',\n        id: request.id,\n        result: null\n      };\n      await _this.getSigner();\n\n      try {\n        // only allow public json rpc method to the provider when user is not logged in, aka signer is not set\n        if ((!_this.signer || _this.signer === null) && !permittedJsonRpcMethods.includes(request.method)) {\n          // throw new Error(`not logged in. ${request.method} is unavailable`)\n          throw ErrSignedInRequired;\n        } // wallet signer\n\n\n        const signer = _this.signer;\n        if (!signer) throw new Error('WalletRequestHandler: wallet signer is not configured'); // fetch the provider for the specific chain, or undefined will select defaultChain\n\n        const provider = await signer.getProvider(chainId);\n        if (!provider) throw new Error(`WalletRequestHandler: wallet provider is not configured for chainId ${chainId}`);\n\n        switch (request.method) {\n          case 'net_version':\n            {\n              const result = await provider.send('net_version', []);\n              response.result = result;\n              break;\n            }\n\n          case 'eth_chainId':\n            {\n              const result = await provider.send('eth_chainId', []);\n              response.result = result;\n              break;\n            }\n\n          case 'eth_accounts':\n            {\n              const walletAddress = await signer.getAddress();\n              response.result = [walletAddress];\n              break;\n            }\n\n          case 'eth_getBalance':\n            {\n              const [accountAddress, blockTag] = request.params;\n              const walletBalance = await provider.getBalance(accountAddress, blockTag);\n              response.result = walletBalance.toHexString();\n              break;\n            }\n\n          case 'personal_sign':\n          case 'eth_sign':\n            {\n              // note: message from json-rpc input is in hex format\n              let message; // there is a difference in the order of the params:\n              // personal_sign: [data, address]\n              // eth_sign: [address, data]\n\n              if (request.method === 'personal_sign') {\n                const [data, address] = request.params;\n                message = data;\n              } else {\n                const [address, data] = request.params;\n                message = data;\n              }\n\n              let sig = ''; // Message must be prefixed with \"\\x19Ethereum Signed Message:\\n\"\n              // as defined by EIP-191\n\n              message = prefixEIP191Message(message); // TODO:\n              // if (process.env.TEST_MODE === 'true' && this.prompter === null) {\n\n              if (_this.prompter === null) {\n                // prompter is null, so we'll sign from here\n                sig = await signer.signMessage(ethers.utils.arrayify(message), chainId);\n              } else {\n                const promptResultForDeployment = await _this.handleConfirmWalletDeployPrompt(_this.prompter, signer, chainId);\n\n                if (promptResultForDeployment) {\n                  sig = await _this.prompter.promptSignMessage({\n                    chainId: chainId,\n                    message\n                  }, _this.connectOptions);\n                }\n              }\n\n              if (sig && sig.length > 0) {\n                response.result = sig;\n              } else {\n                // The user has declined the request when value is null\n                throw new Error('declined by user');\n              }\n\n              break;\n            }\n\n          case 'eth_signTypedData':\n          case 'eth_signTypedData_v4':\n            {\n              // note: signingAddress from json-rpc input is in hex format, and typedDataObject\n              // should be an object, but in some instances may be double string encoded\n              const [signingAddress, typedDataObject] = request.params;\n              let typedData = undefined;\n\n              if (typeof typedDataObject === 'string') {\n                try {\n                  typedData = JSON.parse(typedDataObject);\n                } catch (e) {}\n              } else {\n                typedData = typedDataObject;\n              }\n\n              if (!typedData || !typedData.domain || !typedData.types || !typedData.message) {\n                throw new Error('invalid typedData object');\n              }\n\n              let sig = '';\n\n              if (_this.prompter === null) {\n                // prompter is null, so we'll sign from here\n                sig = await signer.signTypedData(typedData.domain, typedData.types, typedData.message, chainId);\n              } else {\n                const promptResultForDeployment = await _this.handleConfirmWalletDeployPrompt(_this.prompter, signer, chainId);\n\n                if (promptResultForDeployment) {\n                  sig = await _this.prompter.promptSignMessage({\n                    chainId: chainId,\n                    typedData: typedData\n                  }, _this.connectOptions);\n                }\n              }\n\n              if (sig && sig.length > 0) {\n                response.result = sig;\n              } else {\n                // The user has declined the request when value is null\n                throw new Error('declined by user');\n              }\n\n              break;\n            }\n\n          case 'eth_sendTransaction':\n            {\n              // https://eth.wiki/json-rpc/API#eth_sendtransaction\n              const [transactionParams] = request.params;\n              let txnHash = '';\n\n              if (_this.prompter === null) {\n                // prompter is null, so we'll send from here\n                const txnResponse = await signer.sendTransaction(transactionParams, chainId);\n                txnHash = txnResponse.hash;\n              } else {\n                // prompt user to provide the response\n                txnHash = await _this.prompter.promptSendTransaction(transactionParams, chainId, _this.connectOptions);\n              }\n\n              if (txnHash) {\n                response.result = txnHash;\n              } else {\n                // The user has declined the request when value is null\n                throw new Error('declined by user');\n              }\n\n              break;\n            }\n\n          case 'eth_signTransaction':\n            {\n              // https://eth.wiki/json-rpc/API#eth_signTransaction\n              const [transaction] = request.params;\n              const sender = ethers.utils.getAddress(transaction.from);\n\n              if (sender !== (await signer.getAddress())) {\n                throw new Error('sender address does not match wallet');\n              }\n\n              if (_this.prompter === null) {\n                // The eth_signTransaction method expects a `string` return value we instead return a `SignedTransactions` object,\n                // this can only be broadcasted using an RPC provider with support for signed Sequence transactions, like this one.\n                //\n                // TODO: verify serializing / transporting the SignedTransaction object works as expected, most likely however\n                // we will want to resolveProperties the bignumber values to hex strings\n                response.result = await signer.signTransactions(transaction, chainId);\n              } else {\n                response.result = await _this.prompter.promptSignTransaction(transaction, chainId, _this.connectOptions);\n              }\n\n              break;\n            }\n\n          case 'eth_sendRawTransaction':\n            {\n              // NOTE: we're not using a prompter here as the transaction is already signed\n              // and would have prompted the user upon signing.\n              // https://eth.wiki/json-rpc/API#eth_sendRawTransaction\n              if (isSignedTransactions(request.params[0])) {\n                const txChainId = BigNumber.from(request.params[0].chainId).toNumber();\n                const tx = await (await signer.getRelayer(txChainId)).relay(request.params[0]);\n                response.result = (await tx).hash;\n              } else {\n                const tx = await provider.sendTransaction(request.params[0]);\n                response.result = tx.hash;\n              }\n\n              break;\n            }\n\n          case 'eth_getTransactionCount':\n            {\n              const address = ethers.utils.getAddress(request.params[0]);\n              const tag = request.params[1];\n              const walletAddress = ethers.utils.getAddress(await signer.getAddress());\n\n              if (address === walletAddress) {\n                const count = await signer.getTransactionCount(tag);\n                response.result = ethers.BigNumber.from(count).toHexString();\n              } else {\n                const count = await provider.getTransactionCount(address, tag);\n                response.result = ethers.BigNumber.from(count).toHexString();\n              }\n\n              break;\n            }\n\n          case 'eth_blockNumber':\n            {\n              response.result = await provider.getBlockNumber();\n              break;\n            }\n\n          case 'eth_getBlockByNumber':\n            {\n              response.result = await provider.getBlock(request.params[0]\n              /* , jsonRpcRequest.params[1] */\n              );\n              break;\n            }\n\n          case 'eth_getBlockByHash':\n            {\n              response.result = await provider.getBlock(request.params[0]\n              /* , jsonRpcRequest.params[1] */\n              );\n              break;\n            }\n\n          case 'eth_getTransactionByHash':\n            {\n              response.result = await provider.getTransaction(request.params[0]);\n              break;\n            }\n\n          case 'eth_call':\n            {\n              const [transactionObject, blockTag] = request.params;\n              response.result = await provider.call(transactionObject, blockTag);\n              break;\n            }\n\n          case 'eth_getCode':\n            {\n              const [contractAddress, blockTag] = request.params;\n              response.result = await provider.getCode(contractAddress, blockTag);\n              break;\n            }\n\n          case 'eth_estimateGas':\n            {\n              const [transactionObject] = request.params;\n              response.result = await provider.estimateGas(transactionObject);\n              break;\n            }\n\n          case 'eth_gasPrice':\n            {\n              const gasPrice = await provider.getGasPrice();\n              response.result = gasPrice.toHexString();\n              break;\n            }\n\n          case 'wallet_switchEthereumChain':\n            {\n              const [switchParams] = request.params;\n\n              if (!switchParams.chainId || switchParams.chainId.length === 0) {\n                throw new Error('invalid chainId');\n              }\n\n              const _chainId = ethers.BigNumber.from(switchParams.chainId);\n\n              const ok = await _this.setDefaultNetwork(_chainId.toString(), true);\n\n              if (!ok) {\n                throw new Error(`unable to set chainId ${_chainId}`);\n              }\n\n              response.result = null; // success\n\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_getWalletContext':\n            {\n              response.result = await signer.getWalletContext();\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_getWalletConfig':\n            {\n              const [_chainId2] = request.params;\n              response.result = await signer.getWalletConfig(_chainId2);\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_getWalletState':\n            {\n              const [_chainId3] = request.params;\n              response.result = await signer.getWalletState(_chainId3);\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_getNetworks':\n            {\n              // NOTE: must ensure that the response result below returns clean serialized data, which is to omit\n              // the provider and relayer objects and only return the urls so can be reinstantiated on dapp side.\n              // This is handled by this.getNetworks() but noted here for future readers.\n              response.result = await _this.getNetworks(true);\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_updateConfig':\n            {\n              throw new Error('sequence_updateConfig method is not allowed from a dapp'); // NOTE: method is disabled as we don't need a dapp to request to update a config.\n              // However, if we ever want this, we can enable it but must also use the prompter\n              // for confirmation.\n              //\n              // const [newConfig] = request.params\n              // response.result = await signer.updateConfig(newConfig)\n\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_publishConfig':\n            {\n              throw new Error('sequence_publishConfig method is not allowed from a dapp');\n              break;\n            }\n          // relayer method\n\n          case 'sequence_estimateGasLimits':\n            {\n              // TODO\n              break;\n            }\n          // relayer method\n\n          case 'sequence_gasRefundOptions':\n            {\n              // TODO\n              break;\n            }\n          // relayer method\n\n          case 'sequence_getNonce':\n            {\n              // TODO\n              break;\n            }\n          // relayer method\n\n          case 'sequence_relay':\n            {\n              // TODO\n              break;\n            }\n          // set default network of wallet\n\n          case 'sequence_setDefaultNetwork':\n            {\n              const [defaultNetworkId] = request.params;\n\n              if (!defaultNetworkId) {\n                throw new Error('invalid request, method argument defaultNetworkId cannot be empty');\n              }\n\n              const ok = await _this.setDefaultNetwork(defaultNetworkId);\n\n              if (!ok) {\n                throw new Error(`unable to set default network ${defaultNetworkId}`);\n              }\n\n              response.result = await _this.getNetworks(true);\n              break;\n            }\n\n          default:\n            {\n              // NOTE: provider here will be chain-bound if chainId is provided\n              const providerResponse = await provider.send(request.method, request.params);\n              response.result = providerResponse;\n            }\n        }\n      } catch (err) {\n        logger.error(err); // See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md#rpc-errors\n\n        response.result = null;\n        response.error = _extends({}, new Error(err), {\n          code: 4001\n        });\n      }\n\n      callback(undefined, response);\n    };\n\n    this.isSignedIn = async function () {\n      await _this.signerReady();\n      return !!_this.signer;\n    };\n\n    this.getSigner = async function () {\n      await _this.signerReady();\n\n      if (_this.signer === undefined) {\n        throw new Error('signerReady failed resolve');\n      }\n\n      return _this.signer;\n    };\n\n    this.signer = _signer;\n    this.prompter = prompter;\n    this.mainnetNetworks = mainnetNetworks;\n    this.testnetNetworks = testnetNetworks;\n  }\n\n  async signIn(signer, options = {}) {\n    this.setSigner(signer);\n    const {\n      connect,\n      mainnetNetworks,\n      testnetNetworks,\n      defaultNetworkId\n    } = options;\n\n    if (mainnetNetworks && mainnetNetworks.length > 0) {\n      this.mainnetNetworks = mainnetNetworks;\n    }\n\n    if (testnetNetworks && testnetNetworks.length > 0) {\n      this.testnetNetworks = testnetNetworks;\n    }\n\n    if ((!this.mainnetNetworks || this.mainnetNetworks.length === 0) && (!this.testnetNetworks || this.testnetNetworks.length === 0)) {\n      throw new Error('signIn failed as network configuration is empty');\n    }\n\n    const networkId = defaultNetworkId || this._defaultNetworkId;\n\n    if (networkId) {\n      if (!(await this.setDefaultNetwork(networkId, false))) {\n        throw new Error(`WalletRequestHandler setup unable to set defaultNetworkId ${networkId}`);\n      }\n    } // Optionally, connect the dapp and wallet. In case connectOptions are provided, we will perform\n    // necessary auth request, and then notify the dapp of the 'connect' details.\n    //\n    // NOTE: if a user is signing into a dapp from a fresh state, and and auth request is made\n    // we don't trigger the promptConnect flow, as we consider the user just authenticated\n    // for this dapp, so its safe to authorize in the connect() method without the prompt.\n    //\n    // NOTE: signIn can optionally connect and notify dapp at this time for new signIn flows\n\n\n    if (connect) {\n      const connectOptions = this._connectOptions;\n      const connectDetails = await this.connect(connectOptions);\n      this.notifyConnect(connectDetails);\n\n      if (!connectOptions || connectOptions.keepWalletOpened !== true) {\n        this.notifyClose();\n      }\n    }\n  }\n\n  signOut() {\n    // signed out state\n    this.setSigner(null);\n  }\n\n  signerReset() {\n    // resetting signer puts the wallet in an uninitialized state, which requires the app to\n    // re-initiatize and set the signer either as \"null\" (ie. no signer) or \"Signer\" (ie. signed in).\n    this.signer = undefined;\n  }\n\n  signerReady(timeout = SIGNER_READY_TIMEOUT) {\n    return new Promise((resolve, reject) => {\n      if (this.signer !== undefined) {\n        resolve();\n      } else {\n        setTimeout(() => {\n          if (this.signer === undefined) {\n            this.signerReadyCallbacks = [];\n            reject(`signerReady timed out`);\n          }\n        }, timeout);\n        this.signerReadyCallbacks.push(resolve);\n      }\n    });\n  }\n\n  async connect(options) {\n    if (!this.signer) {\n      return {\n        connected: false,\n        chainId: '0x0',\n        error: 'unable to connect without signed in account'\n      };\n    }\n\n    const connectDetails = {\n      connected: true,\n      chainId: ethers.utils.hexlify(await this.getChainId())\n    };\n\n    if (options && options.authorize) {\n      // Perform ethauth eip712 request and construct the ConnectDetails response\n      // including the auth proof\n      const authOptions = {\n        app: options.app,\n        origin: options.origin,\n        expiry: options.expiry\n      }; // if (typeof(options.authorize) === 'object') {\n      //   authOptions = { ...authOptions, ...options.authorize }\n      // }\n\n      try {\n        connectDetails.proof = await signAuthorization(this.signer, authOptions);\n      } catch (err) {\n        logger.warn(`connect, signAuthorization failed for options: ${JSON.stringify(options)}, due to: ${err.message}`);\n        return {\n          connected: false,\n          chainId: '0x0',\n          error: `signAuthorization failed: ${err.message}`\n        };\n      }\n    } // Build session response for connect details\n\n\n    connectDetails.session = await this.walletSession();\n    return connectDetails;\n  }\n\n  // sendMessageRequest will unwrap the ProviderMessageRequest and send it to the JsonRpcHandler\n  // (aka, the signer in this instance) and then responds with a wrapped response of\n  // ProviderMessageResponse to be sent over the transport\n  sendMessageRequest(message) {\n    return new Promise(resolve => {\n      this.sendAsync(message.data, (error, response) => {\n        // TODO: if response includes data.error, why do we need a separate error argument here?\n        const responseMessage = _extends({}, message, {\n          data: response\n        }); // NOTE: we always resolve here, are the sendAsync call will wrap any exceptions\n        // in the error field of the response to ensure we send back to the user\n\n\n        resolve(responseMessage);\n      }, message.chainId);\n    });\n  } // sendAsync implements the JsonRpcHandler interface for sending JsonRpcRequests to the wallet\n\n\n  on(event, fn) {\n    this.events.on(event, fn);\n  }\n\n  once(event, fn) {\n    this.events.once(event, fn);\n  }\n\n  async getAddress() {\n    if (!this.signer) {\n      return '';\n    } else {\n      return this.signer.getAddress();\n    }\n  }\n\n  async getChainId() {\n    if (!this.signer) {\n      return 0;\n    } else {\n      if (this._chainId) return this._chainId; // memoized\n\n      this._chainId = await this.signer.getChainId();\n      return this._chainId;\n    }\n  }\n\n  get openIntent() {\n    return this._openIntent;\n  }\n\n  setOpenIntent(intent) {\n    this._openIntent = intent;\n  }\n\n  get connectOptions() {\n    return this._connectOptions;\n  }\n\n  setConnectOptions(options) {\n    this._connectOptions = options;\n  }\n\n  get defaultNetworkId() {\n    return this._defaultNetworkId;\n  }\n\n  async setDefaultNetwork(chainId, notifyNetworks = true) {\n    if (!chainId) return undefined;\n    this._defaultNetworkId = chainId;\n    this._chainId = undefined;\n\n    if (this.signer && this.signer.setNetworks) {\n      const defaultChainId = this.signer.setNetworks(this.mainnetNetworks, this.testnetNetworks, chainId);\n\n      if (defaultChainId && notifyNetworks) {\n        await this.notifyNetworks();\n      }\n\n      return defaultChainId;\n    } else {\n      return undefined;\n    }\n  }\n\n  async getNetworks(jsonRpcResponse) {\n    if (!this.signer) {\n      logger.warn('signer not set: getNetworks is returning an empty list');\n      return [];\n    }\n\n    const networks = await this.signer.getNetworks();\n\n    if (jsonRpcResponse) {\n      // omit provider and relayer objects as they are not serializable\n      return networks.map(n => {\n        const network = _extends({}, n);\n\n        network.provider = undefined;\n        network.relayer = undefined;\n        return network;\n      });\n    } else {\n      return networks;\n    }\n  }\n\n  async walletSession() {\n    return !this.signer ? undefined : {\n      walletContext: await this.signer.getWalletContext(),\n      accountAddress: await this.signer.getAddress(),\n      networks: await this.getNetworks(true)\n    };\n  }\n\n  notifyConnect(connectDetails, origin) {\n    var _connectDetails$sessi;\n\n    this.events.emit('connect', connectDetails);\n\n    if ((_connectDetails$sessi = connectDetails.session) != null && _connectDetails$sessi.accountAddress) {\n      var _connectDetails$sessi2;\n\n      this.events.emit('accountsChanged', [(_connectDetails$sessi2 = connectDetails.session) == null ? void 0 : _connectDetails$sessi2.accountAddress], origin);\n    }\n  }\n\n  notifyDisconnect(origin) {\n    this.events.emit('accountsChanged', [], origin);\n    this.events.emit('disconnect');\n  }\n\n  async notifyNetworks(networks) {\n    const n = networks || (await this.getNetworks(true));\n    this.events.emit('networks', n);\n\n    if (n.length > 0) {\n      const defaultNetwork = n.find(network => network.isDefaultChain);\n\n      if (defaultNetwork) {\n        this.events.emit('chainChanged', ethers.utils.hexlify(defaultNetwork.chainId));\n      }\n    } else {\n      this.events.emit('chainChanged', '0x0');\n    }\n  }\n\n  async notifyWalletContext() {\n    if (!this.signer) {\n      logger.warn('signer not set: skipping to notify wallet context');\n      return;\n    }\n\n    const walletContext = await this.signer.getWalletContext();\n    this.events.emit('walletContext', walletContext);\n  }\n\n  notifyClose(error) {\n    this.events.emit('close', error);\n  }\n\n  setSigner(signer) {\n    this.signer = signer;\n\n    if (signer !== undefined) {\n      for (let i = 0; i < this.signerReadyCallbacks.length; i++) {\n        this.signerReadyCallbacks[i]();\n      }\n\n      this.signerReadyCallbacks = [];\n    }\n  }\n\n  async handleConfirmWalletDeployPrompt(prompter, signer, chainId) {\n    // check if wallet is deployed and up to date, if not, prompt user to deploy\n    // if no chainId is provided, we'll assume the wallet is auth chain wallet and is up to date\n    if (!chainId) {\n      return true;\n    }\n\n    const isUpToDate = await isWalletUpToDate(signer, chainId);\n\n    if (isUpToDate) {\n      return true;\n    }\n\n    const promptResult = await prompter.promptConfirmWalletDeploy(chainId, this.connectOptions); // if client returned true, check again to make sure wallet is deployed and up to date\n\n    if (promptResult) {\n      const isPromptResultCorrect = await isWalletUpToDate(signer, chainId);\n\n      if (!isPromptResultCorrect) {\n        logger.error('WalletRequestHandler: result for promptConfirmWalletDeploy is not correct');\n        return false;\n      } else {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\nconst permittedJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_getBalance', 'eth_getTransactionCount', 'eth_blockNumber', 'eth_getBlockByNumber', 'eth_getBlockByHash', 'eth_getTransactionByHash', 'eth_getCode', 'eth_estimateGas', 'eth_gasPrice', 'sequence_getWalletContext', 'sequence_getNetworks', 'sequence_setDefaultNetwork'];\n\nclass Web3Provider extends Web3Provider$1 {\n  static isSequenceProvider(cand) {\n    return isSequenceProvider(cand);\n  }\n\n  constructor(provider, defaultChainId) {\n    const sender = new JsonRpcSender(provider, maybeChainId(defaultChainId));\n    provider = sender;\n    super(provider, 'any');\n    this._sender = void 0;\n    this._isSequenceProvider = void 0;\n    this._defaultChainId = void 0;\n    this._sender = sender;\n    this._isSequenceProvider = true;\n    this._defaultChainId = maybeChainId(defaultChainId);\n  }\n\n  sendAsync(request, callback, chainId) {\n    this._sender.sendAsync(request, callback, chainId);\n  }\n\n  send(method, params, chainId) {\n    return this._sender.send(method, params, chainId);\n  }\n\n  request(request) {\n    return this.send(request.method, request.params || [], request.chainId);\n  }\n\n  getSigner() {\n    return new Web3Signer(this, this._defaultChainId);\n  }\n\n  async getChainId() {\n    // TODO: is it safe to memoize this?\n    const result = await this.send('eth_chainId', []);\n    const chainId = ethers.BigNumber.from(result).toNumber();\n\n    if (this._defaultChainId && this._defaultChainId !== chainId) {\n      throw new Error(`provider chainId (${chainId}) does not match provider-bound chainId ${this._defaultChainId}`);\n    }\n\n    return chainId;\n  }\n\n}\nfunction isSequenceProvider(provider) {\n  const cand = provider;\n  return cand && cand.send !== undefined && cand._isSequenceProvider === true;\n}\nclass LocalWeb3Provider extends Web3Provider {\n  constructor(signer, networks) {\n    const walletRequestHandler = new WalletRequestHandler(signer, null, networks || []);\n    super(walletRequestHandler);\n  }\n\n}\nclass Web3Signer extends Signer {\n  constructor(provider, defaultChainId) {\n    super();\n    this.provider = void 0;\n    this.defaultChainId = void 0;\n    this._address = void 0;\n    this._index = void 0;\n    this._context = void 0;\n    this._networks = void 0;\n    this._providers = {};\n    this.provider = provider;\n    this.defaultChainId = defaultChainId;\n  } // memoized\n\n\n  //\n  // ethers AbstractSigner methods\n  //\n  async getAddress() {\n    if (this._address) return this._address;\n    const accounts = await this.provider.send('eth_accounts', []);\n    this._address = accounts[0];\n    this._index = 0;\n    return ethers.utils.getAddress(this._address);\n  }\n\n  signTransaction(transaction) {\n    // TODO .. since ethers isn't using this method, perhaps we will?\n    throw new Error('signTransaction is unsupported, use signTransactions instead');\n  }\n\n  connect(provider) {\n    throw new Error('unsupported: cannot alter JSON-RPC Signer connection');\n  } //\n  // Sequence Signer methods\n  //\n  // getProvider returns a Web3Provider instance for the current chain. Note that this method\n  // and signer is bound to a particular chain to prevent misuse. If you'd like a provider\n  // for a specific chain, try getSender(chainId), or wallet.getProvider(chainId).\n\n\n  async getProvider(chainId) {\n    if (chainId) {\n      const currentChainId = await this.getChainId();\n\n      if (currentChainId !== chainId) {\n        throw new Error(`signer is attempting to access chain ${chainId}, but is already bound to chain ${currentChainId}`);\n      }\n    }\n\n    return this.provider;\n  } // getSender returns a Web3Provider instance via the signer transport. Note: for our case\n  // the of sequence wallet, this will bring up the wallet window whenever using it, as the json-rpc\n  // requests are sent to the window transport. Therefore, for anything non-signing related\n  // you can write a higher-order JsonRpcRouter sender to route to the public provider endpoints\n  // as we do in the WalletProvider.\n  //\n  // This method is primarily utilized internally when routing requests to a particular chainId.\n\n\n  async getSender(chainId) {\n    if (!chainId || chainId && chainId === this.defaultChainId) {\n      return this.provider;\n    }\n\n    if (!this._providers[chainId]) {\n      this._providers[chainId] = new Web3Provider(new JsonRpcSender(this.provider, chainId), chainId);\n    }\n\n    return this._providers[chainId];\n  }\n\n  getRelayer(chainId) {\n    // TODO: JsonRpcRelayer ......? or, Web3Relayer.. or SequenceRelayer?\n    // sequence_estimateGasLimits\n    // sequence_gasRefundOptions\n    // sequence_getNonce\n    // sequence_relay\n    throw new Error('TODO');\n  }\n\n  async getWalletContext() {\n    if (!this._context) {\n      this._context = await this.provider.send('sequence_getWalletContext', []);\n    }\n\n    return this._context;\n  }\n\n  async getWalletConfig(chainId) {\n    return await this.provider.send('sequence_getWalletConfig', [maybeChainId(chainId)], maybeChainId(chainId) || this.defaultChainId);\n  }\n\n  async getWalletState(chainId) {\n    return await this.provider.send('sequence_getWalletState', [maybeChainId(chainId)], maybeChainId(chainId) || this.defaultChainId);\n  }\n\n  async getNetworks() {\n    if (!this._networks) {\n      this._networks = await this.provider.send('sequence_getNetworks', []);\n    }\n\n    return this._networks;\n  }\n\n  async getSigners() {\n    const networks = await this.getNetworks();\n    const authChainId = networks.find(n => n.isAuthChain);\n\n    if (!authChainId) {\n      throw new Error('authChainId could not be determined from network list');\n    }\n\n    const walletConfig = await this.getWalletConfig(authChainId);\n\n    if (!walletConfig || walletConfig.length === 0) {\n      throw new Error(`walletConfig returned zero results for authChainId {authChainId}`);\n    }\n\n    return walletConfig[0].signers.map(s => s.address);\n  } // signMessage matches implementation from ethers JsonRpcSigner for compatibility, but with\n  // multi-chain support.\n\n\n  async signMessage(message, chainId, allSigners) {\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);\n    const data = typeof message === 'string' ? ethers.utils.toUtf8Bytes(message) : message;\n    const address = await this.getAddress(); // NOTE: as of ethers v5.5, it switched to using personal_sign, see\n    // https://github.com/ethers-io/ethers.js/pull/1542 and see\n    // https://github.com/WalletConnect/walletconnect-docs/issues/32 for additional info.\n\n    return await provider.send('personal_sign', [ethers.utils.hexlify(data), address]);\n  } // signTypedData matches implementation from ethers JsonRpcSigner for compatibility, but with\n  // multi-chain support.\n\n\n  async signTypedData(domain, types, message, chainId, allSigners) {\n    // Populate any ENS names (in-place)\n    // const populated = await ethers.utils._TypedDataEncoder.resolveNames(domain, types, message, (name: string) => {\n    //   return this.provider.resolveName(name)\n    // })\n    return await this.provider.send('eth_signTypedData_v4', [await this.getAddress(), ethers.utils._TypedDataEncoder.getPayload(domain, types, message)], maybeChainId(chainId) || this.defaultChainId);\n  } // sendTransaction matches implementation from ethers JsonRpcSigner for compatibility, but with\n  // multi-chain support.\n\n\n  async sendTransaction(transaction, chainId, allSigners) {\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);\n    const tx = this.sendUncheckedTransaction(transaction, chainId).then(hash => {\n      return ethers.utils.poll(() => {\n        return provider.getTransaction(hash).then(tx => {\n          if (tx === null) {\n            return undefined;\n          }\n\n          return provider._wrapTransaction(tx, hash);\n        });\n      }, {\n        onceBlock: this.provider\n      }).catch(error => {\n        error.transactionHash = hash;\n        throw error;\n      });\n    }); // @ts-ignore\n\n    return tx;\n  } // sendTransactionBatch is a convenience method to call sendTransaction in a batch format, allowing you to\n  // send multiple transaction as a single payload and just one on-chain transaction.\n\n\n  async sendTransactionBatch(transactions, chainId, allSigners) {\n    const batch = await resolveArrayProperties(transactions);\n\n    if (!batch || batch.length === 0) {\n      throw new Error('cannot send empty batch');\n    } // sendTransactionBatch only accepts TransactionRequest, not TransactionResponses\n\n\n    if (batch.find(v => v.wait !== undefined && v.wait !== null)) {\n      throw new Error('transaction request expected for sendTransactionBatch, transaction response found');\n    }\n\n    const tx = _extends({}, batch[0]);\n\n    if (batch.length > 1) {\n      tx.auxiliary = batch.splice(1);\n    }\n\n    return this.sendTransaction(tx, chainId, allSigners);\n  }\n\n  signTransactions(transaction, chainId, allSigners) {\n    transaction = shallowCopy(transaction); // TODO: transaction argument..? make sure to resolve any properties and serialize property before sending over\n    // the wire.. see sendUncheckedTransaction and resolveProperties\n\n    return this.provider.send('eth_signTransaction', [transaction], maybeChainId(chainId) || this.defaultChainId);\n  }\n\n  sendSignedTransactions(signedTxs, chainId) {\n    // sequence_relay\n    throw new Error('TODO');\n  } // updateConfig..\n  // NOTE: this is not supported by the remote wallet by default.\n\n\n  async updateConfig(newConfig) {\n    // sequence_updateConfig\n    const [config, tx] = await this.provider.send('sequence_updateConfig', [newConfig], this.defaultChainId);\n\n    if (tx === null) {\n      return [config, undefined];\n    }\n\n    const provider = await this.getSender(this.defaultChainId);\n    return [config, provider._wrapTransaction(tx, tx.hash)];\n  } // publishConfig..\n  // NOTE: this is not supported by the remote wallet by default.\n\n\n  async publishConfig() {\n    const provider = await this.getSender(this.defaultChainId);\n    const tx = await provider.send('sequence_publishConfig', []);\n\n    if (tx === null) {\n      return undefined;\n    }\n\n    return provider._wrapTransaction(tx, tx.hash);\n  }\n\n  async isDeployed(chainId) {\n    const provider = await this.getSender(maybeChainId(chainId));\n    const walletCode = await provider.getCode(await this.getAddress());\n    return !!walletCode && walletCode !== '0x';\n  } //\n  // ethers JsonRpcSigner methods\n  //\n\n\n  async _legacySignMessage(message, chainId, allSigners) {\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);\n    const data = typeof message === 'string' ? ethers.utils.toUtf8Bytes(message) : message;\n    const address = await this.getAddress(); // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    // NOTE: ethers since 5.5 has switched to using personal_sign, we should review, etc.\n\n    return await provider.send('eth_sign', [address, ethers.utils.hexlify(data)]);\n  }\n\n  async _signTypedData(domain, types, message, chainId, allSigners) {\n    return this.signTypedData(domain, types, message, chainId, allSigners);\n  }\n\n  async sendUncheckedTransaction(transaction, chainId) {\n    transaction = shallowCopy(transaction);\n    const fromAddress = this.getAddress(); // NOTE: we do not use provider estimation, and instead rely on our relayer to determine the gasLimit and gasPrice\n    //\n    // TODO: alternatively/one day, we could write a provider middleware to eth_estimateGas\n    // and send it to our relayer url instead for estimation..\n    //\n    // if (!transaction.gasLimit) {\n    //   const estimate = shallowCopy(transaction)\n    //   estimate.from = fromAddress\n    //   transaction.gasLimit = this.provider.estimateGas(estimate)\n    // }\n\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);\n    return resolveProperties({\n      tx: resolveProperties(transaction),\n      sender: await fromAddress\n    }).then(({\n      tx,\n      sender\n    }) => {\n      if (tx.from != null) {\n        if (ethers.utils.getAddress(tx.from) !== sender) {\n          // logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction)\n          throw new Error(`from address mismatch for transaction ${transaction}`);\n        }\n      } else {\n        tx.from = sender;\n      }\n\n      const hexTx = hexlifyTransaction(tx);\n      return provider.send('eth_sendTransaction', [hexTx]).then(hash => {\n        return hash;\n      }, error => {\n        // return checkError(\"sendTransaction\", error, hexTx)\n        throw new Error(`sendTransaction ${error}`);\n      });\n    });\n  }\n\n  connectUnchecked() {\n    throw new Error('connectUnchecked is unsupported');\n  }\n\n  async unlock(password) {\n    const address = await this.getAddress();\n    return this.provider.send('personal_unlockAccount', [address, password, null]);\n  }\n\n} // NOTE: method has been copied + modified from ethers.js JsonRpcProvider\n// Convert an ethers.js transaction into a JSON-RPC transaction\n\nconst allowedTransactionKeys = {\n  chainId: true,\n  data: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  value: true,\n  from: true,\n  auxiliary: true,\n  expiration: true,\n  afterNonce: true,\n  delegateCall: true,\n  revertOnError: true\n};\n\nconst hexlifyTransaction = (transaction, allowExtra) => {\n  // Check only allowed properties are given\n  const allowed = shallowCopy(allowedTransactionKeys);\n\n  if (allowExtra) {\n    for (const key in allowExtra) {\n      if (allowExtra[key]) {\n        allowed[key] = true;\n      }\n    }\n  }\n\n  ethers.utils.checkProperties(transaction, allowed);\n  const result = {} // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n  ;\n  ['gasLimit', 'gasPrice', 'nonce', 'value'].forEach(key => {\n    if (!transaction[key]) {\n      return;\n    }\n\n    const value = ethers.utils.hexValue(transaction[key]);\n\n    if (key === 'gasLimit') {\n      key = 'gas';\n    }\n\n    result[key] = value;\n  });\n  ['from', 'to', 'data'].forEach(key => {\n    if (!transaction[key]) {\n      return;\n    }\n\n    result[key] = ethers.utils.hexlify(transaction[key]);\n  });\n  const auxiliary = transaction['auxiliary'];\n\n  if (auxiliary && auxiliary.length > 0) {\n    result['auxiliary'] = [];\n    auxiliary.forEach(a => {\n      result['auxiliary'].push(hexlifyTransaction(a));\n    });\n  }\n\n  return result;\n};\n\nconst eip191prefix = ethers.utils.toUtf8Bytes('\\x19Ethereum Signed Message:\\n');\nconst messageToBytes = message => {\n  if (ethers.utils.isBytes(message) || ethers.utils.isHexString(message)) {\n    return ethers.utils.arrayify(message);\n  }\n\n  return ethers.utils.toUtf8Bytes(message);\n};\nconst prefixEIP191Message = message => {\n  const messageBytes = messageToBytes(message);\n  return ethers.utils.concat([eip191prefix, ethers.utils.toUtf8Bytes(String(messageBytes.length)), messageBytes]);\n};\nconst isValidSignature = async (address, digest, sig, provider, chainId, walletContext) => {\n  if (!chainId) {\n    var _await$provider$getNe;\n\n    chainId = (_await$provider$getNe = await provider.getNetwork()) == null ? void 0 : _await$provider$getNe.chainId;\n  }\n\n  if (!walletContext && Web3Provider.isSequenceProvider(provider)) {\n    walletContext = await provider.getSigner().getWalletContext();\n  }\n\n  return isValidSignature$1(address, digest, sig, provider, walletContext, chainId);\n};\nconst isValidMessageSignature = async (address, message, signature, provider, chainId, walletContext) => {\n  const prefixed = prefixEIP191Message(message);\n  const digest = encodeMessageDigest(prefixed);\n  return isValidSignature(address, digest, signature, provider, chainId, walletContext);\n};\nconst isValidTypedDataSignature = (address, typedData, signature, provider, chainId, walletContext) => {\n  return isValidSignature(address, encodeTypedDataDigest(typedData), signature, provider, chainId, walletContext);\n};\nconst recoverWalletConfig = async (address, digest, signature, chainId, walletContext) => {\n  const subDigest = packMessageData(address, chainId, digest);\n  const config = await recoverConfig(subDigest, signature);\n\n  if (walletContext) {\n    const recoveredWalletAddress = addressOf(config, walletContext);\n\n    if (config.address && config.address !== recoveredWalletAddress) {\n      throw new Error('recovered address does not match the WalletConfig address, check the WalletContext');\n    } else {\n      config.address = recoveredWalletAddress;\n    }\n  }\n\n  return config;\n};\nconst isBrowserExtension = () => window.location.protocol === 'chrome-extension:' || window.location.protocol === 'moz-extension:';\n/**\n * Returns the status of a signer's wallet on given chain by checking wallet deployment and config status\n *\n * @param {Signer} signer\n * @param {number} chainId\n * @return {Promise<boolean>} Promise that returns true if the wallet is up to date, false otherwise\n */\n\nconst isWalletUpToDate = async (signer, chainId) => {\n  var _walletState$find;\n\n  const walletState = await signer.getWalletState();\n  const networks = await signer.getNetworks();\n  const walletStateForRequiredChain = walletState.find(state => state.chainId === chainId);\n\n  if (!walletStateForRequiredChain) {\n    throw new Error(`WalletRequestHandler: could not find wallet state for chainId ${chainId}`);\n  }\n\n  const isDeployed = walletStateForRequiredChain.deployed;\n\n  if (!networks) {\n    throw new Error(`isWalletUpToDate util: could not get networks from signer`);\n  }\n\n  const authChain = networks.find(network => network.isAuthChain);\n\n  if (!authChain) {\n    throw new Error(`isWalletUpToDate util: could not get auth chain network information`);\n  }\n\n  const authChainId = authChain.chainId;\n  const authChainConfig = (_walletState$find = walletState.find(state => state.chainId === authChainId)) == null ? void 0 : _walletState$find.config;\n\n  if (!authChainConfig) {\n    throw new Error(`isWalletUpToDate util: could not get auth chain config`);\n  }\n\n  const requiredChainConfig = walletStateForRequiredChain.config;\n\n  if (!requiredChainConfig) {\n    throw new Error(`isWalletUpToDate util: could not get config for chainId ${chainId}`);\n  }\n\n  const isUpToDate = isConfigEqual(authChainConfig, requiredChainConfig);\n  return isDeployed && isUpToDate;\n};\nclass LocalStorage {\n  constructor() {}\n\n  static getInstance() {\n    if (!LocalStorage._instance) {\n      LocalStorage._instance = {\n        getItem: key => Promise.resolve(window.localStorage.getItem(key)),\n        setItem: (key, value) => Promise.resolve(window.localStorage.setItem(key, value)),\n        removeItem: key => Promise.resolve(window.localStorage.removeItem(key))\n      };\n    }\n\n    return this._instance;\n  }\n\n  static use(instance) {\n    LocalStorage._instance = instance;\n  }\n\n} // window.localstorage helper\n\nLocalStorage._instance = void 0;\nclass LocalStore {\n  constructor(key, def) {\n    this.def = def;\n    this.key = void 0;\n    this.key = key;\n  }\n\n  async get() {\n    const val = await LocalStorage.getInstance().getItem(this.key);\n\n    if (val === null) {\n      return this.def;\n    }\n\n    try {\n      return JSON.parse(val);\n    } catch (err) {\n      console.error(err);\n    }\n\n    return;\n  }\n\n  set(val) {\n    val ? LocalStorage.getInstance().setItem(this.key, JSON.stringify(val)) : LocalStorage.getInstance().removeItem(this.key);\n  }\n\n  del() {\n    LocalStorage.getInstance().removeItem(this.key);\n  }\n\n}\n\nconst TRANSPORT_SESSION_LS_KEY = '@sequence.transportSession';\nclass BaseWalletTransport {\n  // appOrigin identifies the dapp's origin which opened the app. A transport\n  // will auto-detect and set this value if it can. This is determined\n  // as the parent app/window which opened the wallet.\n  constructor(walletRequestHandler) {\n    var _this = this;\n\n    this.walletRequestHandler = void 0;\n    this._sessionId = void 0;\n    this._registered = void 0;\n    this._init = void 0;\n    this._initNonce = void 0;\n    this._initCallback = void 0;\n    this.appOrigin = void 0;\n\n    this.sendAsync = async function (request, callback, chainId) {\n      throw new Error('abstract method');\n    };\n\n    this.handleMessage = async function (message) {\n      const request = message; // ensure initial handshake is complete before accepting\n      // other kinds of messages.\n\n      if (_this._init !== InitState.OK) {\n        if (request.type === EventType.INIT) {\n          if (_this.isValidInitAck(message)) {\n            // successful init\n            if (_this._initCallback) _this._initCallback();\n          } else {\n            // failed init\n            if (_this._initCallback) _this._initCallback('invalid init');\n            return;\n          }\n        }\n\n        return;\n      } // ensure signer is ready to handle requests\n      // if (this.walletRequestHandler.getSigner() === undefined) {\n      //   await this.walletRequestHandler.signerReady()\n      // }\n      // handle request\n\n\n      switch (request.type) {\n        case EventType.OPEN:\n          {\n            if (_this._init !== InitState.OK) return;\n            const session = {\n              sessionId: request.data.sessionId,\n              intent: request.data.intent,\n              networkId: request.data.networkId\n            };\n            await _this.open(session);\n            return;\n          }\n\n        case EventType.CLOSE:\n          {\n            if (_this._init !== InitState.OK) return; // noop. just here to capture the message so event emitters may be notified\n\n            return;\n          }\n\n        case EventType.MESSAGE:\n          {\n            const response = await _this.walletRequestHandler.sendMessageRequest(request);\n\n            _this.sendMessage(response);\n\n            if (response.data.error) ;\n\n            return;\n          }\n\n        default:\n          {\n            logger.error(`unexpected payload type ${request.type}`);\n          }\n      }\n    };\n\n    this.sendMessageRequest = async function (message) {\n      return _this.walletRequestHandler.sendMessageRequest(message);\n    };\n\n    this.open = async function ({\n      sessionId,\n      intent,\n      networkId\n    }) {\n      if (sessionId) {\n        _this._sessionId = sanitizeNumberString(sessionId); // persist transport session in localstorage for restoring after redirect/reload\n\n        _this.saveTransportSession({\n          sessionId,\n          intent,\n          networkId\n        });\n      }\n\n      _this.walletRequestHandler.setOpenIntent(intent); // init handshake for certain transports, before we can open the communication.\n      //\n      // for example, with the window-transport, we have to exchange messages to determine the\n      // origin host of the dapp.\n\n\n      await _this.init(); // Prepare connect options from intent\n\n      if (intent && intent.type === 'connect' && intent.options) {\n        const connectOptions = intent.options;\n        const authorizeOptions = connectOptions; // overlapping types\n        // Sanity/integrity check the intent payload, and set authorization origin\n        // if its been determined as part of the init handshake from earlier.\n\n        if (_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {\n          if (!isBrowserExtension()) {\n            if (authorizeOptions.origin !== _this.appOrigin) {\n              throw new Error('origin is invalid');\n            }\n          }\n        } else if (!_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {\n          // ie. when we can't determine the origin in our transport, but dapp provides it to us.\n          // we just sanitize the origin host.\n          connectOptions.origin = sanitizeHost(authorizeOptions.origin);\n        } else if (_this.appOrigin) {\n          // ie. when we auto-determine the origin such as in window-transport\n          connectOptions.origin = _this.appOrigin;\n        }\n\n        if (connectOptions.app) {\n          connectOptions.app = sanitizeAlphanumeric(connectOptions.app);\n        } // Set connect options on the walletRequestHandler as our primary\n        // wallet controller\n\n\n        _this.walletRequestHandler.setConnectOptions(connectOptions);\n\n        if (connectOptions.networkId) {\n          networkId = connectOptions.networkId;\n        }\n      } else {\n        _this.walletRequestHandler.setConnectOptions(undefined);\n      } // ensure signer is ready\n\n\n      await _this.walletRequestHandler.getSigner(); // Notify open and proceed to prompt for connection if intended\n\n      if (!(await _this.walletRequestHandler.isSignedIn())) {\n        // open wallet without a specific connected chainId, as the user is not signed in\n        _this.notifyOpen({\n          sessionId: _this._sessionId\n        });\n\n        return true;\n      } else {\n        // Set default network, in case of error chainId will be undefined or 0\n        let chainId = undefined;\n\n        try {\n          if (networkId) {\n            chainId = await _this.walletRequestHandler.setDefaultNetwork(networkId, false);\n          } else {\n            chainId = await _this.walletRequestHandler.getChainId();\n          }\n        } catch (err) {\n          console.error(err);\n        } // Failed to set default network on open -- quit + close\n\n\n        if (!chainId || chainId <= 0) {\n          _this.notifyOpen({\n            sessionId: _this._sessionId,\n            error: `failed to open wallet on network ${networkId}`\n          });\n\n          return false;\n        } // prompt user with a connect request. the options will be used as previously set above.\n        // upon success, the walletRequestHandler will notify the dapp with the ConnectDetails.\n        // upon cancellation by user, the walletRequestHandler will throw an error\n\n\n        if (intent && intent.type === 'connect') {\n          // notify wallet is opened, without session details\n          _this.notifyOpen({\n            sessionId: _this._sessionId\n          });\n\n          try {\n            const connectDetails = await _this.walletRequestHandler.promptConnect(intent.options);\n\n            if (connectDetails.connected) {\n              _this.walletRequestHandler.notifyConnect(connectDetails);\n            }\n          } catch (err) {\n            logger.warn('promptConnect not connected:', err);\n          } finally {\n            // auto-close by default, unless intent is to keep open\n            if (!intent.options || intent.options.keepWalletOpened !== true) {\n              _this.notifyClose();\n            }\n          }\n        } else {\n          // user is already connected, notify session details.\n          // TODO: in future, keep list if 'connected' dapps / sessions in the session\n          // controller, and only sync with allowed apps\n          _this.notifyOpen({\n            sessionId: _this._sessionId,\n            chainId: `${chainId}`,\n            session: await _this.walletRequestHandler.walletSession()\n          });\n        }\n      }\n\n      return true;\n    };\n\n    this.saveTransportSession = session => {\n      LocalStorage.getInstance().setItem(TRANSPORT_SESSION_LS_KEY, JSON.stringify(session));\n    };\n\n    this.getCachedTransportSession = async function () {\n      const session = await LocalStorage.getInstance().getItem(TRANSPORT_SESSION_LS_KEY);\n\n      try {\n        return session ? JSON.parse(session) : null;\n      } catch (err) {\n        console.error(`unable to parse transport session: ${session}`);\n        return null;\n      }\n    };\n\n    this.walletRequestHandler = walletRequestHandler;\n    this._init = InitState.NIL;\n    this.walletRequestHandler.on('connect', connectDetails => {\n      if (!this.registered) return; // means user has logged in and wallet is connected to the app\n\n      this.notifyConnect(connectDetails);\n    });\n    this.walletRequestHandler.on('disconnect', error => {\n      if (!this.registered) return; // means user has logged out the app / disconnected wallet from the app\n\n      this.notifyDisconnect(error);\n    });\n    this.walletRequestHandler.on('accountsChanged', (accounts, origin) => {\n      if (!this.registered) return;\n      this.notifyAccountsChanged(accounts, origin);\n    });\n    this.walletRequestHandler.on('networks', networks => {\n      if (!this.registered) return;\n      this.notifyNetworks(networks);\n\n      if (!networks || networks.length === 0) {\n        this.notifyChainChanged('0x0');\n      } else {\n        this.notifyChainChanged(ethers.utils.hexlify(networks.find(network => network.isDefaultChain).chainId));\n      }\n    });\n    this.walletRequestHandler.on('walletContext', walletContext => {\n      if (!this.registered || !walletContext) return;\n      this.notifyWalletContext(walletContext);\n    });\n    this.walletRequestHandler.on('close', error => {\n      if (!this.registered) return;\n      this.notifyClose(error);\n    });\n  }\n\n  get registered() {\n    return this._registered;\n  }\n\n  register() {\n    throw new Error('abstract method');\n  }\n\n  unregister() {\n    throw new Error('abstract method');\n  }\n\n  sendMessage(message) {\n    throw new Error('abstract method');\n  }\n\n  notifyOpen(openInfo) {\n    const {\n      chainId,\n      sessionId,\n      session,\n      error\n    } = openInfo;\n    this.sendMessage({\n      idx: -1,\n      type: EventType.OPEN,\n      data: {\n        chainId,\n        sessionId,\n        session,\n        error\n      }\n    });\n  }\n\n  notifyClose(error) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CLOSE,\n      data: error ? {\n        error\n      } : null\n    });\n  }\n\n  notifyConnect(connectDetails) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CONNECT,\n      data: connectDetails\n    });\n  }\n\n  notifyDisconnect(error) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.DISCONNECT,\n      data: error ? {\n        error\n      } : null\n    });\n  }\n\n  notifyAccountsChanged(accounts, origin) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.ACCOUNTS_CHANGED,\n      data: accounts,\n      origin: origin\n    });\n  }\n\n  notifyChainChanged(chainIdHex) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CHAIN_CHANGED,\n      data: chainIdHex\n    });\n  }\n\n  notifyNetworks(networks) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.NETWORKS,\n      data: networks\n    });\n  }\n\n  notifyWalletContext(walletContext) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.WALLET_CONTEXT,\n      data: walletContext\n    });\n  }\n\n  isValidInitAck(message) {\n    if (this._init === InitState.OK) {\n      // we're already in init state, we shouldn't handle this message\n      logger.warn(\"isValidInitAck, already in init'd state, so inquiry is invalid.\");\n      return false;\n    }\n\n    if (message.type !== EventType.INIT) {\n      logger.warn('isValidInitAck, invalid message type, expecting init');\n      return false;\n    }\n\n    const {\n      sessionId,\n      nonce\n    } = message.data;\n\n    if (!sessionId || sessionId.length === 0 || !nonce || nonce.length === 0) {\n      logger.error('invalid init ack');\n      return false;\n    }\n\n    if (sessionId !== this._sessionId || nonce !== this._initNonce) {\n      logger.error('invalid init ack match');\n      return false;\n    } // all checks pass, its true\n\n\n    return true;\n  }\n\n  init() {\n    return new Promise((resolve, reject) => {\n      // avoid re-init`ing, or if there is a transport which doesn't require\n      // it, then it may set this._init to OK in its constructor.\n      if (this._init === InitState.OK) {\n        resolve();\n        return;\n      }\n\n      if (this._init !== InitState.NIL || this._initCallback) {\n        reject('transport init is in progress');\n        return;\n      } // start init timeout, if we don't receive confirmation\n      // from provider within this amount of time, then we timeout\n\n\n      const initTimeout = setTimeout(() => {\n        logger.warn('transport init timed out');\n\n        if (this._initCallback) {\n          this._initCallback('transport init timed out');\n        }\n      }, PROVIDER_OPEN_TIMEOUT / 2); // setup callback as we receive the init message async in the handleMessage function\n\n      this._initCallback = error => {\n        this._initCallback = undefined; // reset\n\n        clearTimeout(initTimeout);\n\n        if (error) {\n          reject(error);\n        } else {\n          this._init = InitState.OK;\n          resolve();\n        }\n      }; // send init request with random nonce to the provider, where we expect\n      // for the provider to echo it back to us as complete handshake\n\n\n      this._initNonce = `${performance.now()}`;\n      this.sendMessage({\n        idx: -1,\n        type: EventType.INIT,\n        data: {\n          nonce: this._initNonce\n        }\n      });\n      this._init = InitState.SENT_NONCE; // NOTE: the promise will resolve in the _initCallback method\n      // which will be called from either handleMessage or the initTimeout\n    });\n  }\n\n}\n\nclass ProxyMessageChannel {\n  constructor() {\n    this.app = void 0;\n    this.wallet = void 0;\n    const port1 = new ProxyMessageChannelPort();\n    const port2 = new ProxyMessageChannelPort();\n    port1.conn = port2;\n    port2.conn = port1;\n    this.app = port1;\n    this.wallet = port2;\n  }\n\n}\nclass ProxyMessageChannelPort {\n  constructor() {\n    this.conn = void 0;\n    this.events = new EventEmitter2();\n\n    this.handleMessage = message => {\n      throw new Error('ProxyMessageChannelPort is not registered');\n    };\n\n    this.sendMessage = message => {\n      this.conn.handleMessage(message); // trigger events\n\n      if (message.type === 'open') {\n        this.events.emit('open', message);\n      }\n\n      if (message.type === 'close') {\n        this.events.emit('close', message);\n      }\n\n      if (message.type === 'connect') {\n        this.events.emit('connect', message);\n      }\n\n      if (message.type === 'disconnect') {\n        this.events.emit('disconnect', message);\n      }\n    };\n  }\n\n  on(event, fn) {\n    this.events.on(event, fn);\n  }\n\n  once(event, fn) {\n    this.events.once(event, fn);\n  }\n\n}\n\nclass ProxyMessageProvider extends BaseProviderTransport {\n  constructor(port) {\n    super();\n    this.port = void 0;\n\n    this.register = () => {\n      this.port.handleMessage = message => {\n        this.handleMessage(message);\n      };\n\n      this.on('open', (...args) => {\n        this.port.events.emit('open', ...args);\n      });\n      this.on('close', (...args) => {\n        this.port.events.emit('close', ...args);\n      });\n      this.on('connect', (...args) => {\n        this.port.events.emit('connect', ...args);\n      });\n      this.on('disconnect', (...args) => {\n        this.port.events.emit('disconnect', ...args);\n      });\n      this._registered = true;\n    };\n\n    this.unregister = () => {\n      this._registered = false;\n      this.closeWallet();\n      this.events.removeAllListeners(); // @ts-ignore\n\n      this.port.handleMessage = undefined;\n    };\n\n    this.openWallet = (path, intent, networkId) => {\n      if (this.state === OpenState.CLOSED) {\n        this.state = OpenState.OPENING;\n        const sessionId = `${performance.now()}`;\n        this._sessionId = sessionId;\n        this.sendMessage({\n          idx: -1,\n          type: EventType.OPEN,\n          data: {\n            path,\n            intent,\n            networkId,\n            sessionId\n          }\n        });\n      }\n    };\n\n    this.state = OpenState.CLOSED;\n    this.port = port;\n\n    if (!port) {\n      throw new Error('port argument cannot be empty');\n    } // disable init handshake for proxy-transport, we set it to OK, to\n    // consider it in completed state.\n\n\n    this._init = InitState.OK;\n  }\n\n  closeWallet() {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CLOSE,\n      data: null\n    });\n    this.close();\n  }\n\n  sendMessage(message) {\n    if (!message.idx) {\n      throw new Error('message idx is empty');\n    }\n\n    this.port.sendMessage(message);\n  }\n\n}\n\nclass ProxyMessageHandler extends BaseWalletTransport {\n  constructor(walletRequestHandler, port) {\n    super(walletRequestHandler);\n    this.port = void 0;\n    this.port = port;\n    this._init = InitState.OK;\n  }\n\n  register() {\n    this.port.handleMessage = message => {\n      this.handleMessage(message);\n    };\n\n    this._registered = true;\n  } // note: we can't decide whether to restore the session within register(), because session info is\n  // received asyncronously via EventType.OPEN after register() is executed.\n  // And in the case of a redirect/reload, EventType.OPEN is not sent at all,\n  // because the wallet is already open.\n  //\n  // call this method from wallet redirect hander when a session restore is needed\n\n\n  async restoreSession() {\n    const cachedSession = await this.getCachedTransportSession();\n\n    if (cachedSession) {\n      this.open(cachedSession);\n    }\n  }\n\n  unregister() {\n    // @ts-ignore\n    this.port.handleMessage = undefined;\n    this._registered = false;\n  }\n\n  sendMessage(message) {\n    this.port.sendMessage(message);\n  }\n\n}\n\nclass MuxMessageProvider {\n  constructor(...messageProviders) {\n    var _this = this;\n\n    this.messageProviders = void 0;\n    this.provider = void 0;\n\n    this.register = () => {\n      if (this.messageProviders.length === 1) {\n        this.provider = this.messageProviders[0];\n        this.provider.register();\n        return;\n      } // REVIEW/NOTE: ........ this method does not work for the chrome-extension. The issue becomes\n      // when the browser quits or restarts, the \"open\" event is never triggered. Perhaps the code here is fine,\n      // or maybe its not. What should happen is when a dapp makes a request, it will call openWallet\n      // below, in which case one of the events will register. So perhaps this is fine.\n\n\n      this.messageProviders.forEach(m => {\n        m.register();\n        m.once('open', () => {\n          // the first one to open is the winner, and others will be unregistered\n          if (!this.provider) {\n            this.provider = m; // unregister other providers\n\n            this.messageProviders.forEach(m => {\n              if (this.provider !== m) {\n                m.unregister();\n              }\n            });\n          }\n        });\n      });\n    };\n\n    this.unregister = () => {\n      this.messageProviders.forEach(m => m.unregister());\n      this.provider = undefined;\n    };\n\n    this.openWallet = (path, intent, networkId) => {\n      if (this.provider) {\n        this.provider.openWallet(path, intent, networkId);\n        return;\n      }\n\n      this.messageProviders.forEach(m => m.openWallet(path, intent, networkId));\n    };\n\n    this.sendAsync = async function (request, callback, chainId) {\n      if (_this.provider) {\n        _this.provider.sendAsync(request, callback, chainId);\n\n        return;\n      }\n\n      throw new Error('impossible state, wallet must be opened first');\n    };\n\n    this.sendMessageRequest = async function (message) {\n      if (_this.provider) {\n        return _this.provider.sendMessageRequest(message);\n      }\n\n      throw new Error('impossible state, wallet must be opened first');\n    };\n\n    this.waitUntilOpened = async function () {\n      if (_this.provider) {\n        return _this.provider.waitUntilOpened();\n      }\n\n      return Promise.race(_this.messageProviders.map(p => p.waitUntilOpened()));\n    };\n\n    this.waitUntilConnected = async function () {\n      if (_this.provider) {\n        return _this.provider.waitUntilConnected();\n      }\n\n      throw new Error('impossible state, wallet must be opened first');\n    };\n\n    this.messageProviders = messageProviders;\n    this.provider = undefined;\n  }\n\n  add(...messageProviders) {\n    this.messageProviders.push(...messageProviders);\n  }\n\n  closeWallet() {\n    if (this.provider) {\n      this.provider.closeWallet();\n    }\n  }\n\n  isOpened() {\n    if (this.provider) {\n      return this.provider.isOpened();\n    }\n\n    return false;\n  }\n\n  isConnected() {\n    if (this.provider) {\n      return this.provider.isConnected();\n    }\n\n    return false;\n  }\n\n  on(event, fn) {\n    if (this.provider) {\n      this.provider.on(event, fn);\n      return;\n    }\n\n    this.messageProviders.forEach(m => {\n      m.on(event, fn);\n    });\n  }\n\n  once(event, fn) {\n    if (this.provider) {\n      this.provider.once(event, fn);\n      return;\n    }\n\n    this.messageProviders.forEach(m => {\n      m.once(event, fn);\n    });\n  }\n\n  emit(event, ...args) {\n    if (this.provider) {\n      return this.provider.emit(event, ...args);\n    }\n\n    for (let i = 0; i < this.messageProviders.length; i++) {\n      this.messageProviders[i].emit(event, ...args);\n    }\n\n    return true;\n  }\n\n  sendMessage(message) {\n    if (!message.idx || message.idx <= 0) {\n      throw new Error('message idx is empty');\n    }\n\n    if (this.provider) {\n      this.provider.sendMessage(message);\n    } else {\n      throw new Error('impossible state, wallet must be opened first');\n    }\n  }\n\n  handleMessage(message) {\n    if (this.provider) {\n      this.provider.handleMessage(message);\n      return;\n    }\n\n    throw new Error('impossible state, wallet must be opened first');\n  }\n\n}\n\nlet registeredWindowMessageProvider;\nclass WindowMessageProvider extends BaseProviderTransport {\n  constructor(walletAppURL) {\n    super();\n    this.walletURL = void 0;\n    this.walletWindow = void 0;\n\n    this.register = () => {\n      if (registeredWindowMessageProvider) {\n        // overriding the registered message provider\n        registeredWindowMessageProvider.unregister();\n        registeredWindowMessageProvider = this;\n      } // listen for incoming messages from wallet\n\n\n      window.addEventListener('message', this.onWindowEvent);\n      registeredWindowMessageProvider = this; // open heartbeat\n\n      this.on('open', () => {\n        // Heartbeat to track if window closed\n        const popup = this.walletWindow;\n        const interval = setInterval(() => {\n          if (popup && popup.closed) {\n            clearInterval(interval);\n            this.close();\n          }\n        }, 500);\n      }); // close clean up\n\n      this.on('close', () => {\n        if (this.walletWindow) {\n          this.walletWindow.close();\n          this.walletWindow = null;\n        }\n      });\n      this._registered = true;\n    };\n\n    this.unregister = () => {\n      this._registered = false;\n      this.closeWallet(); // disable message listener\n\n      if (registeredWindowMessageProvider === this) {\n        registeredWindowMessageProvider = undefined;\n      }\n\n      window.removeEventListener('message', this.onWindowEvent); // clear event listeners\n\n      this.events.removeAllListeners();\n    };\n\n    this.openWallet = (path, intent, networkId) => {\n      if (this.walletWindow && this.isOpened()) {\n        // TODO: update the location of window to path\n        this.walletWindow.focus();\n        return;\n      } // Instantiate new walletURL for this call\n\n\n      const walletURL = new URL(this.walletURL.href);\n      const windowSessionParams = new WindowSessionParams();\n\n      if (path && path !== '') {\n        walletURL.pathname = path.toLowerCase();\n      } // Set session, intent and network id on walletURL\n\n\n      this._init = InitState.NIL;\n      this._sessionId = `${performance.now()}`;\n      windowSessionParams.set('sid', this._sessionId);\n\n      if (intent) {\n        // for the window-transport, we eagerly/optimistically set the origin host\n        // when connecting to the wallet, however, this will be verified and enforced\n        // on the wallet-side, so if a dapp provides the wrong origin, it will be dropped.\n        if (intent.type === 'connect') {\n          if (!intent.options) intent.options = {}; // skip setting origin host if we're in an browser extension execution context\n          // allow origin that is passed in\n\n          if (!isBrowserExtension()) {\n            intent.options.origin = window.location.origin;\n          }\n        } // encode intent as base64 url-encoded param\n\n\n        windowSessionParams.set('intent', base64EncodeObject(intent));\n      }\n\n      if (networkId) {\n        windowSessionParams.set('net', `${networkId}`);\n      } // Open popup window on center of the app window\n\n\n      let windowSize;\n      let windowPos;\n\n      if (isBrowserExtension()) {\n        windowSize = [450, 750];\n        windowPos = [Math.abs(window.screen.width / 2 - windowSize[0] / 2), Math.abs(window.screen.height / 2 - windowSize[1] / 2)];\n      } else {\n        windowSize = [450, 750];\n        windowPos = [Math.abs(window.screenX + window.innerWidth / 2 - windowSize[0] / 2), Math.abs(window.screenY + window.innerHeight / 2 - windowSize[1] / 2)];\n      }\n\n      const windowFeatures = `toolbar=0,location=0,menubar=0,scrollbars=yes,status=yes` + `,width=${windowSize[0]},height=${windowSize[1]}` + `,left=${windowPos[0]},top=${windowPos[1]}`; // serialize params\n\n      walletURL.search = windowSessionParams.toString();\n      this.walletWindow = window.open(walletURL.href, 'sequence.app', windowFeatures); // TODO: move this somewhere else\n      // TODO: perhaps we trigger a .on('openTimeout') event..? maybe.. could help.\n      // Popup blocking detection and notice\n      // let warned = false\n      // const warnPopupBlocked = () => {\n      //   if (warned) return\n      //   warned = true\n      //   // alert('popup is blocked! hey yo') // NOTE: for debug purposes only\n      //   throw new Error('popup is blocked')\n      // }\n      // const popupCheck = setTimeout(() => {\n      //   if (!popup || popup.closed || typeof popup.closed === 'undefined') {\n      //     // popup is definitely blocked if we reach here.\n      //     warnPopupBlocked()\n      //   }\n      // }, 1000)\n      // const popupBlocked = popup === null || popup === undefined\n      // if (popupBlocked) {\n      //   warnPopupBlocked()\n      //   return\n      // }\n    };\n\n    this.onWindowEvent = event => {\n      // Security check, ensure message is coming from wallet origin url\n      if (event.origin !== this.walletURL.origin) {\n        // Safetly can skip events not from the wallet\n        return;\n      }\n\n      let message;\n\n      try {\n        message = JSON.parse(event.data);\n      } catch (err) {\n        // event is not a ProviderMessage JSON object, skip\n        return;\n      }\n\n      if (!message) {\n        throw new Error('ProviderMessage object is empty');\n      } // handle message with base message provider\n\n\n      this.handleMessage(message);\n    };\n\n    this.walletURL = new URL(walletAppURL);\n  }\n\n  closeWallet() {\n    var _this$walletWindow;\n\n    this.close();\n    (_this$walletWindow = this.walletWindow) == null ? void 0 : _this$walletWindow.close();\n  } // onmessage, receives ProviderMessageResponse from the wallet post-message transport\n\n\n  sendMessage(message) {\n    if (!this.walletWindow) {\n      logger.warn('WindowMessageProvider: sendMessage failed as walletWindow is unavailable');\n      return;\n    }\n\n    const postedMessage = typeof message !== 'string' ? JSON.stringify(message) : message;\n    this.walletWindow.postMessage(postedMessage, this.walletURL.origin);\n  }\n\n}\n\nclass WindowMessageHandler extends BaseWalletTransport {\n  constructor(walletRequestHandler) {\n    var _this;\n\n    super(walletRequestHandler);\n    _this = this;\n    this.parentWindow = void 0;\n    this._isPopup = false;\n\n    this.onWindowEvent = async function (event) {\n      if (!event.origin || event.origin === '') {\n        // skip same-origin or when event.origin is empty/undefined\n        return;\n      }\n\n      if (_this.appOrigin && event.origin !== _this.appOrigin) {\n        // skip message as not from expected app origin\n        return;\n      } // Wallet always expects json-rpc request messages from a dapp\n\n\n      let request;\n\n      try {\n        request = JSON.parse(event.data);\n      } catch (err) {\n        // event is not a ProviderMessage JSON object, skip\n        return;\n      }\n\n      logger.debug('RECEIVED MESSAGE', request); // Record event origin for valid init ack\n\n      if (_this._init !== InitState.OK && _this.isValidInitAck(request)) {\n        _this.appOrigin = event.origin;\n      }\n\n      if (_this._init === InitState.OK && (!_this.appOrigin || _this.appOrigin.length < 8)) {\n        // impossible state\n        logger.error('impossible state, init.OK and appOrigin required');\n        return;\n      } // Handle message via the base transport\n\n\n      _this.handleMessage(request);\n    };\n\n    this.getWindowTransportSession = windowParams => {\n      const params = new WindowSessionParams(windowParams);\n      return {\n        sessionId: params.get('sid'),\n        networkId: params.get('net'),\n        intent: base64DecodeObject(params.get('intent'))\n      };\n    };\n\n    this._init = InitState.NIL;\n  }\n\n  async register(windowHref) {\n    const isPopup = parent.window.opener !== null;\n    this._isPopup = isPopup;\n\n    if (isPopup !== true) {\n      return;\n    } // record open details (sessionId + default network) from the window url\n\n\n    const {\n      pathname,\n      search: rawParams\n    } = new URL(windowHref || window.location.href);\n    let session = this.getWindowTransportSession(rawParams); // provider should always include sid when opening a new window\n\n    const isNewWindowSession = !!session.sessionId; // attempt to restore previous session in the case of a redirect or window reload\n\n    if (!isNewWindowSession) {\n      session = await this.getCachedTransportSession();\n    }\n\n    if (!session) {\n      logger.error('window session is undefined');\n      return;\n    } // record parent window instance for communication\n\n\n    this.parentWindow = parent.window.opener; // listen for window-transport requests\n\n    window.addEventListener('message', this.onWindowEvent, false);\n    this._registered = true; // send open event to the app which opened us\n\n    this.open(session).then(opened => {\n      if (!opened) {\n        var _session;\n\n        const err = `failed to open to network ${(_session = session) == null ? void 0 : _session.networkId}`;\n        logger.error(err);\n        this.notifyClose({\n          message: err\n        });\n        window.close();\n      }\n    }).catch(e => {\n      var _session2;\n\n      const err = `failed to open to network ${(_session2 = session) == null ? void 0 : _session2.networkId}, due to: ${e}`;\n      logger.error(err);\n      this.notifyClose({\n        message: err\n      });\n      window.close();\n    });\n  }\n\n  unregister() {\n    window.removeEventListener('message', this.onWindowEvent);\n    this._registered = false;\n  } // onmessage is called when (the wallet) receives request messages from the dapp\n  // over the window post-messaging transport\n\n\n  // postMessage sends message to the dapp window\n  sendMessage(message) {\n    // prepare payload\n    const payload = JSON.stringify(message); // post-message to app.\n    // only for init requests, we send to '*' origin\n\n    if (message.type === EventType.INIT) {\n      this.postMessage(payload, true);\n    } else {\n      this.postMessage(payload);\n    }\n  }\n\n  get isPopup() {\n    return this._isPopup;\n  }\n\n  postMessage(message, init = false) {\n    if (init !== true && this._init !== InitState.OK) {\n      logger.error('impossible state, should not be calling postMessage until inited');\n      return;\n    }\n\n    if (init) {\n      // init message transmission to global target -- for 'init' payloads only\n      this.parentWindow.postMessage(message, '*');\n    } else {\n      // open message transmission\n      if (this.appOrigin && this.appOrigin.length > 4) {\n        // just above '.com'\n        this.parentWindow.postMessage(message, this.appOrigin);\n      } else {\n        logger.error('unable to postMessage as parentOrigin is invalid');\n      }\n    }\n  }\n\n}\n\nconst CHANNEL_ID = 'sequence-extension-message-handler';\nclass ExtensionMessageHandler extends BaseWalletTransport {\n  constructor(walletRequestHandler, runtime) {\n    super(walletRequestHandler);\n    this.runtime = runtime;\n    this.port = void 0;\n    this._init = InitState.OK;\n  }\n\n  register() {\n    this._registered = true;\n    this.port = this.runtime.connect({\n      name: CHANNEL_ID\n    });\n  }\n\n  sendMessage(message) {\n    logger.info('[ExtensionMessageHandler send]', message);\n    this.port.postMessage(message);\n  }\n\n}\n\nclass ExtensionMessageProvider extends BaseProviderTransport {\n  constructor(runtime) {\n    super();\n\n    this.register = () => {\n      this._registered = true;\n    };\n\n    runtime.onConnect.addListener(port => {\n      if (port.name === CHANNEL_ID) {\n        this._init = InitState.OK;\n        port.onMessage.addListener(message => {\n          this.handleMessage(message);\n        });\n      }\n    });\n  }\n\n  sendMessage(message) {//noop\n  }\n\n  unregister() {//noop\n  }\n\n  openWallet(path, intent, networkId) {//noop\n  }\n\n  closeWallet() {//noop\n  }\n\n}\n\n// to be used on injected window.ethereum EIP1193 proxy\nclass BaseInjectedTransport extends EventEmitter2 {\n  constructor(stream) {\n    var _this;\n\n    super();\n    _this = this;\n    this.stream = stream;\n    this.responseCallbacks = new Map();\n    this._messageIdx = 0;\n\n    this.nextMessageIdx = () => ++this._messageIdx;\n\n    this.handleMessage = message => {\n      if (!message.type || !message.data) {\n        return;\n      }\n\n      logger.info('[received message]', message);\n      const requestIdx = message.idx;\n      const responseCallback = this.responseCallbacks.get(requestIdx);\n\n      if (requestIdx) {\n        this.responseCallbacks.delete(requestIdx);\n      }\n\n      switch (message.type) {\n        case EventType.MESSAGE:\n          if (responseCallback) {\n            this.emit(EventType.MESSAGE, message);\n            responseCallback(message.data.error, message);\n          } else {\n            // NOTE: this would occur if 'idx' isn't set, which should never happen\n            // or when we register two handler, or duplicate messages with the same idx are sent,\n            // all of which should be prevented prior to getting to this point\n            throw new Error('impossible state');\n          }\n\n          break;\n\n        case EventType.DISCONNECT:\n        case EventType.ACCOUNTS_CHANGED:\n        case EventType.CHAIN_CHANGED:\n          this.emit(message.type, message.data);\n          break;\n\n        default:\n          console.error('unknown message type', message);\n          break;\n      }\n    };\n\n    this.sendMessageRequest = async function (message) {\n      return new Promise((resolve, reject) => {\n        if (!message.idx || message.idx <= 0) {\n          reject(new Error('message idx not set'));\n        }\n\n        const responseCallback = (error, response) => {\n          if (error) {\n            reject(error);\n          } else if (response) {\n            resolve(response);\n          } else {\n            throw new Error('no valid response to return');\n          }\n        };\n\n        const {\n          idx\n        } = message;\n\n        if (!_this.responseCallbacks.get(idx)) {\n          _this.responseCallbacks.set(idx, responseCallback);\n        } else {\n          reject(new Error('duplicate message idx, should never happen'));\n        }\n\n        _this.sendMessage(message);\n      });\n    };\n\n    this.stream.on('data', this.handleMessage);\n  }\n\n  sendMessage(message) {\n    if (!this.stream.writable) {\n      console.error('window post message stream is not writable');\n    }\n\n    this.stream.write(message);\n  }\n\n}\n\nclass WalletUtils {\n  constructor(walletProvider) {\n    var _this = this;\n\n    this.wallet = void 0;\n\n    this.recoverWalletConfig = async function (address, digest, signature, chainId, walletContext) {\n      walletContext = walletContext || (await _this.wallet.getWalletContext());\n      return recoverWalletConfig(address, digest, signature, chainId, walletContext);\n    };\n\n    this.recoverWalletConfigFromMessage = async function (address, message, signature, chainId, walletContext) {\n      walletContext = walletContext || (await _this.wallet.getWalletContext());\n      return recoverWalletConfig(address, encodeMessageDigest(prefixEIP191Message(message)), signature, chainId, walletContext);\n    };\n\n    this.recoverWalletConfigFromTypedData = async function (address, typedData, signature, chainId, walletContext) {\n      walletContext = walletContext || (await _this.wallet.getWalletContext());\n      return recoverWalletConfig(address, encodeTypedDataDigest(typedData), signature, chainId, walletContext);\n    };\n\n    this.wallet = walletProvider;\n  } // Sign message on a specified chain, or DefaultChain by default\n\n\n  signMessage(message, chainId, allSigners) {\n    const signer = this.wallet.getSigner();\n    if (!signer) throw new Error('unable to get signer');\n    return signer.signMessage(message, chainId, allSigners);\n  } // Sign message on the AuthChain\n\n\n  async signAuthMessage(message, allSigners) {\n    const signer = await this.wallet.getAuthSigner();\n    if (!signer) throw new Error('unable to get AuthChain signer');\n    return signer.signMessage(message, await signer.getChainId(), allSigners);\n  } // Sign EIP-712 TypedData on a specified chain, or DefaultChain by default\n\n\n  signTypedData(domain, types, message, chainId, allSigners) {\n    const signer = this.wallet.getSigner();\n    if (!signer) throw new Error('unable to get signer');\n    return signer.signTypedData(domain, types, message, chainId, allSigners);\n  } // Sign EIP-712 TypedData on the AuthChain\n\n\n  async signAuthTypedData(domain, types, message, allSigners) {\n    const signer = await this.wallet.getAuthSigner();\n    if (!signer) throw new Error('unable to get AuthChain signer');\n    return signer.signTypedData(domain, types, message, await signer.getChainId(), allSigners);\n  } // Verify signature of a digest, one of a message, typedData or other\n\n\n  async isValidSignature(address, digest, signature, chainId, walletContext) {\n    const provider = this.wallet.getProvider(chainId);\n    if (!provider) throw new Error(`unable to get provider for chainId ${chainId}`);\n    return isValidSignature(address, digest, signature, provider, chainId, walletContext);\n  } // Verify message signature\n\n\n  async isValidMessageSignature(address, message, signature, chainId, walletContext) {\n    const provider = this.wallet.getProvider(chainId);\n    if (!provider) throw new Error(`unable to get provider for chainId ${chainId}`);\n    const prefixed = prefixEIP191Message(message);\n    const digest = encodeMessageDigest(prefixed);\n    return isValidSignature(address, digest, signature, provider, chainId, walletContext);\n  } // Verify typedData signature\n\n\n  isValidTypedDataSignature(address, typedData, signature, chainId, walletContext) {\n    return this.isValidSignature(address, encodeTypedDataDigest(typedData), signature, chainId, walletContext);\n  } // Recover the WalletConfig from a signature + digest combo\n  // sendTransaction()\n  // sendTransactions()\n  // sendETH()\n  // sendToken()\n  // sendCoin() -- sugar for sendToken()\n  // sendCollectible() -- sugar for sendToken()\n  // callContract()\n  // transactionHistory()\n  // getReceipt()\n  // getLogs()\n  // // ..\n  // isWalletDeployed()\n  // deployWallet()\n  // validateSignature()\n  // recoverWalletConfig()\n  // recoverAddress()\n\n\n}\n\nclass Wallet {\n  constructor(_network, config) {\n    var _this = this;\n\n    this.utils = void 0;\n    this.config = void 0;\n    this.session = void 0;\n    this.connectedSites = void 0;\n    this.transport = void 0;\n    this.networks = void 0;\n    this.providers = void 0;\n\n    this.init = () => {\n      var _this$config$transpor, _this$config$transpor2, _this$config$transpor3, _this$config$transpor4, _this$config$transpor5, _this$config$transpor6;\n\n      if (this.transport.provider) {\n        // init must have already been called\n        return;\n      } // Setup provider\n\n\n      this.transport.messageProvider = new MuxMessageProvider(); // multiple message provider setup, first one to connect will be the main transport\n\n      if ((_this$config$transpor = this.config.transports) != null && (_this$config$transpor2 = _this$config$transpor.windowTransport) != null && _this$config$transpor2.enabled) {\n        this.transport.windowMessageProvider = new WindowMessageProvider(this.config.walletAppURL);\n        this.transport.messageProvider.add(this.transport.windowMessageProvider);\n      }\n\n      if ((_this$config$transpor3 = this.config.transports) != null && (_this$config$transpor4 = _this$config$transpor3.proxyTransport) != null && _this$config$transpor4.enabled) {\n        this.transport.proxyMessageProvider = new ProxyMessageProvider(this.config.transports.proxyTransport.appPort);\n        this.transport.messageProvider.add(this.transport.proxyMessageProvider);\n      }\n\n      if ((_this$config$transpor5 = this.config.transports) != null && (_this$config$transpor6 = _this$config$transpor5.extensionTransport) != null && _this$config$transpor6.enabled) {\n        this.transport.extensionMessageProvider = new ExtensionMessageProvider(this.config.transports.extensionTransport.runtime); // this.transport.extensionMessageProvider.register()\n\n        this.transport.messageProvider.add(this.transport.extensionMessageProvider); // NOTE/REVIEW: see note in mux-message-provider\n        //\n        // We don't add the extensionMessageProvider here because we don't send requests to it anyways, we seem to\n        // send all requests to the WindowMessageProvider anyways. By allowing it, if browser restarts, it will break\n        // the entire extension because messageProvider.provider will be undefined. So this is a hack to fix it.\n        //\n        // this.transport.messageProvider.add(this.transport.extensionMessageProvider)\n      }\n\n      this.transport.messageProvider.register(); // .....\n\n      this.transport.allowProvider = allowProviderMiddleware(request => {\n        if (request.method === 'sequence_setDefaultNetwork') return true;\n        const isConnected = this.isConnected();\n\n        if (!isConnected) {\n          throw new Error('Sequence: wallet not connected');\n        }\n\n        return isConnected;\n      }); // ...\n\n      this.transport.networkProvider = networkProviderMiddleware(request => {\n        // return stub chainId of 0 when not connected to any\n        if (!this.networks || this.networks.length === 0) return 0; // return the default chainId as we're connected\n\n        return this.networks.find(network => network.isDefaultChain).chainId;\n      }); // Provider proxy to support middleware stack of logging, caching and read-only rpc calls\n\n      this.transport.cachedProvider = new CachedProvider();\n      this.transport.cachedProvider.onUpdate(() => {\n        if (!this.session) this.session = {\n          providerCache: {}\n        };\n        this.session.providerCache = this.transport.cachedProvider.getCache();\n        this.saveSession(this.session);\n      }); // ..\n\n      this.transport.router = new JsonRpcRouter([loggingProviderMiddleware, this.transport.networkProvider, this.transport.allowProvider, exceptionProviderMiddleware, this.transport.cachedProvider], this.transport.messageProvider);\n      this.transport.provider = new Web3Provider(this.transport.router); // NOTE: we don't listen on 'connect' even here as we handle it within connect() method\n      // in more synchronous flow.\n      // below will update the wallet session object and persist it. In case the session\n      // is undefined, we consider the session to have been removed by the user, so we clear it.\n\n      this.transport.messageProvider.on('open', openInfo => {\n        const {\n          session\n        } = openInfo;\n\n        if (!session) {\n          if (this.session && this.session.accountAddress) {\n            // emit disconnect even if previously we had a session, and now we don't.\n            this.transport.messageProvider.emit('disconnect');\n          }\n\n          this.clearSession();\n        } else {\n          this.useSession(session, true);\n        }\n      }); // below will update the account upon wallet connect/disconnect - aka, login/logout.\n      // if an origin is provided, this operation should be performed only on that origin\n      // and shouldn't affect the session of the wallet.\n\n      this.transport.messageProvider.on('accountsChanged', (accounts, origin) => {\n        if (origin) {\n          if (accounts.length > 0) {\n            this.useSession({\n              accountAddress: accounts[0]\n            }, true);\n          }\n\n          return;\n        }\n\n        if (!accounts || accounts.length === 0 || accounts[0] === '') {\n          this.clearSession();\n        } else {\n          this.useSession({\n            accountAddress: accounts[0]\n          }, true);\n        }\n      }); // below will update the networks automatically when the wallet networks change\n\n      this.transport.messageProvider.on('networks', networks => {\n        this.useSession({\n          networks: networks\n        }, true);\n      }); // below will update the wallet context automatically\n\n      this.transport.messageProvider.on('walletContext', walletContext => {\n        this.useSession({\n          walletContext: walletContext\n        }, true);\n      });\n    };\n\n    this.loadSession = async function () {\n      const data = await LocalStorage.getInstance().getItem('@sequence.session');\n\n      if (!data || data === '') {\n        return undefined;\n      }\n\n      try {\n        const session = JSON.parse(data);\n\n        if (session) {\n          _this.useSession(session, false);\n        }\n\n        return session;\n      } catch (err) {\n        logger.warn('loadSession failed, unable to parse session payload from storage.');\n        return undefined;\n      }\n    };\n\n    this.connect = async function (options) {\n      if ((options == null ? void 0 : options.refresh) === true) {\n        _this.disconnect();\n      }\n\n      if (_this.isConnected() && (await _this.isSiteConnected(options == null ? void 0 : options.origin)) && !!_this.session && !(options != null && options.authorize) && !(options != null && options.askForEmail)) {\n        return {\n          connected: true,\n          session: _this.session,\n          chainId: ethers.utils.hexlify(await _this.getChainId())\n        };\n      }\n\n      if (options) {\n        if (options.authorize && (!options.app || options.app === '')) {\n          throw new Error(`connecting with 'authorize' option also requires 'app' to be set`);\n        }\n      }\n\n      await _this.openWallet(undefined, {\n        type: 'connect',\n        options\n      });\n      const connectDetails = await _this.transport.messageProvider.waitUntilConnected().catch(_ => {\n        return {\n          connected: false\n        };\n      });\n\n      if (connectDetails.connected) {\n        if (!!connectDetails.session) {\n          _this.useSession(connectDetails.session, true);\n\n          _this.addConnectedSite(options == null ? void 0 : options.origin);\n        } else {\n          throw new Error('impossible state, connect response is missing session');\n        }\n      }\n\n      return connectDetails;\n    };\n\n    this.authorize = async function (options) {\n      return _this.connect(_extends({}, options, {\n        authorize: true\n      }));\n    };\n\n    this.getSession = () => {\n      if (!this.isConnected()) {\n        return undefined;\n      }\n\n      return this.session;\n    };\n\n    this.getAddress = async function () {\n      if (!_this.isConnected()) {\n        throw new Error('connect first');\n      }\n\n      const session = _this.getSession();\n\n      return session.accountAddress;\n    };\n\n    this.getNetworks = async function (chainId) {\n      if (!_this.isConnected() || !_this.networks) {\n        throw new Error('connect first');\n      }\n\n      if (chainId) {\n        // filter list to just the specific chain requested\n        const network = findNetworkConfig(_this.networks, chainId);\n        return network ? [network] : [];\n      }\n\n      return _this.networks;\n    };\n\n    this.getChainId = async function () {\n      if (!_this.networks || _this.networks.length < 1) {\n        throw new Error('networks have not been set by session. connect first.');\n      }\n\n      const network = _this.networks.find(network => network.isDefaultChain);\n\n      if (!network) {\n        throw new Error('networks must have a default chain specified');\n      }\n\n      return network.chainId;\n    };\n\n    this.getAuthChainId = async function () {\n      if (!_this.networks || _this.networks.length < 1) {\n        throw new Error('networks have not been set by session. connect first.');\n      }\n\n      const network = _this.networks.find(network => network.isAuthChain);\n\n      if (!network) {\n        throw new Error('networks must have an auth chain specified');\n      }\n\n      return network.chainId;\n    };\n\n    this.openWallet = async function (path, intent, networkId) {\n      if ((intent == null ? void 0 : intent.type) !== 'connect' && !_this.isConnected()) {\n        throw new Error('connect first');\n      }\n\n      let currentNetworkId;\n\n      if (!_this.networks || _this.networks.length < 1) {\n        currentNetworkId = _this.config.defaultNetworkId;\n      } else {\n        currentNetworkId = await _this.getChainId();\n      }\n\n      _this.transport.messageProvider.openWallet(path, intent, networkId || currentNetworkId);\n\n      await _this.transport.messageProvider.waitUntilOpened();\n      return true;\n    };\n\n    this.closeWallet = () => {\n      this.transport.messageProvider.closeWallet();\n    };\n\n    this.saveSession = async function (session) {\n      logger.debug('wallet provider: saving session');\n      const data = JSON.stringify(session);\n      await LocalStorage.getInstance().setItem('@sequence.session', data);\n    };\n\n    this.useSession = async function (session, autoSave = true) {\n      if (!_this.session) _this.session = {}; // setup wallet context\n\n      if (_this.config.walletContext) {\n        _this.session.walletContext = _this.config.walletContext;\n      } else if (session.walletContext) {\n        _this.session.walletContext = session.walletContext;\n      } // setup account\n\n\n      if (session.accountAddress) {\n        _this.useAccountAddress(session.accountAddress);\n      } // setup networks\n\n\n      if (session.networks) {\n        _this.useNetworks(session.networks);\n      } // setup provider cache\n\n\n      if (session.providerCache) {\n        _this.transport.cachedProvider.setCache(session.providerCache);\n      } // persist\n\n\n      if (autoSave) {\n        _this.saveSession(_this.session);\n      }\n    };\n\n    // config is a Partial, so that we may intersect it with the DefaultProviderConfig,\n    // which allows easy overriding and control of the config.\n    this.config = _extends({}, DefaultProviderConfig);\n\n    if (config) {\n      this.config = _extends({}, this.config, config);\n    }\n\n    if (_network) {\n      this.config.defaultNetworkId = _network;\n    } else if (!this.config.defaultNetworkId) {\n      this.config.defaultNetworkId = 'mainnet';\n    }\n\n    if (config != null && config.localStorage) {\n      LocalStorage.use(config.localStorage);\n    }\n\n    this.transport = {};\n    this.networks = [];\n    this.providers = {};\n    this.connectedSites = new LocalStore('@sequence.connectedSites', []);\n    this.utils = new WalletUtils(this);\n    this.init();\n  }\n\n  async addConnectedSite(origin) {\n    origin = origin || window.location.origin;\n    const connectedSites = await this.connectedSites.get();\n\n    if (connectedSites) {\n      if (connectedSites.includes(origin)) {\n        return;\n      }\n\n      this.connectedSites.set([...connectedSites, origin]);\n    } else {\n      this.connectedSites.set([origin]);\n    }\n  }\n\n  async removeConnectedSite(origin) {\n    const authorized = await this.connectedSites.get();\n\n    if (authorized) {\n      this.connectedSites.set(authorized.filter(domain => domain !== origin));\n    }\n  }\n\n  getConnectedSites() {\n    return this.connectedSites.get();\n  }\n\n  async isSiteConnected(origin) {\n    const authorized = await this.connectedSites.get();\n    return !!authorized && authorized.includes(origin || window.location.origin);\n  }\n\n  disconnect() {\n    if (this.isOpened()) {\n      this.closeWallet();\n    }\n\n    this.clearSession();\n  } // TODO: add switchNetwork(network: string | number) which will call wallet_switchEthereumChain\n  // and on successful response, will update the provider info here, etc.\n\n\n  getProviderConfig() {\n    return this.config;\n  }\n\n  isOpened() {\n    return this.transport.messageProvider.isOpened();\n  }\n\n  isConnected() {\n    return this.session !== undefined && this.session.networks !== undefined && this.session.networks.length > 0 && this.networks !== undefined && this.networks.length > 0 && !!this.session.accountAddress && this.session.accountAddress.startsWith('0x');\n  }\n\n  getProvider(chainId) {\n    // return the top-level provider message transport when chainId is unspecified\n    // and user has not logged in\n    if (!this.isConnected()) {\n      if (chainId) {\n        throw new Error(`session is empty. connect and try again.`);\n      } else {\n        return this.transport.provider;\n      }\n    }\n\n    let network = this.networks.find(network => network.isDefaultChain);\n\n    if (chainId) {\n      network = findNetworkConfig(this.networks, chainId);\n\n      if (!network) {\n        throw new Error(`network ${chainId} is not in the network list`);\n      }\n    } // return memoized network provider\n\n\n    if (this.providers[network.chainId]) {\n      return this.providers[network.chainId];\n    } // builder web3 provider stack\n\n\n    let provider; // network.provider may be set by the ProviderConfig override\n\n    const rpcProvider = network.provider ? network.provider : new JsonRpcProvider(network.rpcUrl, network.chainId);\n\n    if (network.isDefaultChain) {\n      // communicating with defaultChain will prioritize the wallet message transport\n      const router = new JsonRpcRouter([loggingProviderMiddleware, exceptionProviderMiddleware, new EagerProvider({\n        accountAddress: this.session.accountAddress,\n        walletContext: this.session.walletContext\n      }), new SigningProvider(this.transport.provider), this.transport.cachedProvider], new JsonRpcSender(rpcProvider));\n      provider = new Web3Provider(router, network.chainId);\n    } else {\n      // communicating with another chain will bind to that network, but will forward\n      // any signing-related requests to the wallet message transport\n      const router = new JsonRpcRouter([loggingProviderMiddleware, exceptionProviderMiddleware, new EagerProvider({\n        accountAddress: this.session.accountAddress,\n        walletContext: this.session.walletContext,\n        chainId: network.chainId\n      }), new SigningProvider(this.transport.provider), new CachedProvider(network.chainId)], new JsonRpcSender(rpcProvider));\n      provider = new Web3Provider(router, network.chainId);\n    }\n\n    this.providers[network.chainId] = provider;\n    return provider;\n  }\n\n  async getAuthProvider() {\n    return this.getProvider((await this.getAuthNetwork()).chainId);\n  }\n\n  async getAuthNetwork() {\n    return (await this.getNetworks()).find(n => n.isAuthChain);\n  }\n\n  getAllProviders() {\n    return this.providers;\n  }\n\n  getSigner(chainId) {\n    return this.getProvider(chainId).getSigner();\n  }\n\n  async getAuthSigner() {\n    return (await this.getAuthProvider()).getSigner();\n  }\n\n  getWalletConfig(chainId) {\n    return this.getSigner().getWalletConfig(chainId);\n  }\n\n  getWalletState(chainId) {\n    return this.getSigner().getWalletState(chainId);\n  }\n\n  getWalletContext() {\n    return this.getSigner().getWalletContext();\n  }\n\n  isDeployed(chainId) {\n    return this.getSigner(chainId).isDeployed();\n  }\n\n  on(event, fn) {\n    this.transport.messageProvider.on(event, fn);\n  }\n\n  once(event, fn) {\n    this.transport.messageProvider.once(event, fn);\n  }\n\n  useAccountAddress(accountAddress) {\n    if (!this.session) this.session = {};\n    this.session.accountAddress = ethers.utils.getAddress(accountAddress);\n  }\n\n  useNetworks(networks) {\n    // set networks in the session\n    if (!this.session) this.session = {}; // set networks on session object\n\n    this.session.networks = networks; // short-circuit if setting empty network list (aka logged out state)\n\n    if (!this.session.networks || this.session.networks.length === 0) {\n      return;\n    } // check if any custom network settings, otherwise return early\n\n\n    if (!this.config.networks && !this.config.networkRpcUrl) {\n      this.networks = networks;\n      return;\n    } // init networks\n\n\n    this.networks = networks; // combine custom network config with networks in the session\n\n    if (this.config.networks) {\n      this.networks = networks.map(n => _extends({}, n)); // copy\n\n      this.config.networks.forEach(n => {\n        const network = findNetworkConfig(this.networks, n.chainId || n.name);\n        if (!network) return;\n        updateNetworkConfig(n, network);\n      });\n      ensureValidNetworks(this.networks, true);\n    } // an extra override for convenience\n\n\n    if (this.config.networkRpcUrl) {\n      const network = this.networks.find(network => network.isDefaultChain);\n\n      if (network) {\n        network.rpcUrl = this.config.networkRpcUrl;\n      }\n    }\n  }\n\n  clearSession() {\n    var _this$transport$cache;\n\n    logger.debug('wallet provider: clearing session');\n    LocalStorage.getInstance().removeItem('@sequence.session');\n    this.session = undefined;\n    this.networks = [];\n    this.providers = {};\n    (_this$transport$cache = this.transport.cachedProvider) == null ? void 0 : _this$transport$cache.clearCache();\n  }\n\n}\nconst DefaultProviderConfig = {\n  walletAppURL: 'https://sequence.app',\n  // walletSessionURL: 'https://session.sequence.app',\n  transports: {\n    windowTransport: {\n      enabled: true\n    },\n    proxyTransport: {\n      enabled: false\n    }\n  }\n};\nlet walletInstance;\nconst initWallet = async (network, config) => {\n  if (walletInstance && walletInstance.isOpened()) {\n    walletInstance.closeWallet();\n  }\n\n  walletInstance = new Wallet(network, config);\n  await walletInstance.loadSession();\n  return walletInstance;\n};\nconst getWallet = () => {\n  if (!walletInstance) {\n    throw new Error('Wallet has not been initialized, call sequence.initWallet(network, config) first.');\n  }\n\n  return walletInstance;\n};\n\nexport { BaseInjectedTransport, BaseProviderTransport, BaseWalletTransport, CHANNEL_ID, DefaultProviderConfig, ErrSignedInRequired, EventType, ExtensionMessageHandler, ExtensionMessageProvider, InitState, LocalStorage, LocalStore, LocalWeb3Provider, MuxMessageProvider, OpenState, PROVIDER_OPEN_TIMEOUT, ProviderError, ProxyMessageChannel, ProxyMessageChannelPort, ProxyMessageHandler, ProxyMessageProvider, Wallet, WalletRequestHandler, Web3Provider, Web3Signer, WindowMessageHandler, WindowMessageProvider, WindowSessionParams, getWallet, initWallet, isBrowserExtension, isSequenceProvider, isValidMessageSignature, isValidSignature, isValidTypedDataSignature, isWalletUpToDate, messageToBytes, nextMessageIdx, prefixEIP191Message, recoverWalletConfig };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}