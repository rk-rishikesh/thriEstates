{"ast":null,"code":"import { ethers } from 'ethers';\nimport { Interface } from '@ethersproject/abi';\nimport { walletContracts } from '@0xsequence/abi';\nimport { subDigestOf } from '@0xsequence/utils';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nconst MetaTransactionsType = `tuple(\n  bool delegateCall,\n  bool revertOnError,\n  uint256 gasLimit,\n  address target,\n  uint256 value,\n  bytes data\n)[]`;\n\nfunction packMetaTransactionsData() {\n  for (var _len = arguments.length, txs = new Array(_len), _key = 0; _key < _len; _key++) {\n    txs[_key] = arguments[_key];\n  }\n\n  const nonce = readSequenceNonce(...txs);\n  if (nonce === undefined) throw new Error('Encoding transactions without defined nonce');\n  return packMetaTransactionsNonceData(nonce, ...txs);\n}\n\nfunction packMetaTransactionsNonceData(nonce) {\n  for (var _len2 = arguments.length, txs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    txs[_key2 - 1] = arguments[_key2];\n  }\n\n  return ethers.utils.defaultAbiCoder.encode(['uint256', MetaTransactionsType], [nonce, sequenceTxAbiEncode(txs)]);\n}\n\nfunction digestOfTransactions() {\n  for (var _len3 = arguments.length, txs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    txs[_key3] = arguments[_key3];\n  }\n\n  const nonce = readSequenceNonce(...txs);\n  if (nonce === undefined) throw new Error('Computing hash for transactions without defined nonce');\n  return digestOfTransactionsNonce(nonce, ...txs);\n}\n\nfunction digestOfTransactionsNonce(nonce) {\n  for (var _len4 = arguments.length, txs = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    txs[_key4 - 1] = arguments[_key4];\n  }\n\n  return ethers.utils.keccak256(packMetaTransactionsNonceData(nonce, ...txs));\n}\n\nfunction computeMetaTxnHash(address, chainId) {\n  for (var _len5 = arguments.length, txs = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n    txs[_key5 - 2] = arguments[_key5];\n  }\n\n  return subDigestOf(address, chainId, digestOfTransactions(...txs)).replace(/^0x/, '');\n}\n\nasync function toSequenceTransactions(wallet, txs) {\n  let revertOnError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let gasLimit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ethers.constants.Zero;\n  // Bundles all transactions, including the auxiliary ones\n  const allTxs = flattenAuxTransactions(txs); // Uses the lowest nonce found on TransactionRequest\n  // if there are no nonces, it leaves an undefined nonce\n\n  const nonces = (await Promise.all(txs.map(t => t.nonce))).filter(n => n !== undefined).map(n => ethers.BigNumber.from(n));\n  const nonce = nonces.length !== 0 ? nonces.reduce((p, c) => p.lt(c) ? p : c) : undefined; // Maps all transactions into SequenceTransactions\n\n  return Promise.all(allTxs.map(tx => toSequenceTransaction(wallet, tx, revertOnError, gasLimit, nonce)));\n}\n\nfunction flattenAuxTransactions(txs) {\n  if (!Array.isArray(txs)) return flattenAuxTransactions([txs]);\n  return txs.reduce(function (p, c) {\n    if (Array.isArray(c)) {\n      return p.concat(flattenAuxTransactions(c));\n    }\n\n    if (c.auxiliary) {\n      return p.concat([c, ...flattenAuxTransactions(c.auxiliary)]);\n    }\n\n    return p.concat(c);\n  }, []);\n}\n\nasync function toSequenceTransaction(wallet, tx) {\n  let revertOnError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let gasLimit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ethers.constants.Zero;\n  let nonce = arguments.length > 4 ? arguments[4] : undefined;\n\n  if (isSequenceTransaction(tx)) {\n    return tx;\n  }\n\n  const txGas = tx.gasLimit === undefined ? tx.gas : tx.gasLimit;\n\n  if (tx.to) {\n    return {\n      delegateCall: false,\n      revertOnError: revertOnError,\n      gasLimit: txGas ? await txGas : gasLimit,\n      to: await tx.to,\n      value: tx.value ? await tx.value : 0,\n      data: await tx.data,\n      nonce: nonce ? nonce : await tx.nonce\n    };\n  } else {\n    const walletInterface = new Interface(walletContracts.mainModule.abi);\n    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('createContract'), [tx.data]);\n    const address = typeof wallet === 'string' ? wallet : wallet.getAddress();\n    return {\n      delegateCall: false,\n      revertOnError: revertOnError,\n      gasLimit: txGas ? await txGas : gasLimit,\n      to: await address,\n      value: tx.value ? await tx.value : 0,\n      data: data,\n      nonce: nonce ? nonce : await tx.nonce\n    };\n  }\n}\n\nfunction isAsyncSendable(target) {\n  return target.send || target.sendAsync;\n}\n\nfunction isSequenceTransaction(tx) {\n  return tx.delegateCall !== undefined || tx.revertOnError !== undefined;\n}\n\nfunction hasSequenceTransactions(txs) {\n  return txs.find(t => isSequenceTransaction(t)) !== undefined;\n}\n\nfunction readSequenceNonce() {\n  for (var _len6 = arguments.length, txs = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    txs[_key6] = arguments[_key6];\n  }\n\n  const sample = txs.find(t => t.nonce !== undefined);\n\n  if (!sample) {\n    return undefined;\n  }\n\n  const sampleNonce = ethers.BigNumber.from(sample.nonce);\n\n  if (txs.find(t => t.nonce !== undefined && !ethers.BigNumber.from(t.nonce).eq(sampleNonce))) {\n    throw new Error('Mixed nonces on Sequence transactions');\n  }\n\n  return sample ? sample.nonce : undefined;\n}\n\nfunction sequenceTxAbiEncode(txs) {\n  return txs.map(t => {\n    var _t$to;\n\n    return {\n      delegateCall: t.delegateCall === true,\n      revertOnError: t.revertOnError === true,\n      gasLimit: t.gasLimit !== undefined ? t.gasLimit : ethers.constants.Zero,\n      target: (_t$to = t.to) != null ? _t$to : ethers.constants.AddressZero,\n      value: t.value !== undefined ? t.value : ethers.constants.Zero,\n      data: t.data !== undefined ? t.data : []\n    };\n  });\n}\n\nfunction appendNonce(txs, nonce) {\n  return txs.map(t => _extends({}, t, {\n    nonce\n  }));\n}\n\nfunction makeExpirable(context, txs, expiration) {\n  const sequenceUtils = new Interface(walletContracts.sequenceUtils.abi);\n\n  if (!context || !context.sequenceUtils) {\n    throw new Error('Undefined sequenceUtils');\n  }\n\n  return [{\n    delegateCall: false,\n    revertOnError: true,\n    gasLimit: 0,\n    to: context.sequenceUtils,\n    value: 0,\n    data: sequenceUtils.encodeFunctionData(sequenceUtils.getFunction('requireNonExpired'), [expiration])\n  }, ...txs];\n}\n\nfunction makeAfterNonce(context, txs, dep) {\n  const sequenceUtils = new Interface(walletContracts.sequenceUtils.abi);\n\n  if (!context || !context.sequenceUtils) {\n    throw new Error('Undefined sequenceUtils');\n  }\n\n  return [{\n    delegateCall: false,\n    revertOnError: true,\n    gasLimit: 0,\n    to: context.sequenceUtils,\n    value: 0,\n    data: sequenceUtils.encodeFunctionData(sequenceUtils.getFunction('requireMinNonce'), [dep.address, dep.space ? encodeNonce(dep.space, dep.nonce) : dep.nonce])\n  }, ...txs];\n}\n\nfunction encodeNonce(space, nonce) {\n  const bspace = ethers.BigNumber.from(space);\n  const bnonce = ethers.BigNumber.from(nonce);\n  const shl = ethers.constants.Two.pow(ethers.BigNumber.from(96));\n\n  if (!bnonce.div(shl).eq(ethers.constants.Zero)) {\n    throw new Error('Space already encoded');\n  }\n\n  return bnonce.add(bspace.mul(shl));\n}\n\nfunction decodeNonce(nonce) {\n  const bnonce = ethers.BigNumber.from(nonce);\n  const shr = ethers.constants.Two.pow(ethers.BigNumber.from(96));\n  return [bnonce.div(shr), bnonce.mod(shr)];\n}\n\nfunction isSignedTransactions(cand) {\n  return cand !== undefined && cand.chainId !== undefined && cand.config !== undefined && cand.context !== undefined && cand.signature !== undefined && cand.transactions !== undefined && Array.isArray(cand.transactions) && cand.transactions.reduce((p, c) => p && isSequenceTransaction(c), true);\n}\n\nasync function fromTransactionish(context, wallet, transaction) {\n  let stx = [];\n\n  if (Array.isArray(transaction)) {\n    if (hasSequenceTransactions(transaction)) {\n      stx = transaction;\n    } else {\n      stx = await toSequenceTransactions(wallet, transaction);\n    }\n  } else if (isSequenceTransaction(transaction)) {\n    stx = [transaction];\n  } else {\n    stx = await toSequenceTransactions(wallet, [transaction]);\n  } // If transaction is marked as expirable\n  // append expirable require\n\n\n  if (transaction.expiration) {\n    stx = makeExpirable(context, stx, transaction.expiration);\n  } // If transaction depends on another nonce\n  // append after nonce requirement\n\n\n  if (transaction.afterNonce) {\n    const after = transaction.afterNonce;\n    stx = makeAfterNonce(context, stx, after.address ? {\n      address: after.address,\n      nonce: after.nonce,\n      space: after.space\n    } : {\n      address: wallet,\n      nonce: after\n    });\n  }\n\n  return stx;\n}\n\nexport { MetaTransactionsType, appendNonce, computeMetaTxnHash, decodeNonce, digestOfTransactions, digestOfTransactionsNonce, encodeNonce, flattenAuxTransactions, fromTransactionish, hasSequenceTransactions, isAsyncSendable, isSequenceTransaction, isSignedTransactions, makeAfterNonce, makeExpirable, packMetaTransactionsData, packMetaTransactionsNonceData, readSequenceNonce, sequenceTxAbiEncode, toSequenceTransaction, toSequenceTransactions };","map":{"version":3,"names":["ethers","Interface","walletContracts","subDigestOf","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","MetaTransactionsType","packMetaTransactionsData","txs","nonce","readSequenceNonce","undefined","Error","packMetaTransactionsNonceData","utils","defaultAbiCoder","encode","sequenceTxAbiEncode","digestOfTransactions","digestOfTransactionsNonce","keccak256","computeMetaTxnHash","address","chainId","replace","toSequenceTransactions","wallet","revertOnError","gasLimit","constants","Zero","allTxs","flattenAuxTransactions","nonces","Promise","all","map","t","filter","n","BigNumber","from","reduce","p","c","lt","tx","toSequenceTransaction","Array","isArray","concat","auxiliary","isSequenceTransaction","txGas","gas","to","delegateCall","value","data","walletInterface","mainModule","abi","encodeFunctionData","getFunction","getAddress","isAsyncSendable","send","sendAsync","hasSequenceTransactions","find","sample","sampleNonce","eq","_t$to","AddressZero","appendNonce","makeExpirable","context","expiration","sequenceUtils","makeAfterNonce","dep","space","encodeNonce","bspace","bnonce","shl","Two","pow","div","add","mul","decodeNonce","shr","mod","isSignedTransactions","cand","config","signature","transactions","fromTransactionish","transaction","stx","afterNonce","after"],"sources":["C:/Users/rishi/contract-poc/ThriEstate/Brandvilla/node_modules/@0xsequence/transactions/dist/0xsequence-transactions.esm.js"],"sourcesContent":["import { ethers } from 'ethers';\nimport { Interface } from '@ethersproject/abi';\nimport { walletContracts } from '@0xsequence/abi';\nimport { subDigestOf } from '@0xsequence/utils';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nconst MetaTransactionsType = `tuple(\n  bool delegateCall,\n  bool revertOnError,\n  uint256 gasLimit,\n  address target,\n  uint256 value,\n  bytes data\n)[]`;\nfunction packMetaTransactionsData(...txs) {\n  const nonce = readSequenceNonce(...txs);\n  if (nonce === undefined) throw new Error('Encoding transactions without defined nonce');\n  return packMetaTransactionsNonceData(nonce, ...txs);\n}\nfunction packMetaTransactionsNonceData(nonce, ...txs) {\n  return ethers.utils.defaultAbiCoder.encode(['uint256', MetaTransactionsType], [nonce, sequenceTxAbiEncode(txs)]);\n}\nfunction digestOfTransactions(...txs) {\n  const nonce = readSequenceNonce(...txs);\n  if (nonce === undefined) throw new Error('Computing hash for transactions without defined nonce');\n  return digestOfTransactionsNonce(nonce, ...txs);\n}\nfunction digestOfTransactionsNonce(nonce, ...txs) {\n  return ethers.utils.keccak256(packMetaTransactionsNonceData(nonce, ...txs));\n}\nfunction computeMetaTxnHash(address, chainId, ...txs) {\n  return subDigestOf(address, chainId, digestOfTransactions(...txs)).replace(/^0x/, '');\n}\nasync function toSequenceTransactions(wallet, txs, revertOnError = false, gasLimit = ethers.constants.Zero) {\n  // Bundles all transactions, including the auxiliary ones\n  const allTxs = flattenAuxTransactions(txs); // Uses the lowest nonce found on TransactionRequest\n  // if there are no nonces, it leaves an undefined nonce\n\n  const nonces = (await Promise.all(txs.map(t => t.nonce))).filter(n => n !== undefined).map(n => ethers.BigNumber.from(n));\n  const nonce = nonces.length !== 0 ? nonces.reduce((p, c) => p.lt(c) ? p : c) : undefined; // Maps all transactions into SequenceTransactions\n\n  return Promise.all(allTxs.map(tx => toSequenceTransaction(wallet, tx, revertOnError, gasLimit, nonce)));\n}\nfunction flattenAuxTransactions(txs) {\n  if (!Array.isArray(txs)) return flattenAuxTransactions([txs]);\n  return txs.reduce(function (p, c) {\n    if (Array.isArray(c)) {\n      return p.concat(flattenAuxTransactions(c));\n    }\n\n    if (c.auxiliary) {\n      return p.concat([c, ...flattenAuxTransactions(c.auxiliary)]);\n    }\n\n    return p.concat(c);\n  }, []);\n}\nasync function toSequenceTransaction(wallet, tx, revertOnError = false, gasLimit = ethers.constants.Zero, nonce) {\n  if (isSequenceTransaction(tx)) {\n    return tx;\n  }\n\n  const txGas = tx.gasLimit === undefined ? tx.gas : tx.gasLimit;\n\n  if (tx.to) {\n    return {\n      delegateCall: false,\n      revertOnError: revertOnError,\n      gasLimit: txGas ? await txGas : gasLimit,\n      to: await tx.to,\n      value: tx.value ? await tx.value : 0,\n      data: await tx.data,\n      nonce: nonce ? nonce : await tx.nonce\n    };\n  } else {\n    const walletInterface = new Interface(walletContracts.mainModule.abi);\n    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('createContract'), [tx.data]);\n    const address = typeof wallet === 'string' ? wallet : wallet.getAddress();\n    return {\n      delegateCall: false,\n      revertOnError: revertOnError,\n      gasLimit: txGas ? await txGas : gasLimit,\n      to: await address,\n      value: tx.value ? await tx.value : 0,\n      data: data,\n      nonce: nonce ? nonce : await tx.nonce\n    };\n  }\n}\nfunction isAsyncSendable(target) {\n  return target.send || target.sendAsync;\n}\nfunction isSequenceTransaction(tx) {\n  return tx.delegateCall !== undefined || tx.revertOnError !== undefined;\n}\nfunction hasSequenceTransactions(txs) {\n  return txs.find(t => isSequenceTransaction(t)) !== undefined;\n}\nfunction readSequenceNonce(...txs) {\n  const sample = txs.find(t => t.nonce !== undefined);\n\n  if (!sample) {\n    return undefined;\n  }\n\n  const sampleNonce = ethers.BigNumber.from(sample.nonce);\n\n  if (txs.find(t => t.nonce !== undefined && !ethers.BigNumber.from(t.nonce).eq(sampleNonce))) {\n    throw new Error('Mixed nonces on Sequence transactions');\n  }\n\n  return sample ? sample.nonce : undefined;\n}\nfunction sequenceTxAbiEncode(txs) {\n  return txs.map(t => {\n    var _t$to;\n\n    return {\n      delegateCall: t.delegateCall === true,\n      revertOnError: t.revertOnError === true,\n      gasLimit: t.gasLimit !== undefined ? t.gasLimit : ethers.constants.Zero,\n      target: (_t$to = t.to) != null ? _t$to : ethers.constants.AddressZero,\n      value: t.value !== undefined ? t.value : ethers.constants.Zero,\n      data: t.data !== undefined ? t.data : []\n    };\n  });\n}\nfunction appendNonce(txs, nonce) {\n  return txs.map(t => _extends({}, t, {\n    nonce\n  }));\n}\nfunction makeExpirable(context, txs, expiration) {\n  const sequenceUtils = new Interface(walletContracts.sequenceUtils.abi);\n\n  if (!context || !context.sequenceUtils) {\n    throw new Error('Undefined sequenceUtils');\n  }\n\n  return [{\n    delegateCall: false,\n    revertOnError: true,\n    gasLimit: 0,\n    to: context.sequenceUtils,\n    value: 0,\n    data: sequenceUtils.encodeFunctionData(sequenceUtils.getFunction('requireNonExpired'), [expiration])\n  }, ...txs];\n}\nfunction makeAfterNonce(context, txs, dep) {\n  const sequenceUtils = new Interface(walletContracts.sequenceUtils.abi);\n\n  if (!context || !context.sequenceUtils) {\n    throw new Error('Undefined sequenceUtils');\n  }\n\n  return [{\n    delegateCall: false,\n    revertOnError: true,\n    gasLimit: 0,\n    to: context.sequenceUtils,\n    value: 0,\n    data: sequenceUtils.encodeFunctionData(sequenceUtils.getFunction('requireMinNonce'), [dep.address, dep.space ? encodeNonce(dep.space, dep.nonce) : dep.nonce])\n  }, ...txs];\n}\nfunction encodeNonce(space, nonce) {\n  const bspace = ethers.BigNumber.from(space);\n  const bnonce = ethers.BigNumber.from(nonce);\n  const shl = ethers.constants.Two.pow(ethers.BigNumber.from(96));\n\n  if (!bnonce.div(shl).eq(ethers.constants.Zero)) {\n    throw new Error('Space already encoded');\n  }\n\n  return bnonce.add(bspace.mul(shl));\n}\nfunction decodeNonce(nonce) {\n  const bnonce = ethers.BigNumber.from(nonce);\n  const shr = ethers.constants.Two.pow(ethers.BigNumber.from(96));\n  return [bnonce.div(shr), bnonce.mod(shr)];\n}\nfunction isSignedTransactions(cand) {\n  return cand !== undefined && cand.chainId !== undefined && cand.config !== undefined && cand.context !== undefined && cand.signature !== undefined && cand.transactions !== undefined && Array.isArray(cand.transactions) && cand.transactions.reduce((p, c) => p && isSequenceTransaction(c), true);\n}\nasync function fromTransactionish(context, wallet, transaction) {\n  let stx = [];\n\n  if (Array.isArray(transaction)) {\n    if (hasSequenceTransactions(transaction)) {\n      stx = transaction;\n    } else {\n      stx = await toSequenceTransactions(wallet, transaction);\n    }\n  } else if (isSequenceTransaction(transaction)) {\n    stx = [transaction];\n  } else {\n    stx = await toSequenceTransactions(wallet, [transaction]);\n  } // If transaction is marked as expirable\n  // append expirable require\n\n\n  if (transaction.expiration) {\n    stx = makeExpirable(context, stx, transaction.expiration);\n  } // If transaction depends on another nonce\n  // append after nonce requirement\n\n\n  if (transaction.afterNonce) {\n    const after = transaction.afterNonce;\n    stx = makeAfterNonce(context, stx, after.address ? {\n      address: after.address,\n      nonce: after.nonce,\n      space: after.space\n    } : {\n      address: wallet,\n      nonce: after\n    });\n  }\n\n  return stx;\n}\n\nexport { MetaTransactionsType, appendNonce, computeMetaTxnHash, decodeNonce, digestOfTransactions, digestOfTransactionsNonce, encodeNonce, flattenAuxTransactions, fromTransactionish, hasSequenceTransactions, isAsyncSendable, isSequenceTransaction, isSignedTransactions, makeAfterNonce, makeExpirable, packMetaTransactionsData, packMetaTransactionsNonceData, readSequenceNonce, sequenceTxAbiEncode, toSequenceTransaction, toSequenceTransactions };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}