{"ast":null,"code":"/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;\n!function (undefined) {\n  var hasOwnProperty = Object.hasOwnProperty;\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n  var nextTickSupported = typeof process == 'object' && typeof process.nextTick == 'function';\n  var symbolsSupported = typeof Symbol === 'function';\n  var reflectSupported = typeof Reflect === 'object';\n  var setImmediateSupported = typeof setImmediate === 'function';\n\n  var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;\n\n  var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === 'function' ? Reflect.ownKeys : function (obj) {\n    var arr = Object.getOwnPropertyNames(obj);\n    arr.push.apply(arr, Object.getOwnPropertySymbols(obj));\n    return arr;\n  } : Object.keys;\n\n  function init() {\n    this._events = {};\n\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n      this._conf = conf;\n      conf.delimiter && (this.delimiter = conf.delimiter);\n\n      if (conf.maxListeners !== undefined) {\n        this._maxListeners = conf.maxListeners;\n      }\n\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this._newListener = conf.newListener);\n      conf.removeListener && (this._removeListener = conf.removeListener);\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\n      conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function logPossibleMemoryLeak(count, eventName) {\n    var errorMsg = '(node) warning: possible EventEmitter memory ' + 'leak detected. ' + count + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.';\n\n    if (this.verboseMemoryLeak) {\n      errorMsg += ' Event name: ' + eventName + '.';\n    }\n\n    if (typeof process !== 'undefined' && process.emitWarning) {\n      var e = new Error(errorMsg);\n      e.name = 'MaxListenersExceededWarning';\n      e.emitter = this;\n      e.count = count;\n      process.emitWarning(e);\n    } else {\n      console.error(errorMsg);\n\n      if (console.trace) {\n        console.trace();\n      }\n    }\n  }\n\n  var toArray = function (a, b, c) {\n    var n = arguments.length;\n\n    switch (n) {\n      case 0:\n        return [];\n\n      case 1:\n        return [a];\n\n      case 2:\n        return [a, b];\n\n      case 3:\n        return [a, b, c];\n\n      default:\n        var arr = new Array(n);\n\n        while (n--) {\n          arr[n] = arguments[n];\n        }\n\n        return arr;\n    }\n  };\n\n  function toObject(keys, values) {\n    var obj = {};\n    var key;\n    var len = keys.length;\n    var valuesCount = values ? values.length : 0;\n\n    for (var i = 0; i < len; i++) {\n      key = keys[i];\n      obj[key] = i < valuesCount ? values[i] : undefined;\n    }\n\n    return obj;\n  }\n\n  function TargetObserver(emitter, target, options) {\n    this._emitter = emitter;\n    this._target = target;\n    this._listeners = {};\n    this._listenersCount = 0;\n    var on, off;\n\n    if (options.on || options.off) {\n      on = options.on;\n      off = options.off;\n    }\n\n    if (target.addEventListener) {\n      on = target.addEventListener;\n      off = target.removeEventListener;\n    } else if (target.addListener) {\n      on = target.addListener;\n      off = target.removeListener;\n    } else if (target.on) {\n      on = target.on;\n      off = target.off;\n    }\n\n    if (!on && !off) {\n      throw Error('target does not implement any known event API');\n    }\n\n    if (typeof on !== 'function') {\n      throw TypeError('on method must be a function');\n    }\n\n    if (typeof off !== 'function') {\n      throw TypeError('off method must be a function');\n    }\n\n    this._on = on;\n    this._off = off;\n    var _observers = emitter._observers;\n\n    if (_observers) {\n      _observers.push(this);\n    } else {\n      emitter._observers = [this];\n    }\n  }\n\n  Object.assign(TargetObserver.prototype, {\n    subscribe: function (event, localEvent, reducer) {\n      var observer = this;\n      var target = this._target;\n      var emitter = this._emitter;\n      var listeners = this._listeners;\n\n      var handler = function () {\n        var args = toArray.apply(null, arguments);\n        var eventObj = {\n          data: args,\n          name: localEvent,\n          original: event\n        };\n\n        if (reducer) {\n          var result = reducer.call(target, eventObj);\n\n          if (result !== false) {\n            emitter.emit.apply(emitter, [eventObj.name].concat(args));\n          }\n\n          return;\n        }\n\n        emitter.emit.apply(emitter, [localEvent].concat(args));\n      };\n\n      if (listeners[event]) {\n        throw Error('Event \\'' + event + '\\' is already listening');\n      }\n\n      this._listenersCount++;\n\n      if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {\n        this._onNewListener = function (_event) {\n          if (_event === localEvent && listeners[event] === null) {\n            listeners[event] = handler;\n\n            observer._on.call(target, event, handler);\n          }\n        };\n\n        emitter.on('newListener', this._onNewListener);\n\n        this._onRemoveListener = function (_event) {\n          if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {\n            listeners[event] = null;\n\n            observer._off.call(target, event, handler);\n          }\n        };\n\n        listeners[event] = null;\n        emitter.on('removeListener', this._onRemoveListener);\n      } else {\n        listeners[event] = handler;\n\n        observer._on.call(target, event, handler);\n      }\n    },\n    unsubscribe: function (event) {\n      var observer = this;\n      var listeners = this._listeners;\n      var emitter = this._emitter;\n      var handler;\n      var events;\n      var off = this._off;\n      var target = this._target;\n      var i;\n\n      if (event && typeof event !== 'string') {\n        throw TypeError('event must be a string');\n      }\n\n      function clearRefs() {\n        if (observer._onNewListener) {\n          emitter.off('newListener', observer._onNewListener);\n          emitter.off('removeListener', observer._onRemoveListener);\n          observer._onNewListener = null;\n          observer._onRemoveListener = null;\n        }\n\n        var index = findTargetIndex.call(emitter, observer);\n\n        emitter._observers.splice(index, 1);\n      }\n\n      if (event) {\n        handler = listeners[event];\n        if (!handler) return;\n        off.call(target, event, handler);\n        delete listeners[event];\n\n        if (! --this._listenersCount) {\n          clearRefs();\n        }\n      } else {\n        events = ownKeys(listeners);\n        i = events.length;\n\n        while (i-- > 0) {\n          event = events[i];\n          off.call(target, event, listeners[event]);\n        }\n\n        this._listeners = {};\n        this._listenersCount = 0;\n        clearRefs();\n      }\n    }\n  });\n\n  function resolveOptions(options, schema, reducers, allowUnknown) {\n    var computedOptions = Object.assign({}, schema);\n    if (!options) return computedOptions;\n\n    if (typeof options !== 'object') {\n      throw TypeError('options must be an object');\n    }\n\n    var keys = Object.keys(options);\n    var length = keys.length;\n    var option, value;\n    var reducer;\n\n    function reject(reason) {\n      throw Error('Invalid \"' + option + '\" option value' + (reason ? '. Reason: ' + reason : ''));\n    }\n\n    for (var i = 0; i < length; i++) {\n      option = keys[i];\n\n      if (!allowUnknown && !hasOwnProperty.call(schema, option)) {\n        throw Error('Unknown \"' + option + '\" option');\n      }\n\n      value = options[option];\n\n      if (value !== undefined) {\n        reducer = reducers[option];\n        computedOptions[option] = reducer ? reducer(value, reject) : value;\n      }\n    }\n\n    return computedOptions;\n  }\n\n  function constructorReducer(value, reject) {\n    if (typeof value !== 'function' || !value.hasOwnProperty('prototype')) {\n      reject('value must be a constructor');\n    }\n\n    return value;\n  }\n\n  function makeTypeReducer(types) {\n    var message = 'value must be type of ' + types.join('|');\n    var len = types.length;\n    var firstType = types[0];\n    var secondType = types[1];\n\n    if (len === 1) {\n      return function (v, reject) {\n        if (typeof v === firstType) {\n          return v;\n        }\n\n        reject(message);\n      };\n    }\n\n    if (len === 2) {\n      return function (v, reject) {\n        var kind = typeof v;\n        if (kind === firstType || kind === secondType) return v;\n        reject(message);\n      };\n    }\n\n    return function (v, reject) {\n      var kind = typeof v;\n      var i = len;\n\n      while (i-- > 0) {\n        if (kind === types[i]) return v;\n      }\n\n      reject(message);\n    };\n  }\n\n  var functionReducer = makeTypeReducer(['function']);\n  var objectFunctionReducer = makeTypeReducer(['object', 'function']);\n\n  function makeCancelablePromise(Promise, executor, options) {\n    var isCancelable;\n    var callbacks;\n    var timer = 0;\n    var subscriptionClosed;\n    var promise = new Promise(function (resolve, reject, onCancel) {\n      options = resolveOptions(options, {\n        timeout: 0,\n        overload: false\n      }, {\n        timeout: function (value, reject) {\n          value *= 1;\n\n          if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {\n            reject('timeout must be a positive number');\n          }\n\n          return value;\n        }\n      });\n      isCancelable = !options.overload && typeof Promise.prototype.cancel === 'function' && typeof onCancel === 'function';\n\n      function cleanup() {\n        if (callbacks) {\n          callbacks = null;\n        }\n\n        if (timer) {\n          clearTimeout(timer);\n          timer = 0;\n        }\n      }\n\n      var _resolve = function (value) {\n        cleanup();\n        resolve(value);\n      };\n\n      var _reject = function (err) {\n        cleanup();\n        reject(err);\n      };\n\n      if (isCancelable) {\n        executor(_resolve, _reject, onCancel);\n      } else {\n        callbacks = [function (reason) {\n          _reject(reason || Error('canceled'));\n        }];\n        executor(_resolve, _reject, function (cb) {\n          if (subscriptionClosed) {\n            throw Error('Unable to subscribe on cancel event asynchronously');\n          }\n\n          if (typeof cb !== 'function') {\n            throw TypeError('onCancel callback must be a function');\n          }\n\n          callbacks.push(cb);\n        });\n        subscriptionClosed = true;\n      }\n\n      if (options.timeout > 0) {\n        timer = setTimeout(function () {\n          var reason = Error('timeout');\n          reason.code = 'ETIMEDOUT';\n          timer = 0;\n          promise.cancel(reason);\n          reject(reason);\n        }, options.timeout);\n      }\n    });\n\n    if (!isCancelable) {\n      promise.cancel = function (reason) {\n        if (!callbacks) {\n          return;\n        }\n\n        var length = callbacks.length;\n\n        for (var i = 1; i < length; i++) {\n          callbacks[i](reason);\n        } // internal callback to reject the promise\n\n\n        callbacks[0](reason);\n        callbacks = null;\n      };\n    }\n\n    return promise;\n  }\n\n  function findTargetIndex(observer) {\n    var observers = this._observers;\n\n    if (!observers) {\n      return -1;\n    }\n\n    var len = observers.length;\n\n    for (var i = 0; i < len; i++) {\n      if (observers[i]._target === observer) return i;\n    }\n\n    return -1;\n  } // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n\n\n  function searchListenerTree(handlers, type, tree, i, typeLength) {\n    if (!tree) {\n      return null;\n    }\n\n    if (i === 0) {\n      var kind = typeof type;\n\n      if (kind === 'string') {\n        var ns,\n            n,\n            l = 0,\n            j = 0,\n            delimiter = this.delimiter,\n            dl = delimiter.length;\n\n        if ((n = type.indexOf(delimiter)) !== -1) {\n          ns = new Array(5);\n\n          do {\n            ns[l++] = type.slice(j, n);\n            j = n + dl;\n          } while ((n = type.indexOf(delimiter, j)) !== -1);\n\n          ns[l++] = type.slice(j);\n          type = ns;\n          typeLength = l;\n        } else {\n          type = [type];\n          typeLength = 1;\n        }\n      } else if (kind === 'object') {\n        typeLength = type.length;\n      } else {\n        type = [type];\n        typeLength = 1;\n      }\n    }\n\n    var listeners = null,\n        branch,\n        xTree,\n        xxTree,\n        isolatedBranch,\n        endReached,\n        currentType = type[i],\n        nextType = type[i + 1],\n        branches,\n        _listeners;\n\n    if (i === typeLength) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n      if (tree._listeners) {\n        if (typeof tree._listeners === 'function') {\n          handlers && handlers.push(tree._listeners);\n          listeners = [tree];\n        } else {\n          handlers && handlers.push.apply(handlers, tree._listeners);\n          listeners = [tree];\n        }\n      }\n    } else {\n      if (currentType === '*') {\n        //\n        // If the event emitted is '*' at this part\n        // or there is a concrete match at this patch\n        //\n        branches = ownKeys(tree);\n        n = branches.length;\n\n        while (n-- > 0) {\n          branch = branches[n];\n\n          if (branch !== '_listeners') {\n            _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);\n\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n\n        return listeners;\n      } else if (currentType === '**') {\n        endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === '*';\n\n        if (endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);\n        }\n\n        branches = ownKeys(tree);\n        n = branches.length;\n\n        while (n-- > 0) {\n          branch = branches[n];\n\n          if (branch !== '_listeners') {\n            if (branch === '*' || branch === '**') {\n              if (tree[branch]._listeners && !endReached) {\n                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);\n\n                if (_listeners) {\n                  if (listeners) {\n                    listeners.push.apply(listeners, _listeners);\n                  } else {\n                    listeners = _listeners;\n                  }\n                }\n              }\n\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            } else if (branch === nextType) {\n              _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            }\n\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n\n        return listeners;\n      } else if (tree[currentType]) {\n        listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);\n      }\n    }\n\n    xTree = tree['*'];\n\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i + 1, typeLength);\n    }\n\n    xxTree = tree['**'];\n\n    if (xxTree) {\n      if (i < typeLength) {\n        if (xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n        } // Build arrays of matching next branches and others.\n\n\n        branches = ownKeys(xxTree);\n        n = branches.length;\n\n        while (n-- > 0) {\n          branch = branches[n];\n\n          if (branch !== '_listeners') {\n            if (branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);\n            } else if (branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, {\n                '**': isolatedBranch\n              }, i + 1, typeLength);\n            }\n          }\n        }\n      } else if (xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n      } else if (xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength, typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener, prepend) {\n    var len = 0,\n        j = 0,\n        i,\n        delimiter = this.delimiter,\n        dl = delimiter.length,\n        ns;\n\n    if (typeof type === 'string') {\n      if ((i = type.indexOf(delimiter)) !== -1) {\n        ns = new Array(5);\n\n        do {\n          ns[len++] = type.slice(j, i);\n          j = i + dl;\n        } while ((i = type.indexOf(delimiter, j)) !== -1);\n\n        ns[len++] = type.slice(j);\n      } else {\n        ns = [type];\n        len = 1;\n      }\n    } else {\n      ns = type;\n      len = type.length;\n    } //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n\n\n    if (len > 1) {\n      for (i = 0; i + 1 < len; i++) {\n        if (ns[i] === '**' && ns[i + 1] === '**') {\n          return;\n        }\n      }\n    }\n\n    var tree = this.listenerTree,\n        name;\n\n    for (i = 0; i < len; i++) {\n      name = ns[i];\n      tree = tree[name] || (tree[name] = {});\n\n      if (i === len - 1) {\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        } else {\n          if (typeof tree._listeners === 'function') {\n            tree._listeners = [tree._listeners];\n          }\n\n          if (prepend) {\n            tree._listeners.unshift(listener);\n          } else {\n            tree._listeners.push(listener);\n          }\n\n          if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {\n            tree._listeners.warned = true;\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  function collectTreeEvents(tree, events, root, asArray) {\n    var branches = ownKeys(tree);\n    var i = branches.length;\n    var branch, branchName, path;\n    var hasListeners = tree['_listeners'];\n    var isArrayPath;\n\n    while (i-- > 0) {\n      branchName = branches[i];\n      branch = tree[branchName];\n\n      if (branchName === '_listeners') {\n        path = root;\n      } else {\n        path = root ? root.concat(branchName) : [branchName];\n      }\n\n      isArrayPath = asArray || typeof branchName === 'symbol';\n      hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));\n\n      if (typeof branch === 'object') {\n        collectTreeEvents.call(this, branch, events, path, isArrayPath);\n      }\n    }\n\n    return events;\n  }\n\n  function recursivelyGarbageCollect(root) {\n    var keys = ownKeys(root);\n    var i = keys.length;\n    var obj, key, flag;\n\n    while (i-- > 0) {\n      key = keys[i];\n      obj = root[key];\n\n      if (obj) {\n        flag = true;\n\n        if (key !== '_listeners' && !recursivelyGarbageCollect(obj)) {\n          delete root[key];\n        }\n      }\n    }\n\n    return flag;\n  }\n\n  function Listener(emitter, event, listener) {\n    this.emitter = emitter;\n    this.event = event;\n    this.listener = listener;\n  }\n\n  Listener.prototype.off = function () {\n    this.emitter.off(this.event, this.listener);\n    return this;\n  };\n\n  function setupListener(event, listener, options) {\n    if (options === true) {\n      promisify = true;\n    } else if (options === false) {\n      async = true;\n    } else {\n      if (!options || typeof options !== 'object') {\n        throw TypeError('options should be an object or true');\n      }\n\n      var async = options.async;\n      var promisify = options.promisify;\n      var nextTick = options.nextTick;\n      var objectify = options.objectify;\n    }\n\n    if (async || nextTick || promisify) {\n      var _listener = listener;\n\n      var _origin = listener._origin || listener;\n\n      if (nextTick && !nextTickSupported) {\n        throw Error('process.nextTick is not supported');\n      }\n\n      if (promisify === undefined) {\n        promisify = listener.constructor.name === 'AsyncFunction';\n      }\n\n      listener = function () {\n        var args = arguments;\n        var context = this;\n        var event = this.event;\n        return promisify ? nextTick ? Promise.resolve() : new Promise(function (resolve) {\n          _setImmediate(resolve);\n        }).then(function () {\n          context.event = event;\n          return _listener.apply(context, args);\n        }) : (nextTick ? process.nextTick : _setImmediate)(function () {\n          context.event = event;\n\n          _listener.apply(context, args);\n        });\n      };\n\n      listener._async = true;\n      listener._origin = _origin;\n    }\n\n    return [listener, objectify ? new Listener(this, event, listener) : this];\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this._newListener = false;\n    this._removeListener = false;\n    this.verboseMemoryLeak = false;\n    configure.call(this, conf);\n  }\n\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\n\n  EventEmitter.prototype.listenTo = function (target, events, options) {\n    if (typeof target !== 'object') {\n      throw TypeError('target musts be an object');\n    }\n\n    var emitter = this;\n    options = resolveOptions(options, {\n      on: undefined,\n      off: undefined,\n      reducers: undefined\n    }, {\n      on: functionReducer,\n      off: functionReducer,\n      reducers: objectFunctionReducer\n    });\n\n    function listen(events) {\n      if (typeof events !== 'object') {\n        throw TypeError('events must be an object');\n      }\n\n      var reducers = options.reducers;\n      var index = findTargetIndex.call(emitter, target);\n      var observer;\n\n      if (index === -1) {\n        observer = new TargetObserver(emitter, target, options);\n      } else {\n        observer = emitter._observers[index];\n      }\n\n      var keys = ownKeys(events);\n      var len = keys.length;\n      var event;\n      var isSingleReducer = typeof reducers === 'function';\n\n      for (var i = 0; i < len; i++) {\n        event = keys[i];\n        observer.subscribe(event, events[event] || event, isSingleReducer ? reducers : reducers && reducers[event]);\n      }\n    }\n\n    isArray(events) ? listen(toObject(events)) : typeof events === 'string' ? listen(toObject(events.split(/\\s+/))) : listen(events);\n    return this;\n  };\n\n  EventEmitter.prototype.stopListeningTo = function (target, event) {\n    var observers = this._observers;\n\n    if (!observers) {\n      return false;\n    }\n\n    var i = observers.length;\n    var observer;\n    var matched = false;\n\n    if (target && typeof target !== 'object') {\n      throw TypeError('target should be an object');\n    }\n\n    while (i-- > 0) {\n      observer = observers[i];\n\n      if (!target || observer._target === target) {\n        observer.unsubscribe(event);\n        matched = true;\n      }\n    }\n\n    return matched;\n  }; // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function (n) {\n    if (n !== undefined) {\n      this._maxListeners = n;\n      if (!this._conf) this._conf = {};\n      this._conf.maxListeners = n;\n    }\n  };\n\n  EventEmitter.prototype.getMaxListeners = function () {\n    return this._maxListeners;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function (event, fn, options) {\n    return this._once(event, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependOnceListener = function (event, fn, options) {\n    return this._once(event, fn, true, options);\n  };\n\n  EventEmitter.prototype._once = function (event, fn, prepend, options) {\n    return this._many(event, 1, fn, prepend, options);\n  };\n\n  EventEmitter.prototype.many = function (event, ttl, fn, options) {\n    return this._many(event, ttl, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependMany = function (event, ttl, fn, options) {\n    return this._many(event, ttl, fn, true, options);\n  };\n\n  EventEmitter.prototype._many = function (event, ttl, fn, prepend, options) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n\n      return fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n    return this._on(event, listener, prepend, options);\n  };\n\n  EventEmitter.prototype.emit = function () {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n    var type = arguments[0],\n        ns,\n        wildcard = this.wildcard;\n    var args, l, i, j, containsSymbol;\n\n    if (type === 'newListener' && !this._newListener) {\n      if (!this._events.newListener) {\n        return false;\n      }\n    }\n\n    if (wildcard) {\n      ns = type;\n\n      if (type !== 'newListener' && type !== 'removeListener') {\n        if (typeof type === 'object') {\n          l = type.length;\n\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var al = arguments.length;\n    var handler;\n\n    if (this._all && this._all.length) {\n      handler = this._all.slice();\n\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n\n        switch (al) {\n          case 1:\n            handler[i].call(this, type);\n            break;\n\n          case 2:\n            handler[i].call(this, type, arguments[1]);\n            break;\n\n          case 3:\n            handler[i].call(this, type, arguments[1], arguments[2]);\n            break;\n\n          default:\n            handler[i].apply(this, arguments);\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);\n    } else {\n      handler = this._events[type];\n\n      if (typeof handler === 'function') {\n        this.event = type;\n\n        switch (al) {\n          case 1:\n            handler.call(this);\n            break;\n\n          case 2:\n            handler.call(this, arguments[1]);\n            break;\n\n          case 3:\n            handler.call(this, arguments[1], arguments[2]);\n            break;\n\n          default:\n            args = new Array(al - 1);\n\n            for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n\n            handler.apply(this, args);\n        }\n\n        return true;\n      } else if (handler) {\n        // need to make copy of handlers because list can change in the middle\n        // of emit call\n        handler = handler.slice();\n      }\n    }\n\n    if (handler && handler.length) {\n      if (al > 3) {\n        args = new Array(al - 1);\n\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n\n        switch (al) {\n          case 1:\n            handler[i].call(this);\n            break;\n\n          case 2:\n            handler[i].call(this, arguments[1]);\n            break;\n\n          case 3:\n            handler[i].call(this, arguments[1], arguments[2]);\n            break;\n\n          default:\n            handler[i].apply(this, args);\n        }\n      }\n\n      return true;\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return !!this._all;\n  };\n\n  EventEmitter.prototype.emitAsync = function () {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n    var type = arguments[0],\n        wildcard = this.wildcard,\n        ns,\n        containsSymbol;\n    var args, l, i, j;\n\n    if (type === 'newListener' && !this._newListener) {\n      if (!this._events.newListener) {\n        return Promise.resolve([false]);\n      }\n    }\n\n    if (wildcard) {\n      ns = type;\n\n      if (type !== 'newListener' && type !== 'removeListener') {\n        if (typeof type === 'object') {\n          l = type.length;\n\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var promises = [];\n    var al = arguments.length;\n    var handler;\n\n    if (this._all) {\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n\n        switch (al) {\n          case 1:\n            promises.push(this._all[i].call(this, type));\n            break;\n\n          case 2:\n            promises.push(this._all[i].call(this, type, arguments[1]));\n            break;\n\n          case 3:\n            promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\n            break;\n\n          default:\n            promises.push(this._all[i].apply(this, arguments));\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n\n      switch (al) {\n        case 1:\n          promises.push(handler.call(this));\n          break;\n\n        case 2:\n          promises.push(handler.call(this, arguments[1]));\n          break;\n\n        case 3:\n          promises.push(handler.call(this, arguments[1], arguments[2]));\n          break;\n\n        default:\n          args = new Array(al - 1);\n\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n\n          promises.push(handler.apply(this, args));\n      }\n    } else if (handler && handler.length) {\n      handler = handler.slice();\n\n      if (al > 3) {\n        args = new Array(al - 1);\n\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n\n        switch (al) {\n          case 1:\n            promises.push(handler[i].call(this));\n            break;\n\n          case 2:\n            promises.push(handler[i].call(this, arguments[1]));\n            break;\n\n          case 3:\n            promises.push(handler[i].call(this, arguments[1], arguments[2]));\n            break;\n\n          default:\n            promises.push(handler[i].apply(this, args));\n        }\n      }\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\n      } else {\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return Promise.all(promises);\n  };\n\n  EventEmitter.prototype.on = function (type, listener, options) {\n    return this._on(type, listener, false, options);\n  };\n\n  EventEmitter.prototype.prependListener = function (type, listener, options) {\n    return this._on(type, listener, true, options);\n  };\n\n  EventEmitter.prototype.onAny = function (fn) {\n    return this._onAny(fn, false);\n  };\n\n  EventEmitter.prototype.prependAny = function (fn) {\n    return this._onAny(fn, true);\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype._onAny = function (fn, prepend) {\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if (!this._all) {\n      this._all = [];\n    } // Add the function to the event listener collection.\n\n\n    if (prepend) {\n      this._all.unshift(fn);\n    } else {\n      this._all.push(fn);\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype._on = function (type, listener, prepend, options) {\n    if (typeof type === 'function') {\n      this._onAny(type, listener);\n\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n\n    this._events || init.call(this);\n    var returnValue = this,\n        temp;\n\n    if (options !== undefined) {\n      temp = setupListener.call(this, type, listener, options);\n      listener = temp[0];\n      returnValue = temp[1];\n    } // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n\n\n    if (this._newListener) {\n      this.emit('newListener', type, listener);\n    }\n\n    if (this.wildcard) {\n      growListenerTree.call(this, type, listener, prepend);\n      return returnValue;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    } else {\n      if (typeof this._events[type] === 'function') {\n        // Change to array.\n        this._events[type] = [this._events[type]];\n      } // If we've already got an array, just add\n\n\n      if (prepend) {\n        this._events[type].unshift(listener);\n      } else {\n        this._events[type].push(listener);\n      } // Check for listener leak\n\n\n      if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {\n        this._events[type].warned = true;\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\n      }\n    }\n\n    return returnValue;\n  };\n\n  EventEmitter.prototype.off = function (type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,\n        leafs = [];\n\n    if (this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n      if (!leafs) return this;\n    } else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({\n        _listeners: handlers\n      });\n    }\n\n    for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n\n      if (isArray(handlers)) {\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if (this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        } else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if (this.wildcard) {\n            delete leaf._listeners;\n          } else {\n            delete this._events[type];\n          }\n        }\n\n        if (this._removeListener) this.emit(\"removeListener\", type, listener);\n        return this;\n      } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {\n        if (this.wildcard) {\n          delete leaf._listeners;\n        } else {\n          delete this._events[type];\n        }\n\n        if (this._removeListener) this.emit(\"removeListener\", type, listener);\n      }\n    }\n\n    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function (fn) {\n    var i = 0,\n        l = 0,\n        fns;\n\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n\n      for (i = 0, l = fns.length; i < l; i++) {\n        if (fn === fns[i]) {\n          fns.splice(i, 1);\n          if (this._removeListener) this.emit(\"removeListenerAny\", fn);\n          return this;\n        }\n      }\n    } else {\n      fns = this._all;\n\n      if (this._removeListener) {\n        for (i = 0, l = fns.length; i < l; i++) this.emit(\"removeListenerAny\", fns[i]);\n      }\n\n      this._all = [];\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function (type) {\n    if (type === undefined) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if (this.wildcard) {\n      var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0),\n          leaf,\n          i;\n      if (!leafs) return this;\n\n      for (i = 0; i < leafs.length; i++) {\n        leaf = leafs[i];\n        leaf._listeners = null;\n      }\n\n      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n    } else if (this._events) {\n      this._events[type] = null;\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function (type) {\n    var _events = this._events;\n    var keys, listeners, allListeners;\n    var i;\n    var listenerTree;\n\n    if (type === undefined) {\n      if (this.wildcard) {\n        throw Error('event name required for wildcard emitter');\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      keys = ownKeys(_events);\n      i = keys.length;\n      allListeners = [];\n\n      while (i-- > 0) {\n        listeners = _events[keys[i]];\n\n        if (typeof listeners === 'function') {\n          allListeners.push(listeners);\n        } else {\n          allListeners.push.apply(allListeners, listeners);\n        }\n      }\n\n      return allListeners;\n    } else {\n      if (this.wildcard) {\n        listenerTree = this.listenerTree;\n        if (!listenerTree) return [];\n        var handlers = [];\n        var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n        searchListenerTree.call(this, handlers, ns, listenerTree, 0);\n        return handlers;\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      listeners = _events[type];\n\n      if (!listeners) {\n        return [];\n      }\n\n      return typeof listeners === 'function' ? [listeners] : listeners;\n    }\n  };\n\n  EventEmitter.prototype.eventNames = function (nsAsArray) {\n    var _events = this._events;\n    return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];\n  };\n\n  EventEmitter.prototype.listenerCount = function (type) {\n    return this.listeners(type).length;\n  };\n\n  EventEmitter.prototype.hasListeners = function (type) {\n    if (this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers.length > 0;\n    }\n\n    var _events = this._events;\n    var _all = this._all;\n    return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));\n  };\n\n  EventEmitter.prototype.listenersAny = function () {\n    if (this._all) {\n      return this._all;\n    } else {\n      return [];\n    }\n  };\n\n  EventEmitter.prototype.waitFor = function (event, options) {\n    var self = this;\n    var type = typeof options;\n\n    if (type === 'number') {\n      options = {\n        timeout: options\n      };\n    } else if (type === 'function') {\n      options = {\n        filter: options\n      };\n    }\n\n    options = resolveOptions(options, {\n      timeout: 0,\n      filter: undefined,\n      handleError: false,\n      Promise: Promise,\n      overload: false\n    }, {\n      filter: functionReducer,\n      Promise: constructorReducer\n    });\n    return makeCancelablePromise(options.Promise, function (resolve, reject, onCancel) {\n      function listener() {\n        var filter = options.filter;\n\n        if (filter && !filter.apply(self, arguments)) {\n          return;\n        }\n\n        self.off(event, listener);\n\n        if (options.handleError) {\n          var err = arguments[0];\n          err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));\n        } else {\n          resolve(toArray.apply(null, arguments));\n        }\n      }\n\n      onCancel(function () {\n        self.off(event, listener);\n      });\n\n      self._on(event, listener, false);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    });\n  };\n\n  function once(emitter, name, options) {\n    options = resolveOptions(options, {\n      Promise: Promise,\n      timeout: 0,\n      overload: false\n    }, {\n      Promise: constructorReducer\n    });\n    var _Promise = options.Promise;\n    return makeCancelablePromise(_Promise, function (resolve, reject, onCancel) {\n      var handler;\n\n      if (typeof emitter.addEventListener === 'function') {\n        handler = function () {\n          resolve(toArray.apply(null, arguments));\n        };\n\n        onCancel(function () {\n          emitter.removeEventListener(name, handler);\n        });\n        emitter.addEventListener(name, handler, {\n          once: true\n        });\n        return;\n      }\n\n      var eventListener = function () {\n        errorListener && emitter.removeListener('error', errorListener);\n        resolve(toArray.apply(null, arguments));\n      };\n\n      var errorListener;\n\n      if (name !== 'error') {\n        errorListener = function (err) {\n          emitter.removeListener(name, eventListener);\n          reject(err);\n        };\n\n        emitter.once('error', errorListener);\n      }\n\n      onCancel(function () {\n        errorListener && emitter.removeListener('error', errorListener);\n        emitter.removeListener(name, eventListener);\n      });\n      emitter.once(name, eventListener);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    });\n  }\n\n  var prototype = EventEmitter.prototype;\n  Object.defineProperties(EventEmitter, {\n    defaultMaxListeners: {\n      get: function () {\n        return prototype._maxListeners;\n      },\n      set: function (n) {\n        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {\n          throw TypeError('n must be a non-negative number');\n        }\n\n        prototype._maxListeners = n;\n      },\n      enumerable: true\n    },\n    once: {\n      value: once,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperties(prototype, {\n    _maxListeners: {\n      value: defaultMaxListeners,\n      writable: true,\n      configurable: true\n    },\n    _observers: {\n      value: null,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(function () {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = EventEmitter;\n  } else {\n    // global for any kind of environment.\n    var _global = new Function('', 'return this')();\n\n    _global.EventEmitter2 = EventEmitter;\n  }\n}();","map":{"version":3,"names":["undefined","hasOwnProperty","Object","isArray","Array","_isArray","obj","prototype","toString","call","defaultMaxListeners","nextTickSupported","process","nextTick","symbolsSupported","Symbol","reflectSupported","Reflect","setImmediateSupported","setImmediate","_setImmediate","setTimeout","ownKeys","arr","getOwnPropertyNames","push","apply","getOwnPropertySymbols","keys","init","_events","_conf","configure","conf","delimiter","maxListeners","_maxListeners","wildcard","newListener","_newListener","removeListener","_removeListener","verboseMemoryLeak","ignoreErrors","listenerTree","logPossibleMemoryLeak","count","eventName","errorMsg","emitWarning","e","Error","name","emitter","console","error","trace","toArray","a","b","c","n","arguments","length","toObject","values","key","len","valuesCount","i","TargetObserver","target","options","_emitter","_target","_listeners","_listenersCount","on","off","addEventListener","removeEventListener","addListener","TypeError","_on","_off","_observers","assign","subscribe","event","localEvent","reducer","observer","listeners","handler","args","eventObj","data","original","result","emit","concat","_onNewListener","_event","_onRemoveListener","hasListeners","unsubscribe","events","clearRefs","index","findTargetIndex","splice","resolveOptions","schema","reducers","allowUnknown","computedOptions","option","value","reject","reason","constructorReducer","makeTypeReducer","types","message","join","firstType","secondType","v","kind","functionReducer","objectFunctionReducer","makeCancelablePromise","Promise","executor","isCancelable","callbacks","timer","subscriptionClosed","promise","resolve","onCancel","timeout","overload","Number","isFinite","cancel","cleanup","clearTimeout","_resolve","_reject","err","cb","code","observers","searchListenerTree","handlers","type","tree","typeLength","ns","l","j","dl","indexOf","slice","branch","xTree","xxTree","isolatedBranch","endReached","currentType","nextType","branches","growListenerTree","listener","prepend","unshift","warned","collectTreeEvents","root","asArray","branchName","path","isArrayPath","recursivelyGarbageCollect","flag","Listener","setupListener","promisify","async","objectify","_listener","_origin","constructor","context","then","_async","EventEmitter","EventEmitter2","listenTo","listen","isSingleReducer","split","stopListeningTo","matched","setMaxListeners","getMaxListeners","once","fn","_once","prependOnceListener","_many","many","ttl","prependMany","self","_all","containsSymbol","al","emitAsync","promises","all","prependListener","onAny","_onAny","prependAny","returnValue","temp","leafs","iLeaf","leaf","position","offAny","fns","removeAllListeners","allListeners","eventNames","nsAsArray","listenerCount","listenersAny","waitFor","filter","handleError","_Promise","eventListener","errorListener","defineProperties","get","set","isNaN","enumerable","writable","configurable","define","amd","exports","module","_global","Function"],"sources":["C:/Users/rishi/contract-poc/ThriEstate/Brandvilla/node_modules/eventemitter2/lib/eventemitter2.js"],"sourcesContent":["/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;!function(undefined) {\n  var hasOwnProperty= Object.hasOwnProperty;\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n  var nextTickSupported= typeof process=='object' && typeof process.nextTick=='function';\n  var symbolsSupported= typeof Symbol==='function';\n  var reflectSupported= typeof Reflect === 'object';\n  var setImmediateSupported= typeof setImmediate === 'function';\n  var _setImmediate= setImmediateSupported ? setImmediate : setTimeout;\n  var ownKeys= symbolsSupported? (reflectSupported && typeof Reflect.ownKeys==='function'? Reflect.ownKeys : function(obj){\n    var arr= Object.getOwnPropertyNames(obj);\n    arr.push.apply(arr, Object.getOwnPropertySymbols(obj));\n    return arr;\n  }) : Object.keys;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n\n      if(conf.maxListeners!==undefined){\n          this._maxListeners= conf.maxListeners;\n      }\n\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this._newListener = conf.newListener);\n      conf.removeListener && (this._removeListener = conf.removeListener);\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\n      conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function logPossibleMemoryLeak(count, eventName) {\n    var errorMsg = '(node) warning: possible EventEmitter memory ' +\n        'leak detected. ' + count + ' listeners added. ' +\n        'Use emitter.setMaxListeners() to increase limit.';\n\n    if(this.verboseMemoryLeak){\n      errorMsg += ' Event name: ' + eventName + '.';\n    }\n\n    if(typeof process !== 'undefined' && process.emitWarning){\n      var e = new Error(errorMsg);\n      e.name = 'MaxListenersExceededWarning';\n      e.emitter = this;\n      e.count = count;\n      process.emitWarning(e);\n    } else {\n      console.error(errorMsg);\n\n      if (console.trace){\n        console.trace();\n      }\n    }\n  }\n\n  var toArray = function (a, b, c) {\n    var n = arguments.length;\n    switch (n) {\n      case 0:\n        return [];\n      case 1:\n        return [a];\n      case 2:\n        return [a, b];\n      case 3:\n        return [a, b, c];\n      default:\n        var arr = new Array(n);\n        while (n--) {\n          arr[n] = arguments[n];\n        }\n        return arr;\n    }\n  };\n\n  function toObject(keys, values) {\n    var obj = {};\n    var key;\n    var len = keys.length;\n    var valuesCount = values ? values.length : 0;\n    for (var i = 0; i < len; i++) {\n      key = keys[i];\n      obj[key] = i < valuesCount ? values[i] : undefined;\n    }\n    return obj;\n  }\n\n  function TargetObserver(emitter, target, options) {\n    this._emitter = emitter;\n    this._target = target;\n    this._listeners = {};\n    this._listenersCount = 0;\n\n    var on, off;\n\n    if (options.on || options.off) {\n      on = options.on;\n      off = options.off;\n    }\n\n    if (target.addEventListener) {\n      on = target.addEventListener;\n      off = target.removeEventListener;\n    } else if (target.addListener) {\n      on = target.addListener;\n      off = target.removeListener;\n    } else if (target.on) {\n      on = target.on;\n      off = target.off;\n    }\n\n    if (!on && !off) {\n      throw Error('target does not implement any known event API');\n    }\n\n    if (typeof on !== 'function') {\n      throw TypeError('on method must be a function');\n    }\n\n    if (typeof off !== 'function') {\n      throw TypeError('off method must be a function');\n    }\n\n    this._on = on;\n    this._off = off;\n\n    var _observers= emitter._observers;\n    if(_observers){\n      _observers.push(this);\n    }else{\n      emitter._observers= [this];\n    }\n  }\n\n  Object.assign(TargetObserver.prototype, {\n    subscribe: function(event, localEvent, reducer){\n      var observer= this;\n      var target= this._target;\n      var emitter= this._emitter;\n      var listeners= this._listeners;\n      var handler= function(){\n        var args= toArray.apply(null, arguments);\n        var eventObj= {\n          data: args,\n          name: localEvent,\n          original: event\n        };\n        if(reducer){\n          var result= reducer.call(target, eventObj);\n          if(result!==false){\n            emitter.emit.apply(emitter, [eventObj.name].concat(args))\n          }\n          return;\n        }\n        emitter.emit.apply(emitter, [localEvent].concat(args));\n      };\n\n\n      if(listeners[event]){\n        throw Error('Event \\'' + event + '\\' is already listening');\n      }\n\n      this._listenersCount++;\n\n      if(emitter._newListener && emitter._removeListener && !observer._onNewListener){\n\n        this._onNewListener = function (_event) {\n          if (_event === localEvent && listeners[event] === null) {\n            listeners[event] = handler;\n            observer._on.call(target, event, handler);\n          }\n        };\n\n        emitter.on('newListener', this._onNewListener);\n\n        this._onRemoveListener= function(_event){\n          if(_event === localEvent && !emitter.hasListeners(_event) && listeners[event]){\n            listeners[event]= null;\n            observer._off.call(target, event, handler);\n          }\n        };\n\n        listeners[event]= null;\n\n        emitter.on('removeListener', this._onRemoveListener);\n      }else{\n        listeners[event]= handler;\n        observer._on.call(target, event, handler);\n      }\n    },\n\n    unsubscribe: function(event){\n      var observer= this;\n      var listeners= this._listeners;\n      var emitter= this._emitter;\n      var handler;\n      var events;\n      var off= this._off;\n      var target= this._target;\n      var i;\n\n      if(event && typeof event!=='string'){\n        throw TypeError('event must be a string');\n      }\n\n      function clearRefs(){\n        if(observer._onNewListener){\n          emitter.off('newListener', observer._onNewListener);\n          emitter.off('removeListener', observer._onRemoveListener);\n          observer._onNewListener= null;\n          observer._onRemoveListener= null;\n        }\n        var index= findTargetIndex.call(emitter, observer);\n        emitter._observers.splice(index, 1);\n      }\n\n      if(event){\n        handler= listeners[event];\n        if(!handler) return;\n        off.call(target, event, handler);\n        delete listeners[event];\n        if(!--this._listenersCount){\n          clearRefs();\n        }\n      }else{\n        events= ownKeys(listeners);\n        i= events.length;\n        while(i-->0){\n          event= events[i];\n          off.call(target, event, listeners[event]);\n        }\n        this._listeners= {};\n        this._listenersCount= 0;\n        clearRefs();\n      }\n    }\n  });\n\n  function resolveOptions(options, schema, reducers, allowUnknown) {\n    var computedOptions = Object.assign({}, schema);\n\n    if (!options) return computedOptions;\n\n    if (typeof options !== 'object') {\n      throw TypeError('options must be an object')\n    }\n\n    var keys = Object.keys(options);\n    var length = keys.length;\n    var option, value;\n    var reducer;\n\n    function reject(reason) {\n      throw Error('Invalid \"' + option + '\" option value' + (reason ? '. Reason: ' + reason : ''))\n    }\n\n    for (var i = 0; i < length; i++) {\n      option = keys[i];\n      if (!allowUnknown && !hasOwnProperty.call(schema, option)) {\n        throw Error('Unknown \"' + option + '\" option');\n      }\n      value = options[option];\n      if (value !== undefined) {\n        reducer = reducers[option];\n        computedOptions[option] = reducer ? reducer(value, reject) : value;\n      }\n    }\n    return computedOptions;\n  }\n\n  function constructorReducer(value, reject) {\n    if (typeof value !== 'function' || !value.hasOwnProperty('prototype')) {\n      reject('value must be a constructor');\n    }\n    return value;\n  }\n\n  function makeTypeReducer(types) {\n    var message= 'value must be type of ' + types.join('|');\n    var len= types.length;\n    var firstType= types[0];\n    var secondType= types[1];\n\n    if (len === 1) {\n      return function (v, reject) {\n        if (typeof v === firstType) {\n          return v;\n        }\n        reject(message);\n      }\n    }\n\n    if (len === 2) {\n      return function (v, reject) {\n        var kind= typeof v;\n        if (kind === firstType || kind === secondType) return v;\n        reject(message);\n      }\n    }\n\n    return function (v, reject) {\n      var kind = typeof v;\n      var i = len;\n      while (i-- > 0) {\n        if (kind === types[i]) return v;\n      }\n      reject(message);\n    }\n  }\n\n  var functionReducer= makeTypeReducer(['function']);\n\n  var objectFunctionReducer= makeTypeReducer(['object', 'function']);\n\n  function makeCancelablePromise(Promise, executor, options) {\n    var isCancelable;\n    var callbacks;\n    var timer= 0;\n    var subscriptionClosed;\n\n    var promise = new Promise(function (resolve, reject, onCancel) {\n      options= resolveOptions(options, {\n        timeout: 0,\n        overload: false\n      }, {\n        timeout: function(value, reject){\n          value*= 1;\n          if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {\n            reject('timeout must be a positive number');\n          }\n          return value;\n        }\n      });\n\n      isCancelable = !options.overload && typeof Promise.prototype.cancel === 'function' && typeof onCancel === 'function';\n\n      function cleanup() {\n        if (callbacks) {\n          callbacks = null;\n        }\n        if (timer) {\n          clearTimeout(timer);\n          timer = 0;\n        }\n      }\n\n      var _resolve= function(value){\n        cleanup();\n        resolve(value);\n      };\n\n      var _reject= function(err){\n        cleanup();\n        reject(err);\n      };\n\n      if (isCancelable) {\n        executor(_resolve, _reject, onCancel);\n      } else {\n        callbacks = [function(reason){\n          _reject(reason || Error('canceled'));\n        }];\n        executor(_resolve, _reject, function (cb) {\n          if (subscriptionClosed) {\n            throw Error('Unable to subscribe on cancel event asynchronously')\n          }\n          if (typeof cb !== 'function') {\n            throw TypeError('onCancel callback must be a function');\n          }\n          callbacks.push(cb);\n        });\n        subscriptionClosed= true;\n      }\n\n      if (options.timeout > 0) {\n        timer= setTimeout(function(){\n          var reason= Error('timeout');\n          reason.code = 'ETIMEDOUT'\n          timer= 0;\n          promise.cancel(reason);\n          reject(reason);\n        }, options.timeout);\n      }\n    });\n\n    if (!isCancelable) {\n      promise.cancel = function (reason) {\n        if (!callbacks) {\n          return;\n        }\n        var length = callbacks.length;\n        for (var i = 1; i < length; i++) {\n          callbacks[i](reason);\n        }\n        // internal callback to reject the promise\n        callbacks[0](reason);\n        callbacks = null;\n      };\n    }\n\n    return promise;\n  }\n\n  function findTargetIndex(observer) {\n    var observers = this._observers;\n    if(!observers){\n      return -1;\n    }\n    var len = observers.length;\n    for (var i = 0; i < len; i++) {\n      if (observers[i]._target === observer) return i;\n    }\n    return -1;\n  }\n\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i, typeLength) {\n    if (!tree) {\n      return null;\n    }\n\n    if (i === 0) {\n      var kind = typeof type;\n      if (kind === 'string') {\n        var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;\n        if ((n = type.indexOf(delimiter)) !== -1) {\n          ns = new Array(5);\n          do {\n            ns[l++] = type.slice(j, n);\n            j = n + dl;\n          } while ((n = type.indexOf(delimiter, j)) !== -1);\n\n          ns[l++] = type.slice(j);\n          type = ns;\n          typeLength = l;\n        } else {\n          type = [type];\n          typeLength = 1;\n        }\n      } else if (kind === 'object') {\n        typeLength = type.length;\n      } else {\n        type = [type];\n        typeLength = 1;\n      }\n    }\n\n    var listeners= null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i],\n        nextType = type[i + 1], branches, _listeners;\n\n    if (i === typeLength) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n\n      if(tree._listeners) {\n        if (typeof tree._listeners === 'function') {\n          handlers && handlers.push(tree._listeners);\n          listeners = [tree];\n        } else {\n          handlers && handlers.push.apply(handlers, tree._listeners);\n          listeners = [tree];\n        }\n      }\n    } else {\n\n      if (currentType === '*') {\n        //\n        // If the event emitted is '*' at this part\n        // or there is a concrete match at this patch\n        //\n        branches = ownKeys(tree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n        return listeners;\n      } else if (currentType === '**') {\n        endReached = (i + 1 === typeLength || (i + 2 === typeLength && nextType === '*'));\n        if (endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);\n        }\n\n        branches = ownKeys(tree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            if (branch === '*' || branch === '**') {\n              if (tree[branch]._listeners && !endReached) {\n                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);\n                if (_listeners) {\n                  if (listeners) {\n                    listeners.push.apply(listeners, _listeners);\n                  } else {\n                    listeners = _listeners;\n                  }\n                }\n              }\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            } else if (branch === nextType) {\n              _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            }\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n        return listeners;\n      } else if (tree[currentType]) {\n        listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);\n      }\n    }\n\n      xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i + 1, typeLength);\n    }\n\n    xxTree = tree['**'];\n    if (xxTree) {\n      if (i < typeLength) {\n        if (xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        branches= ownKeys(xxTree);\n        n= branches.length;\n        while(n-->0){\n          branch= branches[n];\n          if (branch !== '_listeners') {\n            if (branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);\n            } else if (branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, {'**': isolatedBranch}, i + 1, typeLength);\n            }\n          }\n        }\n      } else if (xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n      } else if (xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength, typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener, prepend) {\n    var len = 0, j = 0, i, delimiter = this.delimiter, dl= delimiter.length, ns;\n\n    if(typeof type==='string') {\n      if ((i = type.indexOf(delimiter)) !== -1) {\n        ns = new Array(5);\n        do {\n          ns[len++] = type.slice(j, i);\n          j = i + dl;\n        } while ((i = type.indexOf(delimiter, j)) !== -1);\n\n        ns[len++] = type.slice(j);\n      }else{\n        ns= [type];\n        len= 1;\n      }\n    }else{\n      ns= type;\n      len= type.length;\n    }\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    if (len > 1) {\n      for (i = 0; i + 1 < len; i++) {\n        if (ns[i] === '**' && ns[i + 1] === '**') {\n          return;\n        }\n      }\n    }\n\n\n\n    var tree = this.listenerTree, name;\n\n    for (i = 0; i < len; i++) {\n      name = ns[i];\n\n      tree = tree[name] || (tree[name] = {});\n\n      if (i === len - 1) {\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        } else {\n          if (typeof tree._listeners === 'function') {\n            tree._listeners = [tree._listeners];\n          }\n\n          if (prepend) {\n            tree._listeners.unshift(listener);\n          } else {\n            tree._listeners.push(listener);\n          }\n\n          if (\n              !tree._listeners.warned &&\n              this._maxListeners > 0 &&\n              tree._listeners.length > this._maxListeners\n          ) {\n            tree._listeners.warned = true;\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\n          }\n        }\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  function collectTreeEvents(tree, events, root, asArray){\n     var branches= ownKeys(tree);\n     var i= branches.length;\n     var branch, branchName, path;\n     var hasListeners= tree['_listeners'];\n     var isArrayPath;\n\n     while(i-->0){\n         branchName= branches[i];\n\n         branch= tree[branchName];\n\n         if(branchName==='_listeners'){\n             path= root;\n         }else {\n             path = root ? root.concat(branchName) : [branchName];\n         }\n\n         isArrayPath= asArray || typeof branchName==='symbol';\n\n         hasListeners && events.push(isArrayPath? path : path.join(this.delimiter));\n\n         if(typeof branch==='object'){\n             collectTreeEvents.call(this, branch, events, path, isArrayPath);\n         }\n     }\n\n     return events;\n  }\n\n  function recursivelyGarbageCollect(root) {\n    var keys = ownKeys(root);\n    var i= keys.length;\n    var obj, key, flag;\n    while(i-->0){\n      key = keys[i];\n      obj = root[key];\n\n      if(obj){\n          flag= true;\n          if(key !== '_listeners' && !recursivelyGarbageCollect(obj)){\n             delete root[key];\n          }\n      }\n    }\n\n    return flag;\n  }\n\n  function Listener(emitter, event, listener){\n    this.emitter= emitter;\n    this.event= event;\n    this.listener= listener;\n  }\n\n  Listener.prototype.off= function(){\n    this.emitter.off(this.event, this.listener);\n    return this;\n  };\n\n  function setupListener(event, listener, options){\n      if (options === true) {\n        promisify = true;\n      } else if (options === false) {\n        async = true;\n      } else {\n        if (!options || typeof options !== 'object') {\n          throw TypeError('options should be an object or true');\n        }\n        var async = options.async;\n        var promisify = options.promisify;\n        var nextTick = options.nextTick;\n        var objectify = options.objectify;\n      }\n\n      if (async || nextTick || promisify) {\n        var _listener = listener;\n        var _origin = listener._origin || listener;\n\n        if (nextTick && !nextTickSupported) {\n          throw Error('process.nextTick is not supported');\n        }\n\n        if (promisify === undefined) {\n          promisify = listener.constructor.name === 'AsyncFunction';\n        }\n\n        listener = function () {\n          var args = arguments;\n          var context = this;\n          var event = this.event;\n\n          return promisify ? (nextTick ? Promise.resolve() : new Promise(function (resolve) {\n            _setImmediate(resolve);\n          }).then(function () {\n            context.event = event;\n            return _listener.apply(context, args)\n          })) : (nextTick ? process.nextTick : _setImmediate)(function () {\n            context.event = event;\n            _listener.apply(context, args)\n          });\n        };\n\n        listener._async = true;\n        listener._origin = _origin;\n      }\n\n    return [listener, objectify? new Listener(this, event, listener): this];\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this._newListener = false;\n    this._removeListener = false;\n    this.verboseMemoryLeak = false;\n    configure.call(this, conf);\n  }\n\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\n\n  EventEmitter.prototype.listenTo= function(target, events, options){\n    if(typeof target!=='object'){\n      throw TypeError('target musts be an object');\n    }\n\n    var emitter= this;\n\n    options = resolveOptions(options, {\n      on: undefined,\n      off: undefined,\n      reducers: undefined\n    }, {\n      on: functionReducer,\n      off: functionReducer,\n      reducers: objectFunctionReducer\n    });\n\n    function listen(events){\n      if(typeof events!=='object'){\n        throw TypeError('events must be an object');\n      }\n\n      var reducers= options.reducers;\n      var index= findTargetIndex.call(emitter, target);\n      var observer;\n\n      if(index===-1){\n        observer= new TargetObserver(emitter, target, options);\n      }else{\n        observer= emitter._observers[index];\n      }\n\n      var keys= ownKeys(events);\n      var len= keys.length;\n      var event;\n      var isSingleReducer= typeof reducers==='function';\n\n      for(var i=0; i<len; i++){\n        event= keys[i];\n        observer.subscribe(\n            event,\n            events[event] || event,\n            isSingleReducer ? reducers : reducers && reducers[event]\n        );\n      }\n    }\n\n    isArray(events)?\n        listen(toObject(events)) :\n        (typeof events==='string'? listen(toObject(events.split(/\\s+/))): listen(events));\n\n    return this;\n  };\n\n  EventEmitter.prototype.stopListeningTo = function (target, event) {\n    var observers = this._observers;\n\n    if(!observers){\n      return false;\n    }\n\n    var i = observers.length;\n    var observer;\n    var matched= false;\n\n    if(target && typeof target!=='object'){\n      throw TypeError('target should be an object');\n    }\n\n    while (i-- > 0) {\n      observer = observers[i];\n      if (!target || observer._target === target) {\n        observer.unsubscribe(event);\n        matched= true;\n      }\n    }\n\n    return matched;\n  };\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    if (n !== undefined) {\n      this._maxListeners = n;\n      if (!this._conf) this._conf = {};\n      this._conf.maxListeners = n;\n    }\n  };\n\n  EventEmitter.prototype.getMaxListeners = function() {\n    return this._maxListeners;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn, options) {\n    return this._once(event, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependOnceListener = function(event, fn, options) {\n    return this._once(event, fn, true, options);\n  };\n\n  EventEmitter.prototype._once = function(event, fn, prepend, options) {\n    return this._many(event, 1, fn, prepend, options);\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn, options) {\n    return this._many(event, ttl, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {\n    return this._many(event, ttl, fn, true, options);\n  };\n\n  EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      return fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    return this._on(event, listener, prepend, options);\n  };\n\n  EventEmitter.prototype.emit = function() {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n\n    var type = arguments[0], ns, wildcard= this.wildcard;\n    var args,l,i,j, containsSymbol;\n\n    if (type === 'newListener' && !this._newListener) {\n      if (!this._events.newListener) {\n        return false;\n      }\n    }\n\n    if (wildcard) {\n      ns= type;\n      if(type!=='newListener' && type!=='removeListener'){\n        if (typeof type === 'object') {\n          l = type.length;\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var al = arguments.length;\n    var handler;\n\n    if (this._all && this._all.length) {\n      handler = this._all.slice();\n\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler[i].call(this, type);\n          break;\n        case 2:\n          handler[i].call(this, type, arguments[1]);\n          break;\n        case 3:\n          handler[i].call(this, type, arguments[1], arguments[2]);\n          break;\n        default:\n          handler[i].apply(this, arguments);\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);\n    } else {\n      handler = this._events[type];\n      if (typeof handler === 'function') {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler.call(this);\n          break;\n        case 2:\n          handler.call(this, arguments[1]);\n          break;\n        case 3:\n          handler.call(this, arguments[1], arguments[2]);\n          break;\n        default:\n          args = new Array(al - 1);\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n          handler.apply(this, args);\n        }\n        return true;\n      } else if (handler) {\n        // need to make copy of handlers because list can change in the middle\n        // of emit call\n        handler = handler.slice();\n      }\n    }\n\n    if (handler && handler.length) {\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler[i].call(this);\n          break;\n        case 2:\n          handler[i].call(this, arguments[1]);\n          break;\n        case 3:\n          handler[i].call(this, arguments[1], arguments[2]);\n          break;\n        default:\n          handler[i].apply(this, args);\n        }\n      }\n      return true;\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return !!this._all;\n  };\n\n  EventEmitter.prototype.emitAsync = function() {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n\n    var type = arguments[0], wildcard= this.wildcard, ns, containsSymbol;\n    var args,l,i,j;\n\n    if (type === 'newListener' && !this._newListener) {\n        if (!this._events.newListener) { return Promise.resolve([false]); }\n    }\n\n    if (wildcard) {\n      ns= type;\n      if(type!=='newListener' && type!=='removeListener'){\n        if (typeof type === 'object') {\n          l = type.length;\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var promises= [];\n\n    var al = arguments.length;\n    var handler;\n\n    if (this._all) {\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          promises.push(this._all[i].call(this, type));\n          break;\n        case 2:\n          promises.push(this._all[i].call(this, type, arguments[1]));\n          break;\n        case 3:\n          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\n          break;\n        default:\n          promises.push(this._all[i].apply(this, arguments));\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      switch (al) {\n      case 1:\n        promises.push(handler.call(this));\n        break;\n      case 2:\n        promises.push(handler.call(this, arguments[1]));\n        break;\n      case 3:\n        promises.push(handler.call(this, arguments[1], arguments[2]));\n        break;\n      default:\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n        promises.push(handler.apply(this, args));\n      }\n    } else if (handler && handler.length) {\n      handler = handler.slice();\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          promises.push(handler[i].call(this));\n          break;\n        case 2:\n          promises.push(handler[i].call(this, arguments[1]));\n          break;\n        case 3:\n          promises.push(handler[i].call(this, arguments[1], arguments[2]));\n          break;\n        default:\n          promises.push(handler[i].apply(this, args));\n        }\n      }\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\n      } else {\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return Promise.all(promises);\n  };\n\n  EventEmitter.prototype.on = function(type, listener, options) {\n    return this._on(type, listener, false, options);\n  };\n\n  EventEmitter.prototype.prependListener = function(type, listener, options) {\n    return this._on(type, listener, true, options);\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n    return this._onAny(fn, false);\n  };\n\n  EventEmitter.prototype.prependAny = function(fn) {\n    return this._onAny(fn, true);\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype._onAny = function(fn, prepend){\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if (!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    if(prepend){\n      this._all.unshift(fn);\n    }else{\n      this._all.push(fn);\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype._on = function(type, listener, prepend, options) {\n    if (typeof type === 'function') {\n      this._onAny(type, listener);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    var returnValue= this, temp;\n\n    if (options !== undefined) {\n      temp = setupListener.call(this, type, listener, options);\n      listener = temp[0];\n      returnValue = temp[1];\n    }\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    if (this._newListener) {\n      this.emit('newListener', type, listener);\n    }\n\n    if (this.wildcard) {\n      growListenerTree.call(this, type, listener, prepend);\n      return returnValue;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    } else {\n      if (typeof this._events[type] === 'function') {\n        // Change to array.\n        this._events[type] = [this._events[type]];\n      }\n\n      // If we've already got an array, just add\n      if(prepend){\n        this._events[type].unshift(listener);\n      }else{\n        this._events[type].push(listener);\n      }\n\n      // Check for listener leak\n      if (\n        !this._events[type].warned &&\n        this._maxListeners > 0 &&\n        this._events[type].length > this._maxListeners\n      ) {\n        this._events[type].warned = true;\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\n      }\n    }\n\n    return returnValue;\n  };\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n      if(!leafs) return this;\n    } else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        if (this._removeListener)\n          this.emit(\"removeListener\", type, listener);\n\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n        if (this._removeListener)\n          this.emit(\"removeListener\", type, listener);\n      }\n    }\n\n    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          if (this._removeListener)\n            this.emit(\"removeListenerAny\", fn);\n          return this;\n        }\n      }\n    } else {\n      fns = this._all;\n      if (this._removeListener) {\n        for(i = 0, l = fns.length; i < l; i++)\n          this.emit(\"removeListenerAny\", fns[i]);\n      }\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function (type) {\n    if (type === undefined) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if (this.wildcard) {\n      var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;\n      if (!leafs) return this;\n      for (i = 0; i < leafs.length; i++) {\n        leaf = leafs[i];\n        leaf._listeners = null;\n      }\n      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n    } else if (this._events) {\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function (type) {\n    var _events = this._events;\n    var keys, listeners, allListeners;\n    var i;\n    var listenerTree;\n\n    if (type === undefined) {\n      if (this.wildcard) {\n        throw Error('event name required for wildcard emitter');\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      keys = ownKeys(_events);\n      i = keys.length;\n      allListeners = [];\n      while (i-- > 0) {\n        listeners = _events[keys[i]];\n        if (typeof listeners === 'function') {\n          allListeners.push(listeners);\n        } else {\n          allListeners.push.apply(allListeners, listeners);\n        }\n      }\n      return allListeners;\n    } else {\n      if (this.wildcard) {\n        listenerTree= this.listenerTree;\n        if(!listenerTree) return [];\n        var handlers = [];\n        var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n        searchListenerTree.call(this, handlers, ns, listenerTree, 0);\n        return handlers;\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      listeners = _events[type];\n\n      if (!listeners) {\n        return [];\n      }\n      return typeof listeners === 'function' ? [listeners] : listeners;\n    }\n  };\n\n  EventEmitter.prototype.eventNames = function(nsAsArray){\n    var _events= this._events;\n    return this.wildcard? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : (_events? ownKeys(_events) : []);\n  };\n\n  EventEmitter.prototype.listenerCount = function(type) {\n    return this.listeners(type).length;\n  };\n\n  EventEmitter.prototype.hasListeners = function (type) {\n    if (this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers.length > 0;\n    }\n\n    var _events = this._events;\n    var _all = this._all;\n\n    return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  EventEmitter.prototype.waitFor = function (event, options) {\n    var self = this;\n    var type = typeof options;\n    if (type === 'number') {\n      options = {timeout: options};\n    } else if (type === 'function') {\n      options = {filter: options};\n    }\n\n    options= resolveOptions(options, {\n      timeout: 0,\n      filter: undefined,\n      handleError: false,\n      Promise: Promise,\n      overload: false\n    }, {\n      filter: functionReducer,\n      Promise: constructorReducer\n    });\n\n    return makeCancelablePromise(options.Promise, function (resolve, reject, onCancel) {\n      function listener() {\n        var filter= options.filter;\n        if (filter && !filter.apply(self, arguments)) {\n          return;\n        }\n        self.off(event, listener);\n        if (options.handleError) {\n          var err = arguments[0];\n          err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));\n        } else {\n          resolve(toArray.apply(null, arguments));\n        }\n      }\n\n      onCancel(function(){\n        self.off(event, listener);\n      });\n\n      self._on(event, listener, false);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    })\n  };\n\n  function once(emitter, name, options) {\n    options= resolveOptions(options, {\n      Promise: Promise,\n      timeout: 0,\n      overload: false\n    }, {\n      Promise: constructorReducer\n    });\n\n    var _Promise= options.Promise;\n\n    return makeCancelablePromise(_Promise, function(resolve, reject, onCancel){\n      var handler;\n      if (typeof emitter.addEventListener === 'function') {\n        handler=  function () {\n          resolve(toArray.apply(null, arguments));\n        };\n\n        onCancel(function(){\n          emitter.removeEventListener(name, handler);\n        });\n\n        emitter.addEventListener(\n            name,\n            handler,\n            {once: true}\n        );\n        return;\n      }\n\n      var eventListener = function(){\n        errorListener && emitter.removeListener('error', errorListener);\n        resolve(toArray.apply(null, arguments));\n      };\n\n      var errorListener;\n\n      if (name !== 'error') {\n        errorListener = function (err){\n          emitter.removeListener(name, eventListener);\n          reject(err);\n        };\n\n        emitter.once('error', errorListener);\n      }\n\n      onCancel(function(){\n        errorListener && emitter.removeListener('error', errorListener);\n        emitter.removeListener(name, eventListener);\n      });\n\n      emitter.once(name, eventListener);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    });\n  }\n\n  var prototype= EventEmitter.prototype;\n\n  Object.defineProperties(EventEmitter, {\n    defaultMaxListeners: {\n      get: function () {\n        return prototype._maxListeners;\n      },\n      set: function (n) {\n        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {\n          throw TypeError('n must be a non-negative number')\n        }\n        prototype._maxListeners = n;\n      },\n      enumerable: true\n    },\n    once: {\n      value: once,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  Object.defineProperties(prototype, {\n      _maxListeners: {\n          value: defaultMaxListeners,\n          writable: true,\n          configurable: true\n      },\n      _observers: {value: null, writable: true, configurable: true}\n  });\n\n  if (typeof define === 'function' && define.amd) {\n     // AMD. Register as an anonymous module.\n    define(function() {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = EventEmitter;\n  }\n  else {\n    // global for any kind of environment.\n    var _global= new Function('','return this')();\n    _global.EventEmitter2 = EventEmitter;\n  }\n}();\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}