import { Signer, ethers, Contract } from 'ethers';
import { walletContracts } from '@0xsequence/abi';
import { logger } from '@0xsequence/utils';
import * as multicall from '@0xsequence/multicall';

/* tslint:disable */

/**
    Minimal upgradeable proxy implementation, delegates all calls to the address
    defined by the storage slot matching the wallet address.

    Inspired by EIP-1167 Implementation (https://eips.ethereum.org/EIPS/eip-1167)

    deployed code:

        0x00    0x36         0x36      CALLDATASIZE      cds
        0x01    0x3d         0x3d      RETURNDATASIZE    0 cds
        0x02    0x3d         0x3d      RETURNDATASIZE    0 0 cds
        0x03    0x37         0x37      CALLDATACOPY
        0x04    0x3d         0x3d      RETURNDATASIZE    0
        0x05    0x3d         0x3d      RETURNDATASIZE    0 0
        0x06    0x3d         0x3d      RETURNDATASIZE    0 0 0
        0x07    0x36         0x36      CALLDATASIZE      cds 0 0 0
        0x08    0x3d         0x3d      RETURNDATASIZE    0 cds 0 0 0
        0x09    0x30         0x30      ADDRESS           addr 0 cds 0 0 0
        0x0A    0x54         0x54      SLOAD             imp 0 cds 0 0 0
        0x0B    0x5a         0x5a      GAS               gas imp 0 cds 0 0 0
        0x0C    0xf4         0xf4      DELEGATECALL      suc 0
        0x0D    0x3d         0x3d      RETURNDATASIZE    rds suc 0
        0x0E    0x82         0x82      DUP3              0 rds suc 0
        0x0F    0x80         0x80      DUP1              0 0 rds suc 0
        0x10    0x3e         0x3e      RETURNDATACOPY    suc 0
        0x11    0x90         0x90      SWAP1             0 suc
        0x12    0x3d         0x3d      RETURNDATASIZE    rds 0 suc
        0x13    0x91         0x91      SWAP2             suc 0 rds
        0x14    0x60 0x18    0x6018    PUSH1             0x18 suc 0 rds
    /-- 0x16    0x57         0x57      JUMPI             0 rds
    |   0x17    0xfd         0xfd      REVERT
    \-> 0x18    0x5b         0x5b      JUMPDEST          0 rds
        0x19    0xf3         0xf3      RETURN

    flat deployed code: 0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3

    deploy function:

        0x00    0x60 0x3a    0x603a    PUSH1             0x3a
        0x02    0x60 0x0e    0x600e    PUSH1             0x0e 0x3a
        0x04    0x3d         0x3d      RETURNDATASIZE    0 0x0e 0x3a
        0x05    0x39         0x39      CODECOPY
        0x06    0x60 0x1a    0x601a    PUSH1             0x1a
        0x08    0x80         0x80      DUP1              0x1a 0x1a
        0x09    0x51         0x51      MLOAD             imp 0x1a
        0x0A    0x30         0x30      ADDRESS           addr imp 0x1a
        0x0B    0x55         0x55      SSTORE            0x1a
        0x0C    0x3d         0x3d      RETURNDATASIZE    0 0x1a
        0x0D    0xf3         0xf3      RETURN
        [...deployed code]

    flat deploy function: 0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3
*/
const WalletContractBytecode = '0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3';

const maxCachedConfigs = 10;
const listKey = '@sequence.config.imageHashes';

const configKey = imageHash => `@sequence.config.${imageHash}`;

let storage;

try {
  storage = localStorage;
} catch (_unused) {
  const map = new Map();
  storage = {
    getItem: key => {
      var _map$get;

      return (_map$get = map.get(key)) != null ? _map$get : null;
    },
    setItem: (key, value) => map.set(key, value),
    removeItem: key => map.delete(key)
  };
}

function getCachedConfig(imageHash) {
  var _storage$getItem;

  const config = JSON.parse((_storage$getItem = storage.getItem(configKey(imageHash))) != null ? _storage$getItem : 'null');

  if (config) {
    pushImageHash(imageHash);
    return config;
  } else {
    return;
  }
}
function cacheConfig(imageHash, config) {
  storage.setItem(configKey(imageHash), JSON.stringify(config));
  pushImageHash(imageHash);
}

function pushImageHash(imageHash) {
  var _storage$getItem2;

  let imageHashes = JSON.parse((_storage$getItem2 = storage.getItem(listKey)) != null ? _storage$getItem2 : '[]');
  imageHashes = imageHashes.filter(hash => hash !== imageHash);
  imageHashes.push(imageHash);

  while (imageHashes.length > maxCachedConfigs) {
    storage.removeItem(configKey(imageHashes.shift()));
  }

  storage.setItem(listKey, JSON.stringify(imageHashes));
}

// and control the wallet

// TODO: createWalletConfig and genConfig are very similar, lets update + remove one
const createWalletConfig = async (threshold, signers) => {
  const config = {
    threshold,
    signers: []
  };
  signers.forEach(async s => {
    config.signers.push({
      weight: s.weight,
      address: Signer.isSigner(s.signer) ? await s.signer.getAddress() : s.signer
    });
  });

  if (!isUsableConfig(config)) {
    throw new Error('wallet config is not usable');
  }

  return config;
}; // isUsableConfig checks if a the sum of the owners in the configuration meets the necessary threshold to sign a transaction
// a wallet that has a non-usable configuration is not able to perform any transactions, and can be considered as destroyed

const isUsableConfig = config => {
  const sum = config.signers.reduce((p, c) => ethers.BigNumber.from(c.weight).add(p), ethers.constants.Zero);
  return sum.gte(ethers.BigNumber.from(config.threshold));
};
const isValidConfigSigners = (config, signers) => {
  if (signers.length === 0) return true;
  const a = config.signers.map(s => ethers.utils.getAddress(s.address));
  const b = signers.map(s => ethers.utils.getAddress(s));
  let valid = true;
  b.forEach(s => {
    if (!a.includes(s)) valid = false;
  });
  return valid;
};
const addressOf = (salt, context, ignoreAddress = false) => {
  if (typeof salt === 'string') {
    const codeHash = ethers.utils.keccak256(ethers.utils.solidityPack(['bytes', 'bytes32'], [WalletContractBytecode, ethers.utils.hexZeroPad(context.mainModule, 32)]));
    const hash = ethers.utils.keccak256(ethers.utils.solidityPack(['bytes1', 'address', 'bytes32', 'bytes32'], ['0xff', context.factory, salt, codeHash]));
    return ethers.utils.getAddress(ethers.utils.hexDataSlice(hash, 12));
  }

  if (salt.address && !ignoreAddress) return salt.address;
  return addressOf(imageHash(salt), context);
};
const imageHash = config => {
  config = sortConfig(config);
  const imageHash = config.signers.reduce((imageHash, signer) => ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['bytes32', 'uint8', 'address'], [imageHash, signer.weight, signer.address])), ethers.utils.solidityPack(['uint256'], [config.threshold]));
  cacheConfig(imageHash, config);
  return imageHash;
}; // sortConfig normalizes the list of signer addreses in a WalletConfig

const sortConfig = config => {
  config.signers.sort((a, b) => compareAddr(a.address, b.address)); // normalize

  config.signers.forEach(s => s.address = ethers.utils.getAddress(s.address));
  if (config.address) config.address = ethers.utils.getAddress(config.address); // ensure no duplicate signers in the config

  const signers = config.signers.map(s => s.address);
  const signerDupes = signers.filter((c, i) => signers.indexOf(c) !== i);

  if (signerDupes.length > 0) {
    throw new Error('invalid wallet config: duplicate signer addresses detected in the config, ${signerDupes}');
  }

  return config;
};
const isConfigEqual = (a, b) => {
  return imageHash(a) === imageHash(b);
};
const compareAddr = (a, b) => {
  const bigA = ethers.BigNumber.from(a);
  const bigB = ethers.BigNumber.from(b);

  if (bigA.lt(bigB)) {
    return -1;
  } else if (bigA.eq(bigB)) {
    return 0;
  } else {
    return 1;
  }
};
function editConfig(config, args) {
  const normSigner = s => ({
    weight: ethers.BigNumber.from(s.weight).toNumber(),
    address: ethers.utils.getAddress(s.address)
  });

  const normSrcSigners = config.signers.map(normSigner);
  const normSetSigners = args.set ? args.set.map(normSigner) : [];
  const normDelAddress = args.del ? args.del.map(a => ethers.utils.getAddress(a.address)) : [];
  const normSetAddress = normSetSigners.map(s => s.address);
  const newSigners = normSrcSigners.filter(s => normDelAddress.indexOf(s.address) === -1 && normSetAddress.indexOf(s.address) === -1).concat(...normSetSigners);
  return sortConfig({
    address: config.address,
    threshold: args.threshold ? ethers.BigNumber.from(args.threshold).toNumber() : config.threshold,
    signers: newSigners
  });
} // TODO: very similar to createWalletConfig, but doesn't allow an AbstractSigner object
// TODO: lets also check isUsableConfig before returning it

function genConfig(threshold, signers) {
  return sortConfig({
    threshold: ethers.BigNumber.from(threshold).toNumber(),
    signers: signers.map(s => ({
      weight: ethers.BigNumber.from(s.weight).toNumber(),
      address: ethers.utils.getAddress(s.address)
    }))
  });
}

class ConfigFinder {
  constructor() {
    this.findCurrentConfig = void 0;
    this.findLastWalletOfInitialSigner = void 0;
  }

}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

class SequenceUtilsFinder {
  constructor(authProvider) {
    var _this = this;

    this.authProvider = authProvider;

    this.findCurrentConfig = async function (args) {
      const {
        provider,
        context,
        ignoreIndex,
        requireIndex,
        skipCache
      } = args;
      const address = ethers.utils.getAddress(args.address);
      logger.info(`[findCurrentConfig] address:${address}, ignoreIndex:${ignoreIndex}, requireIndex:${requireIndex}`);
      if (requireIndex && ignoreIndex) throw Error(`findCurrentConfig: can't ignore index and require index`);
      const chainIdPromise = provider.getNetwork();
      const knownConfigs = args.knownConfigs ? args.knownConfigs : []; // Get imageHash of wallet

      const {
        imageHash,
        config
      } = await _this.findCurrentImageHash(context, provider, address, knownConfigs, skipCache);
      if (imageHash === undefined) return {
        config: undefined
      }; // Get config for that imageHash

      const found = await _this.findConfigForImageHash(context, imageHash, config ? [config, ...knownConfigs] : knownConfigs, skipCache);
      const chainId = (await chainIdPromise).chainId;
      return {
        config: found ? _extends({}, found, {
          chainId,
          address
        }) : undefined
      };
    };

    this.findLastWalletOfInitialSigner = async function (args) {
      const {
        signer,
        context,
        ignoreIndex,
        requireIndex
      } = args;
      logger.info(`[findLastWalletOfInitialSigner] signer:${signer}`);
      if (requireIndex && ignoreIndex) throw Error(`findCurrentConfig: can't ignore index and require index`);
      const authContract = new Contract(context.sequenceUtils, walletContracts.sequenceUtils.abi, _this.authProvider);
      const logBlockHeight = ignoreIndex ? 0 : (await authContract.lastSignerUpdate(signer)).toNumber();
      if (requireIndex && logBlockHeight === 0) return {
        wallet: undefined
      };
      const filter = authContract.filters.RequiredSigner(null, signer);
      const lastLog = await _this.findLatestLog(_this.authProvider, _extends({}, filter, {
        fromBlock: logBlockHeight,
        toBlock: logBlockHeight !== 0 ? logBlockHeight : 'latest'
      }));

      if (lastLog === undefined) {
        logger.warn('publishConfig: wallet config last log not found');
        return {
          wallet: undefined
        };
      }

      const event = authContract.interface.decodeEventLog('RequiredSigner', lastLog.data, lastLog.topics);
      return {
        wallet: event._wallet
      };
    };

    this.findConfigForImageHash = async function (context, image, knownConfigs = [], skipCache = false) {
      // Lookup config in known configurations
      const found = knownConfigs.find(kc => imageHash(kc) === image);
      if (found) return found; // Lookup config in cached configurations

      if (!skipCache) {
        const cached = getCachedConfig(image);

        if (cached) {
          return cached;
        }
      }

      logger.info(`[findConfigForImageHash] image:${image}`); // Load index for last imageHash update

      const authContract = new Contract(context.sequenceUtils, walletContracts.sequenceUtils.abi, _this.authProvider);
      const imageHashHeight = (await authContract.lastImageHashUpdate(image)).toNumber(); // Get requireConfig with imageHash info

      const filter = authContract.filters.RequiredConfig(undefined, image);
      const lastLog = await _this.findLatestLog(_this.authProvider, _extends({}, filter, {
        fromBlock: imageHashHeight,
        toBlock: imageHashHeight !== 0 ? imageHashHeight : 'latest'
      })); // If there is no log, and no knownConfig...
      // the config is not found

      if (lastLog === undefined) return undefined;
      const event = authContract.interface.decodeEventLog('RequiredConfig', lastLog.data, lastLog.topics);
      const signers = ethers.utils.defaultAbiCoder.decode([`tuple(
        uint256 weight,
        address signer
      )[]`], event._signers)[0];
      const config = {
        threshold: ethers.BigNumber.from(event._threshold).toNumber(),
        signers: signers.map(s => ({
          address: s.signer,
          weight: ethers.BigNumber.from(s.weight).toNumber()
        }))
      }; // Cache this config

      imageHash(config);
      return config;
    };

    this.findCurrentImageHash = async function (context, provider, address, knownConfigs = [], skipCache) {
      logger.info(`[findCurrentImageHash] address:${address}`);
      const walletContract = new Contract(address, walletContracts.mainModuleUpgradable.abi, provider);
      const currentImageHash = await walletContract.functions.imageHash.call([]).catch(() => []); // Wallet is not counterfactual and has a defined imageHash

      if (currentImageHash[0] !== undefined) {
        return {
          imageHash: currentImageHash[0],
          config: skipCache ? undefined : getCachedConfig(currentImageHash[0])
        };
      } // Wallet is in counter-factual mode
      // Lookup config in known configurations


      const normalizedAddress = ethers.utils.getAddress(address);
      const found = knownConfigs.find(kc => addressOf(kc, context, true) === normalizedAddress);
      if (found) return {
        imageHash: imageHash(found),
        config: found
      }; // Call wallet index

      const authContract = new Contract(context.sequenceUtils, walletContracts.sequenceUtils.abi, _this.authProvider);
      const knownImageHash = await authContract.knownImageHashes(address);

      if (knownImageHash !== ethers.constants.HashZero) {
        if (addressOf(knownImageHash, context) !== address) throw Error('findCurrentImageHash: inconsistent RequireUtils results');
        return {
          imageHash: knownImageHash
        };
      } // Get known image hash from raw logs, as last resort


      const filter = authContract.filters.RequiredConfig(address);
      const log = await _this.findFirstLog(_this.authProvider, filter);

      if (log !== undefined) {
        const event = authContract.interface.decodeEventLog('RequiredConfig', log.data, log.topics);
        const signers = ethers.utils.defaultAbiCoder.decode([`tuple(
          uint256 weight,
          address signer
        )[]`], event._signers)[0];
        const config = {
          threshold: ethers.BigNumber.from(event._threshold).toNumber(),
          signers: signers.map(s => ({
            address: s.signer,
            weight: ethers.BigNumber.from(s.weight).toNumber()
          }))
        };
        const gotImageHash = imageHash(config);

        if (addressOf(gotImageHash, context) === address) {
          return {
            imageHash: gotImageHash,
            config
          };
        }
      } // Counter-factual imageHash not found


      return {};
    };

    this.findLatestLog = async function (provider, filter) {
      const toBlock = filter.toBlock === 'latest' ? await provider.getBlockNumber() : filter.toBlock;
      const fromBlock = filter.fromBlock;

      if (fromBlock === 0) {
        logger.warn(`findLatestLog: expensive getLogs query fromBlock 0 toBlock ${toBlock}`);
      }

      try {
        const logs = await provider.getLogs(_extends({}, filter, {
          toBlock: toBlock
        }));
        return logs.length === 0 ? undefined : logs[logs.length - 1];
      } catch (e) {
        // TODO Don't assume all errors are bad
        const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock);
        const nhalf = await _this.findLatestLog(provider, _extends({}, filter, {
          fromBlock: pivot,
          toBlock: toBlock
        }));
        if (nhalf !== undefined) return nhalf;
        return _this.findLatestLog(provider, _extends({}, filter, {
          fromBlock: fromBlock,
          toBlock: pivot
        }));
      }
    };

    this.findFirstLog = async function (provider, filter) {
      const toBlock = filter.toBlock === 'latest' || !filter.toBlock ? await provider.getBlockNumber() : filter.toBlock;
      const fromBlock = filter.fromBlock ? filter.fromBlock : 0;

      if (fromBlock === 0) {
        logger.warn(`findFirstLog: expensive getLogs query fromBlock 0 toBlock ${toBlock}`);
      }

      try {
        const logs = await provider.getLogs(_extends({}, filter, {
          fromBlock,
          toBlock
        }));
        return logs.length === 0 ? undefined : logs[0];
      } catch (e) {
        // TODO Don't assume all errors are bad
        const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock);
        const nhalf = await _this.findFirstLog(provider, _extends({}, filter, {
          fromBlock,
          toBlock: pivot
        }));
        if (nhalf !== undefined) return nhalf;
        return _this.findFirstLog(provider, _extends({}, filter, {
          fromBlock: pivot,
          toBlock
        }));
      }
    };
  }

}

function isDecodedAddress(cand) {
  const c = cand;
  return c.address !== undefined && !isDecodedSigner(cand);
}
function isDecodedSigner(cand) {
  return isDecodedEOASigner(cand) || isDecodedEOASplitSigner(cand) || isDecodedFullSigner(cand);
}
function isDecodedEOASigner(cand) {
  const c = cand;
  return c.signature !== undefined && c.address === undefined;
}
function isDecodedEOASplitSigner(cand) {
  const c = cand;
  return c.r !== undefined && c.s !== undefined && c.v !== undefined && c.t !== undefined;
}
function isDecodedFullSigner(cand) {
  const c = cand;
  return c.address !== undefined && c.signature !== undefined;
}
let SignatureType;

(function (SignatureType) {
  SignatureType[SignatureType["EOA"] = 0] = "EOA";
  SignatureType[SignatureType["Address"] = 1] = "Address";
  SignatureType[SignatureType["Full"] = 2] = "Full";
})(SignatureType || (SignatureType = {}));

const decodeSignature = signature => {
  if (typeof signature !== 'string') return signature;
  const auxsig = signature.replace('0x', '');
  const threshold = ethers.BigNumber.from(`0x${auxsig.slice(0, 4)}`).toNumber();
  const signers = [];

  for (let rindex = 4; rindex < auxsig.length;) {
    const signatureType = ethers.BigNumber.from(auxsig.slice(rindex, rindex + 2)).toNumber();
    rindex += 2;
    const weight = ethers.BigNumber.from(`0x${auxsig.slice(rindex, rindex + 2)}`).toNumber();
    rindex += 2;

    switch (signatureType) {
      case SignatureType.Address:
        const addr = ethers.utils.getAddress(auxsig.slice(rindex, rindex + 40));
        rindex += 40;
        signers.push({
          weight: weight,
          address: addr
        });
        break;

      case SignatureType.EOA:
        const sig = ethers.utils.arrayify(`0x${auxsig.slice(rindex, rindex + 132)}`);
        rindex += 132;
        const split = ethers.utils.splitSignature(sig.slice(0, 65));
        const r = split.r;
        const s = split.s;
        const v = split.v;
        const t = ethers.BigNumber.from(sig[sig.length - 1]).toNumber();
        signers.push({
          weight: weight,
          signature: sig,
          r: r,
          s: s,
          v: v,
          t: t
        });
        break;

      case SignatureType.Full:
        const address = ethers.utils.getAddress(auxsig.slice(rindex, rindex + 40));
        rindex += 40;
        const size = ethers.BigNumber.from(`0x${auxsig.slice(rindex, rindex + 4)}`).mul(2).toNumber();
        rindex += 4;

        const _signature = ethers.utils.arrayify(`0x${auxsig.slice(rindex, rindex + size)}`);

        rindex += size;
        signers.push({
          weight: weight,
          address: address,
          signature: _signature
        });
        break;

      default:
        throw Error('Signature type not supported');
    }
  }

  return {
    threshold: threshold,
    signers: signers
  };
};
const SIG_TYPE_EIP712 = 1;
const SIG_TYPE_ETH_SIGN = 2;
const SIG_TYPE_WALLET_BYTES32 = 3;
const splitDecodedEOASigner = sig => {
  const signature = ethers.utils.arrayify(sig.signature);
  const split = ethers.utils.splitSignature(signature.slice(0, 65));
  const t = ethers.BigNumber.from(signature[signature.length - 1]).toNumber();
  return _extends({}, sig, split, {
    t: t
  });
};
const recoverEOASigner = (digest, sig) => {
  const signature = isDecodedEOASplitSigner(sig) ? sig : splitDecodedEOASigner(sig);

  switch (signature.t) {
    case SIG_TYPE_EIP712:
      return ethers.utils.recoverAddress(digest, {
        r: signature.r,
        s: signature.s,
        v: signature.v
      });

    case SIG_TYPE_ETH_SIGN:
      const subDigest = ethers.utils.keccak256(ethers.utils.solidityPack(['string', 'bytes32'], ['\x19Ethereum Signed Message:\n32', digest]));
      return ethers.utils.recoverAddress(subDigest, {
        r: signature.r,
        s: signature.s,
        v: signature.v
      });

    default:
      throw new Error('Unknown signature');
  }
};
const joinSignatures = (...signatures) => {
  const parts = signatures.map(s => typeof s === 'string' ? decodeSignature(s) : s);
  return parts.reduce((p, c) => joinTwoSignatures(p, c));
};
const joinTwoSignatures = (a, b) => {
  return {
    threshold: a.threshold,
    signers: a.signers.map((s, i) => isDecodedAddress(s) ? b.signers[i] : s)
  };
};
const encodeSignature = sig => {
  if (typeof sig === 'string') return encodeSignature(decodeSignature(sig));
  const accountBytes = sig.signers.map(s => {
    if (isDecodedAddress(s)) {
      return ethers.utils.solidityPack(['uint8', 'uint8', 'address'], [SignatureType.Address, s.weight, s.address]);
    }

    if (isDecodedEOASplitSigner(s)) {
      return ethers.utils.solidityPack(['uint8', 'uint8', 'bytes32', 'bytes32', 'uint8', 'uint8'], [SignatureType.EOA, s.weight, s.r, s.s, s.v, s.t]);
    }

    if (isDecodedFullSigner(s)) {
      const signatureSize = ethers.utils.arrayify(s.signature).length;
      return ethers.utils.solidityPack(['uint8', 'uint8', 'address', 'uint16', 'bytes'], [SignatureType.Full, s.weight, s.address, signatureSize, s.signature]);
    }

    if (isDecodedEOASigner(s)) {
      return ethers.utils.solidityPack(['uint8', 'uint8', 'bytes'], [SignatureType.EOA, s.weight, s.signature]);
    }

    throw Error('Unkwnown signature part type');
  });
  return ethers.utils.solidityPack(['uint16', ...Array(accountBytes.length).fill('bytes')], [sig.threshold, ...accountBytes]);
};
function signerOf(part, digest) {
  if (isDecodedAddress(part)) {
    return part.address;
  }

  if (isDecodedFullSigner(part)) {
    return part.address;
  }

  if (isDecodedEOASplitSigner(part) || isDecodedEOASigner(part)) {
    return recoverEOASigner(digest, part);
  }

  throw Error('Unkwnown signature part type');
}
function mutateSignature(sig, config, digest) {
  const allSigners = sig.signers.map(s => signerOf(s, digest));
  return {
    threshold: config.threshold,
    signers: config.signers.map(s => {
      const found = allSigners.indexOf(s.address);

      if (found !== -1) {
        const part = sig.signers[found];
        return _extends({}, part, {
          weight: s.weight
        });
      }

      return {
        weight: s.weight,
        address: s.address
      };
    })
  };
}
async function buildStubSignature(provider, config) {
  const multicallProvider = new multicall.providers.MulticallProvider(provider); // Pre-load if signers are EOAs or not

  const signers = await Promise.all(config.signers.map(async (s, i) => {
    return _extends({}, s, {
      index: i,
      isEOA: ethers.utils.arrayify(await multicallProvider.getCode(s.address)).length === 0
    });
  })); // Sort signers by weight
  // and prepare them for selection

  let sortedSigners = signers.sort((a, b) => a.weight - b.weight); // Keep track of the total signing power

  let totalWeight = 0; // First pick non-eoa signers

  sortedSigners = sortedSigners.map(s => {
    if (totalWeight >= config.threshold || s.isEOA) return s;
    totalWeight += s.weight;
    return _extends({}, s, {
      willSign: true
    });
  }); // If we still haven't reached threshold
  // start picking non-EOA signers

  if (totalWeight < config.threshold) {
    sortedSigners = sortedSigners.map(s => {
      if (s.willSign || totalWeight >= config.threshold) return s;
      totalWeight += s.weight;
      return _extends({}, s, {
        willSign: true
      });
    });
  } // Stub signature part
  // pre-determined signature, tailored for worse-case scenario in gas costs


  const stubSig = ethers.utils.arrayify("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a01b02"); // Re-sort signers by original index

  const finalSigners = sortedSigners.sort((a, b) => a.index - b.index); // Map final signers to signature parts

  return {
    threshold: config.threshold,
    signers: finalSigners.map(s => {
      // If wallet shouldn't sign
      // just return address part
      if (!s.willSign) {
        return {
          address: s.address,
          weight: s.weight
        };
      } // If wallet is EOA return signature
      // part is with stubSign


      if (s.isEOA) {
        return {
          weight: s.weight,
          signature: stubSig
        };
      } // If wallet is a contract
      // build a stub nested signature


      return {
        weight: s.weight,
        address: s.address,
        signature: encodeSignature({
          threshold: 1,
          signers: [{
            address: ethers.Wallet.createRandom().address,
            weight: 1
          }, {
            weight: 1,
            signature: stubSig
          }]
        }) + ethers.utils.hexlify(SIG_TYPE_WALLET_BYTES32).substring(2)
      };
    })
  };
}

export { ConfigFinder, SequenceUtilsFinder, SignatureType, WalletContractBytecode, addressOf, buildStubSignature, compareAddr, createWalletConfig, decodeSignature, editConfig, encodeSignature, genConfig, imageHash, isConfigEqual, isDecodedAddress, isDecodedEOASigner, isDecodedEOASplitSigner, isDecodedFullSigner, isDecodedSigner, isUsableConfig, isValidConfigSigners, joinSignatures, joinTwoSignatures, mutateSignature, recoverEOASigner, signerOf, sortConfig, splitDecodedEOASigner };
