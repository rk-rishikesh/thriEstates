import { Signer as AbstractSigner } from 'ethers';
import { TypedDataDomain, TypedDataField } from '@ethersproject/abstract-signer';
import { NetworkConfig, ChainIdLike, WalletContext } from '@0xsequence/network';
import { FeeQuote, Relayer } from '@0xsequence/relayer';
import { SignedTransactions, Transactionish, TransactionRequest, Transaction, TransactionResponse } from '@0xsequence/transactions';
import { JsonRpcProvider } from '@ethersproject/providers';
import { BytesLike } from '@ethersproject/bytes';
import { Deferrable } from '@0xsequence/utils';
import { WalletConfig, WalletState } from '@0xsequence/config';
export declare abstract class Signer extends AbstractSigner {
    static isSequenceSigner(cand: any): cand is Signer;
    abstract getProvider(chainId?: number): Promise<JsonRpcProvider | undefined>;
    abstract getRelayer(chainId?: number): Promise<Relayer | undefined>;
    abstract getWalletContext(): Promise<WalletContext>;
    abstract getWalletConfig(chainId?: ChainIdLike): Promise<WalletConfig[]>;
    abstract getWalletState(chainId?: ChainIdLike): Promise<WalletState[]>;
    abstract getNetworks(): Promise<NetworkConfig[]>;
    abstract getSigners(): Promise<string[]>;
    abstract signMessage(message: BytesLike, chainId?: ChainIdLike, allSigners?: boolean, isDigest?: boolean): Promise<string>;
    abstract signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, message: Record<string, any>, chainId?: ChainIdLike, allSigners?: boolean): Promise<string>;
    abstract sendTransaction(transaction: Deferrable<Transactionish>, chainId?: ChainIdLike, allSigners?: boolean, quote?: FeeQuote): Promise<TransactionResponse>;
    abstract sendTransactionBatch(transactions: Deferrable<TransactionRequest[] | Transaction[]>, chainId?: ChainIdLike, allSigners?: boolean, quote?: FeeQuote): Promise<TransactionResponse>;
    abstract signTransactions(txs: Deferrable<Transactionish>, chainId?: ChainIdLike, allSigners?: boolean): Promise<SignedTransactions>;
    abstract sendSignedTransactions(signedTxs: SignedTransactions, chainId?: ChainIdLike, quote?: FeeQuote): Promise<TransactionResponse>;
    abstract updateConfig(newConfig?: WalletConfig): Promise<[WalletConfig, TransactionResponse | undefined]>;
    abstract publishConfig(): Promise<TransactionResponse | undefined>;
    abstract isDeployed(chainId?: ChainIdLike): Promise<boolean>;
}
export declare type SignedTransactionsCallback = (signedTxs: SignedTransactions, metaTxnHash: string) => void;
export declare function isSequenceSigner(signer: AbstractSigner): signer is Signer;
export declare class InvalidSigner extends Error {
}
export declare class NotEnoughSigners extends Error {
}
