import { Provider, BlockTag, JsonRpcProvider } from '@ethersproject/providers';
import { BigNumber, BigNumberish, Signer as AbstractSigner } from 'ethers';
import { TypedDataDomain, TypedDataField } from '@ethersproject/abstract-signer';
import { BytesLike } from '@ethersproject/bytes';
import { Deferrable } from '@ethersproject/properties';
import { ConnectionInfo } from '@ethersproject/web';
import { Transaction, Transactionish, TransactionRequest, SignedTransactions, TransactionResponse } from '@0xsequence/transactions';
import { FeeQuote, Relayer } from '@0xsequence/relayer';
import { ChainIdLike, WalletContext, JsonRpcSender, NetworkConfig } from '@0xsequence/network';
import { WalletConfig, WalletState } from '@0xsequence/config';
import { Signer, SignedTransactionsCallback } from './signer';
export interface WalletOptions {
    config: WalletConfig;
    context?: WalletContext;
    strict?: boolean;
}
export declare class Wallet extends Signer {
    readonly context: WalletContext;
    readonly config: WalletConfig;
    private readonly _signers;
    provider: JsonRpcProvider;
    sender: JsonRpcSender;
    relayer: Relayer;
    chainId?: number;
    constructor(options: WalletOptions, ...signers: (BytesLike | AbstractSigner)[]);
    useConfig(config: WalletConfig, strict?: boolean): Wallet;
    useSigners(...signers: (BytesLike | AbstractSigner)[]): Wallet;
    connect(provider: Provider, relayer?: Relayer): Wallet;
    setProvider(provider: JsonRpcProvider | ConnectionInfo | string): Wallet;
    setRelayer(relayer: Relayer): Wallet;
    getProvider(chainId?: number): Promise<JsonRpcProvider>;
    getRelayer(chainId?: number): Promise<Relayer>;
    getWalletContext(): Promise<WalletContext>;
    getWalletConfig(chainId?: ChainIdLike): Promise<WalletConfig[]>;
    getWalletState(_?: ChainIdLike): Promise<WalletState[]>;
    get connected(): boolean;
    get address(): string;
    get imageHash(): string;
    getAddress(): Promise<string>;
    getSigners(): Promise<string[]>;
    getChainId(): Promise<number>;
    getNetworks(): Promise<NetworkConfig[]>;
    getNonce(blockTag?: BlockTag, space?: BigNumberish): Promise<BigNumberish>;
    getTransactionCount(blockTag?: BlockTag): Promise<number>;
    sendTransaction(transaction: Deferrable<Transactionish>, chainId?: ChainIdLike, allSigners?: boolean, quote?: FeeQuote, callback?: SignedTransactionsCallback): Promise<TransactionResponse>;
    sendTransactionBatch(transactions: Deferrable<TransactionRequest[] | Transaction[]>, chainId?: ChainIdLike, allSigners?: boolean, quote?: FeeQuote, callback?: SignedTransactionsCallback): Promise<TransactionResponse>;
    signTransactions(txs: Deferrable<Transactionish>, chainId?: ChainIdLike, allSigners?: boolean): Promise<SignedTransactions>;
    sendSignedTransactions(signedTxs: SignedTransactions, chainId?: ChainIdLike, quote?: FeeQuote): Promise<TransactionResponse>;
    signMessage(message: BytesLike, chainId?: ChainIdLike, allSigners?: boolean, isDigest?: boolean): Promise<string>;
    signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, message: Record<string, any>, chainId?: ChainIdLike, allSigners?: boolean): Promise<string>;
    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, message: Record<string, any>, chainId?: ChainIdLike, allSigners?: boolean): Promise<string>;
    subDigest(digest: BytesLike, chainId?: ChainIdLike): Promise<Uint8Array>;
    sign(msg: BytesLike, isDigest?: boolean, chainId?: ChainIdLike, allSigners?: boolean): Promise<string>;
    signWeight(): Promise<BigNumber>;
    isDeployed(chainId?: ChainIdLike): Promise<boolean>;
    updateConfig(config?: WalletConfig, nonce?: number, publish?: boolean, indexed?: boolean, quote?: FeeQuote, callback?: SignedTransactionsCallback): Promise<[WalletConfig, TransactionResponse]>;
    publishConfig(indexed?: boolean, nonce?: number, requireFreshSigners?: string[], quote?: FeeQuote, callback?: SignedTransactionsCallback): Promise<TransactionResponse>;
    buildUpdateConfigTransaction(config: WalletConfig, publish?: boolean, indexed?: boolean): Promise<Transaction[]>;
    buildPublishConfigTransaction(config: WalletConfig, indexed?: boolean, nonce?: number): Transaction[];
    buildPublishSignersTransaction(indexed?: boolean, nonce?: number, requireFreshSigners?: string[]): Promise<Transaction[]>;
    private getChainIdNumber;
    private packMsgAndSig;
    signTransaction(_: Deferrable<TransactionRequest>): Promise<string>;
    static singleOwner(owner: BytesLike | AbstractSigner, context?: WalletContext): Promise<Wallet>;
    hasEnoughSigners(chainId?: ChainIdLike): Promise<boolean>;
}
