import { Signer as Signer$1, ethers, BigNumber, Contract } from 'ethers';
import { decodeNonce, computeMetaTxnHash, fromTransactionish, readSequenceNonce, appendNonce, digestOfTransactionsNonce, sequenceTxAbiEncode } from '@0xsequence/transactions';
import { isUsableConfig, sortConfig, addressOf, imageHash, isDecodedSigner, encodeSignature, joinSignatures, compareAddr, decodeSignature, isDecodedFullSigner, recoverEOASigner, SequenceUtilsFinder, isConfigEqual, isDecodedEOASigner, isDecodedAddress } from '@0xsequence/config';
import { ChainId, sequenceContext, isJsonRpcProvider, JsonRpcSender, getChainId, mainnetNetworks, ensureValidNetworks, sortNetworks } from '@0xsequence/network';
import { Provider, JsonRpcProvider } from '@ethersproject/providers';
import { Interface } from '@ethersproject/abi';
import { walletContracts } from '@0xsequence/abi';
import { encodeTypedDataDigest, subDigestOf, packMessageData } from '@0xsequence/utils';
import fetchPonyfill from 'fetch-ponyfill';
import { GuarddService } from '@0xsequence/guard';
import { resolveProperties } from '@ethersproject/properties';
import { isRelayer, isRpcRelayerOptions, RpcRelayer } from '@0xsequence/relayer';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

class Signer extends Signer$1 {
  static isSequenceSigner(cand) {
    return isSequenceSigner(cand);
  }

}
function isSequenceSigner(signer) {
  const cand = signer;
  return cand && cand.updateConfig !== undefined && cand.publishConfig !== undefined && cand.getWalletContext !== undefined && cand.getWalletConfig !== undefined;
} // TODO: move to error.ts, along with others..

class InvalidSigner extends Error {}
class NotEnoughSigners extends Error {}

class RemoteSigner extends Signer$1 {
  signMessage(message, chainId) {
    return this.signMessageWithData(message);
  }

  sendTransaction(_) {
    throw new Error('sendTransaction method is not supported in RemoteSigner');
  }

  signTransaction(_) {
    throw new Error('signTransaction method is not supported in RemoteSigner');
  }

  connect(_) {
    throw new Error('connect method is not supported in RemoteSigner');
  }

  static signMessageWithData(signer, message, data, chainId) {
    if (this.isRemoteSigner(signer)) {
      return signer.signMessageWithData(message, data, chainId);
    }

    return signer.signMessage(message);
  }

  static isRemoteSigner(signer) {
    return signer.signMessageWithData !== undefined;
  }

}

class GuardRemoteSigner extends RemoteSigner {
  constructor(address, hostname, isSequence = false, defaultChainId = ChainId.MAINNET) {
    super();
    this.isSequence = isSequence;
    this.defaultChainId = defaultChainId;
    this._guardd = void 0;
    this._address = void 0;
    this._guardd = new GuarddService(hostname, fetchPonyfill().fetch);
    this._address = address;
  }

  async signMessageWithData(message, auxData, chainId) {
    const request = {
      msg: ethers.utils.hexlify(message),
      auxData: ethers.utils.hexlify(auxData ? auxData : []),
      chainId: chainId ? BigNumber.from(chainId).toNumber() : this.defaultChainId
    };
    const res = await this._guardd.sign({
      request: request
    }); // TODO: The guardd service doesn't include the EIP2126 signature type on it's reponse
    // maybe it should be more explicit and include it? the EIP2126 is only required for non-sequence signatures

    return this.isSequence ? res.sig : res.sig + '02';
  }

  async getAddress() {
    return this._address;
  }

}

class LocalRemoteSigner extends RemoteSigner {
  constructor(signer) {
    super();
    this._signer = void 0;
    this._signer = signer;
  }

  signMessageWithData(message, _) {
    return this._signer.signMessage(message);
  }

  getAddress() {
    return this._signer.getAddress();
  }

}

async function resolveArrayProperties(object) {
  if (Array.isArray(object)) {
    // T must include array type
    return Promise.all(object.map(o => resolveProperties(o)));
  }

  return resolveProperties(object);
}
async function findLatestLog(provider, filter) {
  const toBlock = filter.toBlock === 'latest' ? await provider.getBlockNumber() : filter.toBlock;
  const fromBlock = filter.fromBlock;

  try {
    const logs = await provider.getLogs(_extends({}, filter, {
      toBlock: toBlock
    }));
    return logs.length === 0 ? undefined : logs[logs.length - 1];
  } catch (e) {
    // TODO Don't assume all errors are bad
    const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock);
    const nhalf = await findLatestLog(provider, _extends({}, filter, {
      fromBlock: pivot,
      toBlock: toBlock
    }));
    if (nhalf !== undefined) return nhalf;
    return findLatestLog(provider, _extends({}, filter, {
      fromBlock: fromBlock,
      toBlock: pivot
    }));
  }
}

//
// Wallet allows managing the account/wallet sub-keys, wallet address, signing
// messages, signing transactions and updating/deploying the wallet config on a specific chain.
//
// Wallet instances represent a wallet at a particular config-state, in someways, the Wallet
// instance is immutable, and if you update the config, then you'll need to call useConfig()
// to instantiate a new Wallet instance with the updated config.

class Wallet extends Signer {
  // provider is an Ethereum Json RPC provider that is connected to a particular network (aka chain)
  // and access to the signer for signing transactions.
  // sender is a minimal Json RPC sender interface. It's here for convenience for other web3
  // interfaces to use.
  // relayer dispatches transactions to an Ethereum node directly
  // or through a remote transaction Web Service.
  // chainId is the node network id, used for memoization
  constructor(options, ...signers) {
    super();
    this.context = void 0;
    this.config = void 0;
    this._signers = void 0;
    this.provider = void 0;
    this.sender = void 0;
    this.relayer = void 0;
    this.chainId = void 0;
    const {
      config,
      context,
      strict
    } = options;

    if (context) {
      this.context = _extends({}, context);
    } else {
      // default context is to use @0xsequence/network deployed context
      this.context = _extends({}, sequenceContext);
    }

    if (strict === true) {
      this.context.nonStrict = undefined;
    } else if (strict === false) {
      this.context.nonStrict = true;
    }

    if (!this.context.nonStrict && !isUsableConfig(config)) {
      throw new Error('wallet config is not usable (strict mode)');
    }

    this.config = sortConfig(config);
    this._signers = signers.map(s => Signer$1.isSigner(s) ? s : new ethers.Wallet(s)); // cache wallet config for future imageHash lookups

    this.imageHash;
  } // useConfig creates a new Wallet instance with the provided config, and uses the current provider
  // and relayer. It's common to initialize a counter-factual / undeployed wallet by initializing
  // it with the Wallet's init config, then calling useConfig() with the most-up-to-date config,
  // ie. new Wallet({ config: initConfig }).useConfig(latestConfig).useSigners(signers)


  useConfig(config, strict) {
    return new Wallet({
      config,
      context: this.context,
      strict
    }, ...this._signers).setProvider(this.provider).setRelayer(this.relayer);
  }

  useSigners(...signers) {
    return new Wallet({
      config: this.config,
      context: this.context
    }, ...signers).setProvider(this.provider).setRelayer(this.relayer);
  } // connect is a short-hand to create an Account instance and set the provider and relayer.
  //
  // The connect method is defined on the AbstractSigner as connect(Provider): AbstractSigner


  connect(provider, relayer) {
    if (isJsonRpcProvider(provider)) {
      return new Wallet({
        config: this.config,
        context: this.context
      }, ...this._signers).setProvider(provider).setRelayer(relayer);
    } else {
      throw new Error('Wallet provider argument is expected to be a JsonRpcProvider');
    }
  } // setProvider assigns a json-rpc provider to this wallet instance


  setProvider(provider) {
    if (provider === undefined) return this;

    if (Provider.isProvider(provider)) {
      this.provider = provider;
      this.sender = new JsonRpcSender(provider);
    } else {
      const jsonProvider = new JsonRpcProvider(provider);
      this.provider = jsonProvider;
      this.sender = new JsonRpcSender(jsonProvider);
    }

    this.chainId = undefined; // reset chainId value

    return this;
  } // setRelayer assigns a Sequence transaction relayer to this wallet instance


  setRelayer(relayer) {
    if (relayer === undefined) return this;
    this.relayer = relayer;
    return this;
  }

  async getProvider(chainId) {
    if (chainId) await this.getChainIdNumber(chainId);
    return this.provider;
  }

  async getRelayer(chainId) {
    if (chainId) await this.getChainIdNumber(chainId);
    return this.relayer;
  }

  async getWalletContext() {
    return this.context;
  }

  async getWalletConfig(chainId) {
    chainId = await this.getChainIdNumber(chainId);

    const config = _extends({}, this.config, {
      chainId
    });

    return [config];
  }

  async getWalletState(_) {
    const [address, chainId, isDeployed] = await Promise.all([this.getAddress(), this.getChainId(), this.isDeployed()]);
    const state = {
      context: this.context,
      config: this.config,
      address: address,
      chainId: chainId,
      deployed: isDeployed,
      imageHash: this.imageHash,
      lastImageHash: isDeployed ? await fetchImageHash(this) : undefined
    }; // TODO: set published boolean by checking if we have the latest logs
    // that compute to the same hash as in lastImageHash

    return [state];
  } // connected reports if json-rpc provider has been connected


  get connected() {
    return this.sender !== undefined;
  } // address returns the address of the wallet account address


  get address() {
    return addressOf(this.config, this.context);
  } // imageHash is the unique hash of the WalletConfig


  get imageHash() {
    return imageHash(this.config);
  } // getAddress returns the address of the wallet account address
  //
  // The getAddress method is defined on the AbstractSigner


  async getAddress() {
    return this.address;
  } // getSigners returns the list of public account addresses to the currently connected
  // signer objects for this wallet. Note: for a complete list of configured signers
  // on the wallet, query getWalletConfig()


  async getSigners() {
    if (!this._signers || this._signers.length === 0) {
      return [];
    }

    return Promise.all(this._signers.map(s => s.getAddress().then(s => ethers.utils.getAddress(s))));
  } // chainId returns the network connected to this wallet instance


  async getChainId() {
    if (this.chainId) return this.chainId;

    if (!this.provider) {
      throw new Error('provider is not set, first connect a provider');
    }

    this.chainId = (await this.provider.getNetwork()).chainId;
    return this.chainId;
  }

  async getNetworks() {
    const chainId = await this.getChainId();
    return [{
      chainId: chainId,
      name: '',
      rpcUrl: ''
    }];
  } // getNonce returns the transaction nonce for this wallet, via the relayer


  async getNonce(blockTag, space) {
    return this.relayer.getNonce(this.config, this.context, space, blockTag);
  } // getTransactionCount returns the number of transactions (aka nonce)
  //
  // getTransactionCount method is defined on the AbstractSigner


  async getTransactionCount(blockTag) {
    const encodedNonce = await this.getNonce(blockTag, 0);
    const [_, decodedNonce] = decodeNonce(encodedNonce);
    return ethers.BigNumber.from(decodedNonce).toNumber();
  } // sendTransaction will dispatch the transaction to the relayer for submission to the network.


  async sendTransaction(transaction, chainId, allSigners, quote, callback) {
    const signedTxs = await this.signTransactions(transaction, chainId, allSigners);

    if (callback) {
      const address = addressOf(signedTxs.config, signedTxs.context);
      const metaTxnHash = computeMetaTxnHash(address, signedTxs.chainId, ...signedTxs.transactions);
      callback(signedTxs, metaTxnHash);
    }

    return this.relayer.relay(signedTxs, quote);
  } // sendTransactionBatch is a sugar for better readability, but is the same as sendTransaction


  async sendTransactionBatch(transactions, chainId, allSigners = true, quote, callback) {
    return this.sendTransaction(transactions, chainId, allSigners, quote, callback);
  } // signTransactions will sign a Sequence transaction with the wallet signers
  //
  // NOTE: the txs argument of type Transactionish can accept one or many transactions.


  async signTransactions(txs, chainId, allSigners) {
    const signChainId = await this.getChainIdNumber(chainId);
    const transaction = await resolveArrayProperties(txs);

    if (!this.provider) {
      throw new Error('missing provider');
    }

    if (!this.relayer) {
      throw new Error('missing relayer');
    } // Convert Transactionish into Sequence transactions


    let stx = await fromTransactionish(this.context, this.address, transaction); // If a transaction has 0 gasLimit and not revertOnError
    // compute all new gas limits

    if (stx.find(a => !a.revertOnError && ethers.BigNumber.from(a.gasLimit || 0).eq(ethers.constants.Zero))) {
      stx = await this.relayer.estimateGasLimits(this.config, this.context, ...stx);
    } // If provided nonce append it to all other transactions
    // otherwise get next nonce for this wallet


    const providedNonce = readSequenceNonce(...stx);
    const nonce = providedNonce ? providedNonce : await this.getNonce();
    stx = appendNonce(stx, nonce); // Get transactions digest

    const digest = digestOfTransactionsNonce(nonce, ...stx); // Bundle with signature

    return {
      digest: digest,
      chainId: signChainId,
      context: this.context,
      config: this.config,
      transactions: stx,
      nonce,
      signature: await this.sign(digest, true, chainId, allSigners)
    };
  }

  async sendSignedTransactions(signedTxs, chainId, quote) {
    if (!this.relayer) {
      throw new Error('relayer is not set, first connect a relayer');
    }

    await this.getChainIdNumber(chainId);
    return this.relayer.relay(signedTxs, quote);
  } // signMessage will sign a message for a particular chainId with the wallet signers
  //
  // NOTE: signMessage(message: Bytes | string): Promise<string> is defined on AbstractSigner


  async signMessage(message, chainId, allSigners, isDigest = false) {
    const data = typeof message === 'string' && !message.startsWith('0x') ? ethers.utils.toUtf8Bytes(message) : message;
    return this.sign(data, isDigest, chainId, allSigners);
  }

  async signTypedData(domain, types, message, chainId, allSigners) {
    const signChainId = await this.getChainIdNumber(chainId);
    const domainChainId = domain.chainId ? BigNumber.from(domain.chainId).toNumber() : undefined;

    if (domainChainId && domainChainId !== signChainId) {
      throw new Error(`signTypedData: domain.chainId (${domain.chainId}) is expected to be ${signChainId}`);
    }

    const hash = encodeTypedDataDigest({
      domain,
      types,
      message
    });
    return this.sign(hash, true, signChainId, allSigners);
  }

  async _signTypedData(domain, types, message, chainId, allSigners) {
    return this.signTypedData(domain, types, message, chainId, allSigners);
  }

  async subDigest(digest, chainId) {
    const solvedChainId = await this.getChainIdNumber(chainId);
    return ethers.utils.arrayify(subDigestOf(this.address, solvedChainId, digest));
  } // sign is a helper method to sign a payload with the wallet signers


  async sign(msg, isDigest = true, chainId, allSigners) {
    var _this = this;

    const signChainId = await this.getChainIdNumber(chainId);
    const digest = isDigest ? msg : ethers.utils.keccak256(msg); // Generate sub-digest

    const subDigest = await this.subDigest(digest, chainId); // Sign sub-digest using a set of signers and some optional data

    const signWith = async function signWith(signers, auxData) {
      const signersAddr = await Promise.all(signers.map(s => s.getAddress()));
      const parts = await Promise.all(_this.config.signers.map(async function (s) {
        try {
          const signer = signers[signersAddr.indexOf(s.address)]; // Is not a signer, return config entry as-is

          if (!signer) {
            return s;
          } // Is another Sequence wallet as signer, sign and append '03' (ERC1271 type)


          if (isSequenceSigner(signer)) {
            if (signer === _this) throw Error("Can't sign transactions for self");
            const signature = (await signer.signMessage(subDigest, signChainId, allSigners, true)) + '03';
            return _extends({}, s, {
              signature: signature
            });
          } // Is remote signer, call and deduce signature type


          if (RemoteSigner.isRemoteSigner(signer)) {
            const signature = await signer.signMessageWithData(subDigest, auxData, signChainId);

            try {
              // Check if signature can be recovered as EOA signature
              const isEOASignature = recoverEOASigner(subDigest, {
                weight: s.weight,
                signature: signature
              }) === s.address;

              if (isEOASignature) {
                // Exclude address on EOA signatures
                return {
                  weight: s.weight,
                  signature: signature
                };
              }
            } catch (_unused) {} // Prepare signature for full encoding


            return _extends({}, s, {
              signature: signature
            });
          } // Is EOA signer


          return {
            weight: s.weight,
            signature: (await signer.signMessage(subDigest)) + '02'
          };
        } catch (err) {
          if (allSigners) {
            throw err;
          } else {
            console.warn(`Skipped signer ${s.address}`);
            return s;
          }
        }
      }));
      return {
        threshold: _this.config.threshold,
        signers: parts
      };
    }; // Sign message first using localSigners


    const localSigners = this._signers.filter(s => !RemoteSigner.isRemoteSigner(s));

    const localSignature = await signWith(localSigners, this.packMsgAndSig(digest, [], signChainId)); // Skip remote signers if we already meet threshold

    const totalWeight = localSignature.signers.filter(isDecodedSigner).reduce((totalWeight, signer) => totalWeight + signer.weight, 0);

    if (totalWeight >= this.config.threshold) {
      return encodeSignature(localSignature);
    } // include local signatures for remote signers


    const remoteSigners = this._signers.filter(s => RemoteSigner.isRemoteSigner(s));

    const remoteSignature = await signWith(remoteSigners, this.packMsgAndSig(digest, encodeSignature(localSignature), signChainId)); // Aggregate both local and remote signatures

    return encodeSignature(joinSignatures(localSignature, remoteSignature));
  } // signWeight will return the total weight of all signers available based on the config


  async signWeight() {
    const signers = await this.getSigners();
    return signers.reduce((p, s) => {
      const sconfig = this.config.signers.find(c => c.address === s);
      if (!sconfig) return p;
      return p.add(sconfig.weight);
    }, ethers.constants.Zero);
  }

  async isDeployed(chainId) {
    await this.getChainIdNumber(chainId);
    const walletCode = await this.provider.getCode(this.address);
    return !!walletCode && walletCode !== '0x';
  } // updateConfig will build an updated config transaction and send it to the Ethereum
  // network via the relayer. Note, the updated wallet config is stored as an image hash,
  // unlike `publishConfig` which will store the entire WalletConfig object in logs.


  async updateConfig(config, nonce, publish = false, indexed, quote, callback) {
    if (!config) config = this.config;
    const [txs, n] = await Promise.all([this.buildUpdateConfigTransaction(config, publish, indexed), nonce != null ? nonce : this.getNonce()]);
    return [_extends({
      address: this.address
    }, config), await this.sendTransaction(appendNonce(txs, n), undefined, undefined, quote, callback)];
  } // publishConfig will publish the current wallet config to the network via the relayer.
  // Publishing the config will also store the entire object of signers.


  async publishConfig(indexed, nonce, requireFreshSigners = [], quote, callback) {
    return this.sendTransaction(this.config.address ? this.buildPublishConfigTransaction(this.config, indexed, nonce) : await this.buildPublishSignersTransaction(indexed, nonce, requireFreshSigners), undefined, undefined, quote, callback);
  } // buildUpdateConfigTransaction creates a transaction to update the imageHash of the wallet's config
  // on chain. Note, the transaction is not sent to the network by this method.
  //
  // The `publish` argument when true will also store the contents of the WalletConfig to a chain's logs.


  async buildUpdateConfigTransaction(config, publish = false, indexed) {
    var _this2 = this;

    if (!this.context.nonStrict && !isUsableConfig(config)) throw new Error('wallet config is not usable (strict mode)');
    const isUpgradable = await async function () {
      try {
        const implementation = await _this2.provider.getStorageAt(_this2.address, ethers.utils.defaultAbiCoder.encode(['address'], [_this2.address]));
        return compareAddr(implementation, _this2.context.mainModuleUpgradable) === 0;
      } catch (_unused2) {
        return false;
      }
    }();
    const walletInterface = new Interface(walletContracts.mainModule.abi); // empirically, this seems to work for the tests:
    // const gasLimit = 100000 + 1800 * config.signers.length
    //
    // but we're going to play it safe with this instead:

    const gasLimit = 2 * (100000 + 1800 * config.signers.length);
    const preTransaction = isUpgradable ? [] : [{
      delegateCall: false,
      revertOnError: true,
      gasLimit: ethers.constants.Zero,
      to: this.address,
      value: ethers.constants.Zero,
      data: walletInterface.encodeFunctionData(walletInterface.getFunction('updateImplementation'), [this.context.mainModuleUpgradable])
    }];
    const mainModuleInterface = new Interface(walletContracts.mainModuleUpgradable.abi);
    const transaction = {
      delegateCall: false,
      revertOnError: true,
      gasLimit: ethers.constants.Zero,
      to: this.address,
      value: ethers.constants.Zero,
      data: mainModuleInterface.encodeFunctionData(mainModuleInterface.getFunction('updateImageHash'), [imageHash(config)])
    };
    const postTransaction = publish ? await this.buildPublishConfigTransaction(config, indexed) : [];
    const transactions = [...preTransaction, transaction, ...postTransaction]; // If update config reguires a single transaction
    // skip nested selfExecute bundle

    if (transactions.length === 1) {
      return transactions;
    }

    return [{
      delegateCall: false,
      revertOnError: false,
      gasLimit: gasLimit,
      to: this.address,
      value: ethers.constants.Zero,
      data: walletInterface.encodeFunctionData(walletInterface.getFunction('selfExecute'), [sequenceTxAbiEncode(transactions)])
    }];
  }

  buildPublishConfigTransaction(config, indexed = true, nonce) {
    const sequenceUtilsInterface = new Interface(walletContracts.sequenceUtils.abi);
    return [{
      delegateCall: false,
      revertOnError: true,
      gasLimit: ethers.constants.Zero,
      to: this.context.sequenceUtils,
      value: ethers.constants.Zero,
      nonce: nonce,
      data: sequenceUtilsInterface.encodeFunctionData(sequenceUtilsInterface.getFunction('publishConfig'), [this.address, config.threshold, sortConfig(config).signers.map(s => ({
        weight: s.weight,
        signer: s.address
      })), indexed])
    }];
  }

  async buildPublishSignersTransaction(indexed = true, nonce, requireFreshSigners = []) {
    var _this$context$libs;

    const sequenceUtilsInterface = new Interface(walletContracts.sequenceUtils.abi);
    const requireFreshSignersInterface = new Interface(walletContracts.requireFreshSigner.abi);
    const message = ethers.utils.randomBytes(32);
    const signature = await this.signMessage(message, this.chainId, false); // TODO: This is only required because RequireUtils doesn't support dynamic signatures
    // remove this filtering of dynamic once a new version of RequireUtils is deployed

    const decodedSignature = decodeSignature(signature);
    const filteredSignature = encodeSignature({
      threshold: decodedSignature.threshold,
      signers: decodedSignature.signers.map((s, i) => {
        if (isDecodedFullSigner(s)) {
          const a = this.config.signers[i];
          return {
            weight: a.weight,
            address: a.address
          };
        }

        return s;
      })
    });
    const contextRequireFreshSigner = (_this$context$libs = this.context.libs) == null ? void 0 : _this$context$libs.requireFreshSigner;

    if (requireFreshSigners.length > 0 && contextRequireFreshSigner === undefined) {
      throw Error('requireFreshSigners missing library');
    }

    return [...requireFreshSigners.map(signer => ({
      delegateCall: false,
      revertOnError: true,
      gasLimit: ethers.constants.Zero,
      to: contextRequireFreshSigner,
      value: ethers.constants.Zero,
      nonce: nonce,
      data: requireFreshSignersInterface.encodeFunctionData(requireFreshSignersInterface.getFunction('requireFreshSigner'), [signer])
    })), {
      delegateCall: false,
      revertOnError: true,
      gasLimit: ethers.constants.Zero,
      to: this.context.sequenceUtils,
      value: ethers.constants.Zero,
      nonce: nonce,
      data: sequenceUtilsInterface.encodeFunctionData(sequenceUtilsInterface.getFunction('publishInitialSigners'), [this.address, ethers.utils.keccak256(message), this.config.signers.length, filteredSignature, indexed])
    }];
  } // getChainIdFromArgument will return the chainId of the argument, as well as ensure
  // we're not providing an invalid chainId that isn't connected to this wallet.


  async getChainIdNumber(chainId) {
    if (!chainId) {
      // it's valid for chainId argument to be undefined, in which case
      // we will use the connected value
      return await this.getChainId();
    }

    const id = getChainId(chainId);

    if (this.context.nonStrict) {
      // in non-strict mode, just return the chainId from argument
      return id;
    }

    const connectedChainId = await this.getChainId();

    if (connectedChainId !== id) {
      throw new Error(`the specified chainId ${id} does not match the wallet's connected chainId ${connectedChainId}`);
    }

    return connectedChainId;
  } // packMsgAndSig is used by RemoteSigners to include details as a string blob of data.


  packMsgAndSig(msg, sig, chainId) {
    return ethers.utils.defaultAbiCoder.encode(['address', 'uint256', 'bytes', 'bytes'], [this.address, chainId, msg, sig]);
  }

  signTransaction(_) {
    throw new Error('signTransaction method is not supported in Wallet, please use signTransactions(...)');
  } // singleOwner will create a Wallet instance with a single signer (ie. from a single EOA account)


  static async singleOwner(owner, context) {
    const signer = Signer$1.isSigner(owner) ? owner : new ethers.Wallet(owner);
    const config = {
      threshold: 1,
      signers: [{
        weight: 1,
        address: ethers.utils.getAddress(await signer.getAddress())
      }]
    };
    return new Wallet({
      config,
      context
    }, signer);
  }

  async hasEnoughSigners(chainId) {
    if (chainId) await this.getChainIdNumber(chainId);
    return (await this.signWeight()).gte(this.config.threshold);
  }

}

// Account is an interface to a multi-network smart contract wallet.
class Account extends Signer {
  // provider points at the main chain for compatability with the Signer.
  // Use getProvider(chainId) to get the provider for the respective network.
  // memoized value
  constructor(options, ...signers) {
    super();
    this.options = void 0;
    this._wallets = void 0;
    this._signers = void 0;
    this.provider = void 0;
    this._chainId = void 0;
    this.options = options;
    this._signers = signers; // Use deployed wallet context by default if not provided

    if (!options.context) this.options.context = _extends({}, sequenceContext); // Network config, defaults will be used if none are provided

    if (this.options.networks) {
      this.setNetworks(this.options.networks);
    } else {
      this.setNetworks([...mainnetNetworks]);
    }
  }

  useSigners(...signers) {
    this._signers = signers;

    this._wallets.forEach(w => {
      w.wallet = w.wallet.useSigners(...signers);
    });

    return this;
  }

  async getWalletContext() {
    return this.options.context;
  }

  getConfigFinder() {
    if (this.options.configFinder) return this.options.configFinder;
    return new SequenceUtilsFinder(this.authWallet().wallet.provider);
  } // getWalletConfig builds a list of WalletConfigs across all networks.
  // This is useful to shows all keys/devices connected to a wallet across networks.


  async getWalletConfig(chainId) {
    let wallets = [];

    if (chainId) {
      const v = this.getWalletByNetwork(chainId);

      if (v) {
        wallets.push(v);
      }
    } else {
      wallets = this._wallets;
    }

    return (await Promise.all(wallets.map(w => w.wallet.getWalletConfig()))).flat();
  }

  async getWalletState(chainId) {
    let wallets = [];

    if (chainId) {
      const v = this.getWalletByNetwork(chainId);

      if (v) {
        wallets.push(v);
      }
    } else {
      wallets = this._wallets;
    }

    const configsPromise = Promise.all(wallets.map(w => this.getConfigFinder().findCurrentConfig({
      address: w.wallet.address,
      provider: w.wallet.provider,
      context: w.wallet.context,
      knownConfigs: [w.wallet.config]
    })));
    const states = (await Promise.all(wallets.map(w => w.wallet.getWalletState()))).flat(); // fetch the current config for the AuthChain, as it will be available

    const idx = states.findIndex(s => s.chainId === this.getAuthChainId());

    if (idx >= 0) {
      states[idx].config = await this.currentConfig(wallets[idx].wallet);
    }

    const configs = await configsPromise;
    return states.map((s, i) => {
      var _configs$i;

      return _extends({}, s, {
        config: (_configs$i = configs[i]) == null ? void 0 : _configs$i.config
      });
    });
  } // address getter


  get address() {
    return this._wallets[0].wallet.address;
  } // getAddress returns the address of the wallet -- note the account address is the same
  // across all wallets on all different networks


  getAddress() {
    return this._wallets[0].wallet.getAddress();
  } // getSigners returns the multi-sig signers with permission to control the wallet


  async getSigners() {
    return this._wallets[0].wallet.getSigners();
  }

  async getProvider(chainId) {
    var _this$mainWallet, _this$_wallets$find;

    if (!chainId) return (_this$mainWallet = this.mainWallet()) == null ? void 0 : _this$mainWallet.wallet.getProvider();
    return (_this$_wallets$find = this._wallets.find(w => w.network.chainId === chainId)) == null ? void 0 : _this$_wallets$find.wallet.getProvider();
  }

  async getRelayer(chainId) {
    var _this$mainWallet2, _this$_wallets$find2;

    if (!chainId) return (_this$mainWallet2 = this.mainWallet()) == null ? void 0 : _this$mainWallet2.wallet.getRelayer();
    return (_this$_wallets$find2 = this._wallets.find(w => w.network.chainId === chainId)) == null ? void 0 : _this$_wallets$find2.wallet.getRelayer();
  }

  async getNetworks() {
    return this.options.networks;
  } // NOTE: this is copied over on top of ethers, and is memoized


  async getChainId() {
    if (this._chainId) return this._chainId;
    const network = await this.provider.getNetwork();
    this._chainId = network.chainId;
    return this._chainId;
  }

  getAuthChainId() {
    try {
      return this.options.networks.find(network => network.isAuthChain).chainId;
    } catch (_unused) {
      throw new Error('no auth network');
    }
  }

  async signMessage(message, target, allSigners = true, isDigest = false) {
    var _this = this;

    let {
      wallet
    } = await async function () {
      // eslint-disable-line
      if (!target) {
        return _this.mainWallet();
      }

      if (target.address) {
        const chainId = await target.getChainId();
        return _this.getWalletByNetwork(chainId);
      }

      return _this.getWalletByNetwork(target);
    }(); // Fetch the latest config of the wallet.
    //
    // We skip this step if wallet is authWallet. The assumption is that authWallet
    // will already have the latest config, but lets confirm that.
    // TODO: instead, memoize the currentConfig, as below will break
    // if we skip
    // if (!network.isAuthChain) {

    let thisConfig = await this.currentConfig(wallet);
    thisConfig = thisConfig ? thisConfig : this._wallets[0].wallet.config;
    wallet = wallet.useConfig(thisConfig); // }
    // See if wallet and available signers set has enough signer power,
    // but if allSigners is false, we allow partial signing

    const weight = await wallet.signWeight();

    if (weight.lt(wallet.config.threshold) && allSigners !== false) {
      throw new NotEnoughSigners(`Sign message - wallet combined weight ${weight.toString()} below required ${wallet.config.threshold.toString()}`);
    }

    return wallet.signMessage(message, undefined, allSigners, isDigest);
  } // TODO: should allSigners default to false here..?


  async signAuthMessage(message, allSigners = true, isDigest = false) {
    var _this$authWallet;

    return this.signMessage(message, (_this$authWallet = this.authWallet()) == null ? void 0 : _this$authWallet.wallet, allSigners, isDigest);
  }

  async signTypedData(domain, types, message, chainId, allSigners = true) {
    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;
    const digest = encodeTypedDataDigest({
      domain,
      types,
      message
    });
    return this.signMessage(digest, wallet, allSigners, true);
  }

  async _signTypedData(domain, types, message, chainId, allSigners = true) {
    return this.signTypedData(domain, types, message, chainId, allSigners);
  }

  async hasEnoughSigners(chainId) {
    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;
    const thisConfig = await this.currentConfig(wallet);
    return wallet.useConfig(thisConfig).hasEnoughSigners();
  }

  async getFeeOptions(transaction, chainId, allSigners = true) {
    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;
    const context = this.options.context;

    if (!context) {
      throw new Error(`missing wallet context`);
    } // TODO: can we avoid calling `this.currentConfig(wallet)` everytime here.. this is an expensive
    // operations and we shouldn't be doing it so liberally. What is the minimum information we require here..?
    // and what is the config used for, and how can we optimize..?
    // TODO: prependConfigUpdate also looks like its calling currentConfig() again, so we're doubling this.
    // A few thoughts.. first off, we must add some kind of memoization for this, but with great care, because
    // the config might change. This make me think we need some king of "ConfigSource" class, or "ConfigXXX" (name?),
    // which we can ask to give us a wallet config. This config would also be used when we update/change a config,
    // such that it can memoize, but also since its the sole interface, it will also properly expire or update the config
    // in cache as necessary. Further to this, I think we need to only get config details for what is required, and try
    // to optimize by using imageHashes of the config everywhere, as this is a much more inexpensive value to fetch.


    const [config, updatedTransaction] = await Promise.all([this.currentConfig(wallet), this.prependConfigUpdate(transaction, chainId, allSigners, true)]);

    if (!config) {
      throw new Error(`missing current config for chain ${chainId}`);
    }

    const finalTransactions = await fromTransactionish(context, this.address, updatedTransaction);
    return wallet.relayer.getFeeOptions(config, context, ...finalTransactions);
  }

  async sendTransaction(dtransactionish, chainId, allSigners = true, quote, callback) {
    const signedTxs = await this.signTransactions(dtransactionish, chainId, allSigners);

    if (callback) {
      const address = addressOf(signedTxs.config, signedTxs.context);
      const metaTxnHash = computeMetaTxnHash(address, signedTxs.chainId, ...signedTxs.transactions);
      callback(signedTxs, metaTxnHash);
    }

    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;
    return wallet.sendSignedTransactions(signedTxs, chainId, quote);
  }

  async sendTransactionBatch(transactions, chainId, allSigners = true, quote, callback) {
    return this.sendTransaction(transactions, chainId, allSigners, quote, callback);
  }

  async signTransactions(dtransactionish, chainId, allSigners) {
    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;
    let currentConfig = await this.currentConfig(wallet);

    if (!currentConfig) {
      currentConfig = await this.currentConfig();

      if (!currentConfig) {
        throw new Error('missing auth chain config');
      }
    }

    const transactions = await this.prependConfigUpdate(dtransactionish, chainId, allSigners);
    return wallet.useConfig(currentConfig).signTransactions(transactions);
  }

  async prependConfigUpdate(dtransactionish, chainId, allSigners, skipThresholdCheck) {
    const transaction = await resolveArrayProperties(dtransactionish);
    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet; // TODO: Skip this step if wallet is authWallet

    const [thisConfig, lastConfig] = await Promise.all([this.currentConfig(wallet), this.currentConfig()]); // We have to skip the threshold check during fee estimation because we
    // might not have the necessary signers until the wallet actually signs the
    // transactions.
    //
    // By design, the Torus login key only exists in memory in Sequence wallet
    // and cannot generally be assumed to be available. However the Torus login
    // key might be required in order to transact on other non-auth chains,
    // because the wallet config might not recognize the current session's
    // signing key. In these cases, the Torus key is retrieved when the user
    // confirms the transaction, which happens after fee estimation. So the
    // wallet might not meet the threshold during fee estimation despite
    // meeting it at confirmation time.

    if (!skipThresholdCheck) {
      // See if wallet has enough signer power
      const weight = await wallet.useConfig(thisConfig).signWeight();

      if (weight.lt(thisConfig.threshold) && allSigners) {
        throw new NotEnoughSigners(`wallet combined weight ${weight.toString()} below required threshold ${thisConfig.threshold.toString()}`);
      }
    } // If the wallet is updated, just sign as-is


    if ((await wallet.isDeployed()) && isConfigEqual(lastConfig, thisConfig)) {
      return transaction;
    } // Bundle with configuration update


    const transactionParts = (() => {
      if (Array.isArray(transaction)) {
        return transaction;
      } else {
        return [transaction];
      }
    })();

    return [...(await wallet.buildUpdateConfigTransaction(lastConfig, false)), ...transactionParts];
  }

  async sendSignedTransactions(signedTxs, chainId, quote) {
    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;
    return wallet.sendSignedTransactions(signedTxs, undefined, quote);
  } // updateConfig will build an updated config transaction, update the imageHash on-chain and also publish
  // the wallet config to the authChain. Other chains are lazy-updated on-demand as batched transactions.


  async updateConfig(newConfig, index, quote, callback) {
    const authWallet = this.authWallet().wallet;

    if (!newConfig) {
      newConfig = authWallet.config;
    } else {
      // ensure its normalized
      newConfig = sortConfig(newConfig);
    } // The config is the default config, see if the wallet has been deployed


    if (isConfigEqual(authWallet.config, newConfig)) {
      if (!(await this.isDeployed())) {
        // Deploy the wallet and publish initial configuration
        return await authWallet.updateConfig(newConfig, undefined, true, index, quote, callback);
      }
    } // Get latest config, update only if neccesary


    const lastConfig = await this.currentConfig();

    if (isConfigEqual(lastConfig, newConfig)) {
      return [_extends({}, lastConfig, {
        address: this.address
      }), undefined];
    } // Update to new configuration on the authWallet. Other networks will be lazily updated
    // once used. The wallet config is also auto-published to the authChain.


    const [_, tx] = await authWallet.useConfig(lastConfig).updateConfig(newConfig, undefined, true, index, quote, callback);
    return [_extends({}, newConfig, {
      address: this.address
    }), tx];
  } // publishConfig will publish the wallet config to the network via the relayer. Publishing
  // the config will also store the entire object of signers.


  publishConfig(indexed, requireFreshSigners = [], quote, callback) {
    return this.authWallet().wallet.publishConfig(indexed, undefined, requireFreshSigners, quote, callback);
  }

  async isDeployed(target) {
    const wallet = (() => {
      if (!target) return this.authWallet().wallet;

      if (target.address) {
        return target;
      }

      return this.getWalletByNetwork(target).wallet;
    })();

    return wallet.isDeployed();
  } // TODO: Split this to it's own class "configProvider" or something
  // this process can be done in different ways (caching, api, utils, etc)


  async currentConfig(target) {
    const wallet = (() => {
      if (!target) return this.authWallet().wallet;

      if (target.address) {
        return target;
      }

      return this.getWalletByNetwork(target).wallet;
    })();

    return (await this.getConfigFinder().findCurrentConfig({
      address: this.address,
      provider: wallet.provider,
      context: wallet.context,
      knownConfigs: [wallet.config]
    })).config;
  }

  getWallets() {
    return this._wallets;
  }

  getWalletByNetwork(chainId) {
    const networkId = getChainId(chainId);

    const network = this._wallets.find(w => w.network.chainId === networkId);

    if (!network) {
      throw new Error(`network ${chainId} not found in wallets list`);
    }

    return network;
  } // mainWallet is the DefaultChain wallet


  mainWallet() {
    const found = this._wallets.find(w => w.network.isDefaultChain);

    if (!found) {
      throw new Error('mainWallet not found');
    }

    return found;
  } // authWallet is the AuthChain wallet


  authWallet() {
    const found = this._wallets.find(w => w.network.isAuthChain);

    if (!found) {
      throw new Error('authChain wallet not found');
    }

    return found;
  }

  setNetworks(mainnetNetworks, testnetNetworks = [], defaultChainId) {
    let networks = [];
    this._chainId = undefined; // clear memoized value
    // find chain between mainnet and testnet network groups, and set that network group.
    // otherwise use mainnetNetworks without changes

    if (defaultChainId) {
      // force-convert to a number in case someone sends a number in a string like "1"
      const defaultChainIdNum = parseInt(defaultChainId);
      const foundMainnetNetwork = mainnetNetworks.find(n => n.name === defaultChainId || n.chainId === defaultChainIdNum);
      const foundTestnetNetwork = testnetNetworks.find(n => n.name === defaultChainId || n.chainId === defaultChainIdNum);

      if (foundMainnetNetwork || foundTestnetNetwork) {
        if (foundMainnetNetwork) {
          mainnetNetworks.forEach(n => n.isDefaultChain = false);
          foundMainnetNetwork.isDefaultChain = true;
          networks = mainnetNetworks;
        } else if (foundTestnetNetwork) {
          testnetNetworks.forEach(n => n.isDefaultChain = false);
          foundTestnetNetwork.isDefaultChain = true;
          networks = testnetNetworks;
        }
      } else {
        throw new Error(`unable to set default network as chain '${defaultChainId}' does not exist`);
      }
    } else {
      networks = mainnetNetworks;
    } // assign while validating network list
    // TODO - we should remove sortNetworks in the future but this is a breaking change


    this.options.networks = ensureValidNetworks(sortNetworks(networks)); // Account/wallet instances using the initial configuration and network list
    //
    // TODO: we can make an optimization where if mainnetNetworks and testnetNetworks lists
    // haven't changed between calls, and only the defaultChainId, as well, the group between
    // mainnet vs testnet has not changed either -- aka just defaultChainId within a group,
    // then we can avoid rebuilding all of these objects and instead just sort them

    this._wallets = this.options.networks.map(network => {
      const wallet = new Wallet({
        config: this.options.initialConfig,
        context: this.options.context
      }, ...this._signers);

      if (network.provider) {
        wallet.setProvider(network.provider);
      } else if (network.rpcUrl && network.rpcUrl !== '') {
        wallet.setProvider(network.rpcUrl);
      } else {
        throw new Error(`network config is missing provider settings for chainId ${network.chainId}`);
      }

      if (isRelayer(network.relayer)) {
        wallet.setRelayer(network.relayer);
      } else if (isRpcRelayerOptions(network.relayer)) {
        wallet.setRelayer(new RpcRelayer(_extends({
          provider: wallet.provider
        }, network.relayer)));
      } else {
        throw new Error(`network config is missing relayer settings for chainId ${network.chainId}`);
      }

      if (network.isDefaultChain) {
        this._chainId = network.chainId;
        this.provider = wallet.provider;
      }

      return {
        network: network,
        wallet: wallet
      };
    }); // return the default chain id as number

    return this.options.networks.find(network => network.isDefaultChain).chainId;
  }

  connect(_) {
    throw new Error('connect method is not supported in MultiWallet');
  }

  signTransaction(_) {
    throw new Error('signTransaction method is not supported in MultiWallet, please use signTransactions(...)');
  }

}

async function isValidSignature(address, digest, sig, provider, walletContext, chainId) {
  // Check if valid EOA signature
  //
  // TODO: the EOA check here assume its being passed a digest, but its not a correct assumption
  // as often the message signing is of a string of text and not a digest.
  if (isValidEIP712Signature(address, digest, sig) || isValidEthSignSignature(address, digest, sig)) return true; // Check if valid deployed smart wallet (via erc1271 check)

  const erc1271Check = await isValidContractWalletSignature(address, digest, sig, provider);

  if (erc1271Check === undefined) {
    // If validity of wallet signature can't be determined
    // it could be a signature of a non-deployed sequence wallet
    return isValidSequenceUndeployedWalletSignature(address, digest, sig, walletContext, provider, chainId);
  }

  return erc1271Check;
}
function isValidEIP712Signature(address, digest, sig) {
  try {
    return compareAddr(ethers.utils.recoverAddress(digest, ethers.utils.splitSignature(sig)), address) === 0;
  } catch (_unused) {
    return false;
  }
}
function isValidEthSignSignature(address, digest, sig) {
  try {
    const subDigest = ethers.utils.keccak256(ethers.utils.solidityPack(['string', 'bytes32'], ['\x19Ethereum Signed Message:\n32', digest]));
    return compareAddr(ethers.utils.recoverAddress(subDigest, ethers.utils.splitSignature(sig)), address) === 0;
  } catch (_unused2) {
    return false;
  }
} // Check if valid Smart Contract Wallet signature, via ERC1271

async function isValidContractWalletSignature(address, digest, sig, provider) {
  if (!provider) return undefined;

  try {
    if ((await provider.getCode(address)) === '0x') {
      // Signature validity can't be determined
      return undefined;
    }

    const wallet = new ethers.Contract(address, walletContracts.erc1271.abi, provider);
    const response = await wallet.isValidSignature(digest, sig);
    return walletContracts.erc1271.returns.isValidSignatureBytes32 === response;
  } catch (_unused3) {
    return false;
  }
}
async function isValidSequenceUndeployedWalletSignature(address, digest, sig, walletContext, provider, chainId) {
  if (!provider && !chainId) return undefined; // Signature validity can't be determined

  if (!walletContext) return undefined; // Signature validity can't be determined

  try {
    const cid = chainId ? chainId : (await provider.getNetwork()).chainId;
    const signature = decodeSignature(sig);
    const subDigest = ethers.utils.arrayify(ethers.utils.keccak256(packMessageData(address, cid, digest)));
    const config = await recoverConfigFromDigest(subDigest, signature, provider, walletContext, chainId, true);
    const weight = signature.signers.reduce((v, s) => isDecodedEOASigner(s) || isDecodedFullSigner(s) ? v + s.weight : v, 0);
    return compareAddr(addressOf(config, walletContext), address) === 0 && weight >= signature.threshold;
  } catch (_unused4) {
    return false;
  }
}

const fetchImageHash = async signer => {
  const address = await signer.getAddress();
  const walletContract = new Contract(address, walletContracts.mainModuleUpgradable.abi, await signer.getProvider());
  const currentImageHash = await walletContract.functions.imageHash.call([]).catch(() => []);
  return currentImageHash && currentImageHash.length > 0 ? currentImageHash[0] : '';
}; // recoverConfig decodes a WalletConfig from the subDigest and signature combo. Note: the subDigest argument
// is an encoding format of the original message, encoded by:
//
// subDigest = packMessageData(wallet.address, chainId, ethers.utils.keccak256(message))

const recoverConfig = async (subDigest, signature, provider, context, chainId, walletSignersValidation) => {
  const digest = ethers.utils.arrayify(ethers.utils.keccak256(subDigest));
  return recoverConfigFromDigest(digest, signature, provider, context, chainId, walletSignersValidation);
}; // recoverConfigFromDigest decodes a WalletConfig from a digest and signature combo. Note: the digest
// is the keccak256 of the subDigest, see `recoverConfig` method.

const recoverConfigFromDigest = async (digest, signature, provider, context, chainId, walletSignersValidation) => {
  const decoded = signature.threshold !== undefined ? signature : decodeSignature(signature);
  const signers = await Promise.all(decoded.signers.map(async s => {
    if (isDecodedEOASigner(s)) {
      return {
        weight: s.weight,
        address: recoverEOASigner(digest, s)
      };
    } else if (isDecodedAddress(s)) {
      return {
        weight: s.weight,
        address: ethers.utils.getAddress(s.address)
      };
    } else if (isDecodedFullSigner(s)) {
      if (walletSignersValidation) {
        if (!(await isValidSignature(s.address, ethers.utils.arrayify(digest), ethers.utils.hexlify(s.signature), provider, context, chainId))) throw Error('Invalid signature');
      }

      return {
        weight: s.weight,
        address: s.address
      };
    } else {
      throw Error('Uknown signature type');
    }
  }));
  return {
    threshold: decoded.threshold,
    signers: signers
  };
};

export { Account, GuardRemoteSigner, InvalidSigner, LocalRemoteSigner, NotEnoughSigners, RemoteSigner, Signer, Wallet, fetchImageHash, findLatestLog, isSequenceSigner, isValidContractWalletSignature, isValidEIP712Signature, isValidEthSignSignature, isValidSequenceUndeployedWalletSignature, isValidSignature, recoverConfig, recoverConfigFromDigest, resolveArrayProperties };
