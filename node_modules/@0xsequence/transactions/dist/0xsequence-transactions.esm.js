import { ethers } from 'ethers';
import { Interface } from '@ethersproject/abi';
import { walletContracts } from '@0xsequence/abi';
import { subDigestOf } from '@0xsequence/utils';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const MetaTransactionsType = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;
function packMetaTransactionsData(...txs) {
  const nonce = readSequenceNonce(...txs);
  if (nonce === undefined) throw new Error('Encoding transactions without defined nonce');
  return packMetaTransactionsNonceData(nonce, ...txs);
}
function packMetaTransactionsNonceData(nonce, ...txs) {
  return ethers.utils.defaultAbiCoder.encode(['uint256', MetaTransactionsType], [nonce, sequenceTxAbiEncode(txs)]);
}
function digestOfTransactions(...txs) {
  const nonce = readSequenceNonce(...txs);
  if (nonce === undefined) throw new Error('Computing hash for transactions without defined nonce');
  return digestOfTransactionsNonce(nonce, ...txs);
}
function digestOfTransactionsNonce(nonce, ...txs) {
  return ethers.utils.keccak256(packMetaTransactionsNonceData(nonce, ...txs));
}
function computeMetaTxnHash(address, chainId, ...txs) {
  return subDigestOf(address, chainId, digestOfTransactions(...txs)).replace(/^0x/, '');
}
async function toSequenceTransactions(wallet, txs, revertOnError = false, gasLimit = ethers.constants.Zero) {
  // Bundles all transactions, including the auxiliary ones
  const allTxs = flattenAuxTransactions(txs); // Uses the lowest nonce found on TransactionRequest
  // if there are no nonces, it leaves an undefined nonce

  const nonces = (await Promise.all(txs.map(t => t.nonce))).filter(n => n !== undefined).map(n => ethers.BigNumber.from(n));
  const nonce = nonces.length !== 0 ? nonces.reduce((p, c) => p.lt(c) ? p : c) : undefined; // Maps all transactions into SequenceTransactions

  return Promise.all(allTxs.map(tx => toSequenceTransaction(wallet, tx, revertOnError, gasLimit, nonce)));
}
function flattenAuxTransactions(txs) {
  if (!Array.isArray(txs)) return flattenAuxTransactions([txs]);
  return txs.reduce(function (p, c) {
    if (Array.isArray(c)) {
      return p.concat(flattenAuxTransactions(c));
    }

    if (c.auxiliary) {
      return p.concat([c, ...flattenAuxTransactions(c.auxiliary)]);
    }

    return p.concat(c);
  }, []);
}
async function toSequenceTransaction(wallet, tx, revertOnError = false, gasLimit = ethers.constants.Zero, nonce) {
  if (isSequenceTransaction(tx)) {
    return tx;
  }

  const txGas = tx.gasLimit === undefined ? tx.gas : tx.gasLimit;

  if (tx.to) {
    return {
      delegateCall: false,
      revertOnError: revertOnError,
      gasLimit: txGas ? await txGas : gasLimit,
      to: await tx.to,
      value: tx.value ? await tx.value : 0,
      data: await tx.data,
      nonce: nonce ? nonce : await tx.nonce
    };
  } else {
    const walletInterface = new Interface(walletContracts.mainModule.abi);
    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('createContract'), [tx.data]);
    const address = typeof wallet === 'string' ? wallet : wallet.getAddress();
    return {
      delegateCall: false,
      revertOnError: revertOnError,
      gasLimit: txGas ? await txGas : gasLimit,
      to: await address,
      value: tx.value ? await tx.value : 0,
      data: data,
      nonce: nonce ? nonce : await tx.nonce
    };
  }
}
function isAsyncSendable(target) {
  return target.send || target.sendAsync;
}
function isSequenceTransaction(tx) {
  return tx.delegateCall !== undefined || tx.revertOnError !== undefined;
}
function hasSequenceTransactions(txs) {
  return txs.find(t => isSequenceTransaction(t)) !== undefined;
}
function readSequenceNonce(...txs) {
  const sample = txs.find(t => t.nonce !== undefined);

  if (!sample) {
    return undefined;
  }

  const sampleNonce = ethers.BigNumber.from(sample.nonce);

  if (txs.find(t => t.nonce !== undefined && !ethers.BigNumber.from(t.nonce).eq(sampleNonce))) {
    throw new Error('Mixed nonces on Sequence transactions');
  }

  return sample ? sample.nonce : undefined;
}
function sequenceTxAbiEncode(txs) {
  return txs.map(t => {
    var _t$to;

    return {
      delegateCall: t.delegateCall === true,
      revertOnError: t.revertOnError === true,
      gasLimit: t.gasLimit !== undefined ? t.gasLimit : ethers.constants.Zero,
      target: (_t$to = t.to) != null ? _t$to : ethers.constants.AddressZero,
      value: t.value !== undefined ? t.value : ethers.constants.Zero,
      data: t.data !== undefined ? t.data : []
    };
  });
}
function appendNonce(txs, nonce) {
  return txs.map(t => _extends({}, t, {
    nonce
  }));
}
function makeExpirable(context, txs, expiration) {
  const sequenceUtils = new Interface(walletContracts.sequenceUtils.abi);

  if (!context || !context.sequenceUtils) {
    throw new Error('Undefined sequenceUtils');
  }

  return [{
    delegateCall: false,
    revertOnError: true,
    gasLimit: 0,
    to: context.sequenceUtils,
    value: 0,
    data: sequenceUtils.encodeFunctionData(sequenceUtils.getFunction('requireNonExpired'), [expiration])
  }, ...txs];
}
function makeAfterNonce(context, txs, dep) {
  const sequenceUtils = new Interface(walletContracts.sequenceUtils.abi);

  if (!context || !context.sequenceUtils) {
    throw new Error('Undefined sequenceUtils');
  }

  return [{
    delegateCall: false,
    revertOnError: true,
    gasLimit: 0,
    to: context.sequenceUtils,
    value: 0,
    data: sequenceUtils.encodeFunctionData(sequenceUtils.getFunction('requireMinNonce'), [dep.address, dep.space ? encodeNonce(dep.space, dep.nonce) : dep.nonce])
  }, ...txs];
}
function encodeNonce(space, nonce) {
  const bspace = ethers.BigNumber.from(space);
  const bnonce = ethers.BigNumber.from(nonce);
  const shl = ethers.constants.Two.pow(ethers.BigNumber.from(96));

  if (!bnonce.div(shl).eq(ethers.constants.Zero)) {
    throw new Error('Space already encoded');
  }

  return bnonce.add(bspace.mul(shl));
}
function decodeNonce(nonce) {
  const bnonce = ethers.BigNumber.from(nonce);
  const shr = ethers.constants.Two.pow(ethers.BigNumber.from(96));
  return [bnonce.div(shr), bnonce.mod(shr)];
}
function isSignedTransactions(cand) {
  return cand !== undefined && cand.chainId !== undefined && cand.config !== undefined && cand.context !== undefined && cand.signature !== undefined && cand.transactions !== undefined && Array.isArray(cand.transactions) && cand.transactions.reduce((p, c) => p && isSequenceTransaction(c), true);
}
async function fromTransactionish(context, wallet, transaction) {
  let stx = [];

  if (Array.isArray(transaction)) {
    if (hasSequenceTransactions(transaction)) {
      stx = transaction;
    } else {
      stx = await toSequenceTransactions(wallet, transaction);
    }
  } else if (isSequenceTransaction(transaction)) {
    stx = [transaction];
  } else {
    stx = await toSequenceTransactions(wallet, [transaction]);
  } // If transaction is marked as expirable
  // append expirable require


  if (transaction.expiration) {
    stx = makeExpirable(context, stx, transaction.expiration);
  } // If transaction depends on another nonce
  // append after nonce requirement


  if (transaction.afterNonce) {
    const after = transaction.afterNonce;
    stx = makeAfterNonce(context, stx, after.address ? {
      address: after.address,
      nonce: after.nonce,
      space: after.space
    } : {
      address: wallet,
      nonce: after
    });
  }

  return stx;
}

export { MetaTransactionsType, appendNonce, computeMetaTxnHash, decodeNonce, digestOfTransactions, digestOfTransactionsNonce, encodeNonce, flattenAuxTransactions, fromTransactionish, hasSequenceTransactions, isAsyncSendable, isSequenceTransaction, isSignedTransactions, makeAfterNonce, makeExpirable, packMetaTransactionsData, packMetaTransactionsNonceData, readSequenceNonce, sequenceTxAbiEncode, toSequenceTransaction, toSequenceTransactions };
