import { ethers } from 'ethers';
import { Proof, ETHAuth, IsValidSignatureBytes32MagicValue } from '@0xsequence/ethauth';
import { SequenceAPIClient } from '@0xsequence/api';
import { SequenceUtilsFinder, decodeSignature, isDecodedSigner, editConfig, genConfig } from '@0xsequence/config';
import { SequenceIndexerClient } from '@0xsequence/indexer';
import { SequenceMetadataClient } from '@0xsequence/metadata';
import { findNetworkConfig, getAuthNetwork, sequenceContext } from '@0xsequence/network';
import { jwtDecodeClaims } from '@0xsequence/utils';
import { Account, isValidSequenceUndeployedWalletSignature } from '@0xsequence/wallet';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// Default session expiration of ETHAuth token (1 week)
const DEFAULT_SESSION_EXPIRATION = 60 * 60 * 24 * 7; // Long session expiration of ETHAuth token (~1 year)

const LONG_SESSION_EXPIRATION = 3e7;
const EXPIRATION_JWT_MARGIN = 60; // seconds

class Session {
  // proof strings are indexed by account address and app name, see getProofStringKey()
  constructor(sequenceApiUrl, sequenceMetadataUrl, networks, config, context, account, metadata, authProvider, jwt) {
    this.sequenceApiUrl = sequenceApiUrl;
    this.sequenceMetadataUrl = sequenceMetadataUrl;
    this.networks = networks;
    this.config = config;
    this.context = context;
    this.account = account;
    this.metadata = metadata;
    this.authProvider = authProvider;
    this._initialAuthRequest = void 0;
    this._jwt = void 0;
    this.proofStrings = new Map();
    this.onAuthCallbacks = [];
    this.apiClient = void 0;
    this.metadataClient = void 0;
    this.indexerClients = new Map();

    if (jwt) {
      var _jwt$expiration;

      this._jwt = {
        token: Promise.resolve(jwt.token),
        expiration: (_jwt$expiration = jwt.expiration) != null ? _jwt$expiration : getJWTExpiration(jwt.token)
      };
    }
  }

  get name() {
    return this.metadata.name;
  }

  get expiration() {
    return this.metadata.expiration ? Math.max(this.metadata.expiration, 120) : DEFAULT_SESSION_EXPIRATION;
  }

  onAuth(cb) {
    this.onAuthCallbacks.push(cb);
  }

  setAccount(account) {
    this.account = account;
  }

  setConfig(config) {
    this.config = config;
  }

  async auth(maxTries = 5) {
    const url = this.sequenceApiUrl;
    if (!url) throw Error('No sequence api url');
    let jwtAuth;

    for (let i = 0;; i++) {
      try {
        jwtAuth = (await this.getJWT(true)).token;
        break;
      } catch (error) {
        if (i === maxTries - 1) {
          console.error(`couldn't authenticate after ${maxTries} attempts`, error);
          throw error;
        }
      }
    }

    return new SequenceAPIClient(url, jwtAuth);
  }

  get isTestnetMode() {
    if (!this.networks || this.networks.length === 0) return;
    return !!this.networks[0].testnet;
  }

  async getAPIClient(tryAuth = true) {
    if (!this.apiClient) {
      const url = this.sequenceApiUrl;
      if (!url) throw Error('No chaind url');
      const jwtAuth = (await this.getJWT(tryAuth)).token;
      this.apiClient = new SequenceAPIClient(url, jwtAuth);
    }

    return this.apiClient;
  }

  getMetadataClient() {
    if (!this.metadataClient) {
      this.metadataClient = new SequenceMetadataClient(this.sequenceMetadataUrl);
    }

    return this.metadataClient;
  }

  async getIndexerClient(chainId) {
    const network = findNetworkConfig(this.networks, chainId);

    if (!network) {
      throw Error(`No network for chain ${chainId}`);
    }

    const jwtAuth = (await this.getJWT(true)).token;

    if (!this.indexerClients.has(network.chainId)) {
      if (network.indexer) {
        this.indexerClients.set(network.chainId, network.indexer);
      } else if (network.indexerUrl) {
        this.indexerClients.set(network.chainId, new SequenceIndexerClient(network.indexerUrl, jwtAuth));
      } else {
        throw Error(`No indexer url for chain ${chainId}`);
      }
    }

    return this.indexerClients.get(network.chainId);
  }

  async getJWT(tryAuth) {
    var _this = this;

    const url = this.sequenceApiUrl;
    if (!url) throw Error('No chaind url'); // check if we already have or are waiting for a token

    if (this._jwt) {
      const _jwt = this._jwt;

      const _token = await _jwt.token;

      if (this.now() < _jwt.expiration) {
        return {
          token: _token,
          expiration: _jwt.expiration
        };
      } // token expired, delete it and get a new one


      this._jwt = undefined;
    }

    if (!tryAuth) {
      throw new Error('no auth token in memory');
    }

    const proofStringKey = this.getProofStringKey();
    const {
      proofString,
      expiration
    } = this.getProofString(proofStringKey);
    const jwt = {
      token: proofString.then(async function (proofString) {
        const api = new SequenceAPIClient(url);
        const authResp = await api.getAuthToken({
          ewtString: proofString,
          testnetMode: _this.isTestnetMode
        });

        if ((authResp == null ? void 0 : authResp.status) === true && authResp.jwtToken.length !== 0) {
          return authResp.jwtToken;
        } else {
          if (!(await _this.isProofStringValid(proofString))) {
            _this.proofStrings.delete(proofStringKey);
          }

          throw new Error('no auth token from server');
        }
      }).catch(reason => {
        this._jwt = undefined;
        throw reason;
      }),
      expiration
    };
    this._jwt = jwt;
    jwt.token.then(() => {
      this.onAuthCallbacks.forEach(cb => {
        try {
          cb({
            status: 'fulfilled',
            value: undefined
          });
        } catch (_unused) {}
      });
    }).catch(reason => {
      this.onAuthCallbacks.forEach(cb => {
        try {
          cb({
            status: 'rejected',
            reason
          });
        } catch (_unused2) {}
      });
    });
    const token = await jwt.token;
    return {
      token,
      expiration
    };
  }

  getProofString(key) {
    // check if we already have or are waiting for a proof string
    if (this.proofStrings.has(key)) {
      const _proofString = this.proofStrings.get(key);

      if (this.now() < _proofString.expiration) {
        return _proofString;
      } // proof string expired, delete it and make a new one


      this.proofStrings.delete(key);
    }

    const proof = new Proof({
      address: this.account.address
    });
    proof.claims.app = this.name;
    proof.setExpiryIn(this.expiration);
    const ethAuth = new ETHAuth();
    const configFinder = new SequenceUtilsFinder(this.authProvider);
    const authWallet = this.account.authWallet();
    const expiration = this.now() + this.expiration - EXPIRATION_JWT_MARGIN;
    const proofString = {
      // Fetch latest config
      // TODO: Should only search for latest config if necessary to be more efficient.
      //       Perhaps compare local config hash with on-chain hash before doing
      //       the search through the logs. Should do this accross sequence.js
      proofString: configFinder.findCurrentConfig({
        address: authWallet.wallet.address,
        provider: this.authProvider,
        context: authWallet.wallet.context,
        knownConfigs: [authWallet.wallet.config]
      }).then(val => {
        if (!val.config) throw Error("Can't find latest config");
        return authWallet.wallet.useConfig(val.config).sign(proof.messageDigest()).then(signature => {
          const decodedSignature = decodeSignature(signature);
          const totalWeight = decodedSignature.signers.filter(isDecodedSigner).reduce((totalWeight, signer) => totalWeight + signer.weight, 0);

          if (totalWeight < decodedSignature.threshold) {
            throw Error(`insufficient signing power, need ${decodedSignature.threshold}, have ${totalWeight}`);
          }

          proof.signature = signature;
          return ethAuth.encodeProof(proof, true);
        });
      }).catch(reason => {
        this.proofStrings.delete(key);
        throw reason;
      }),
      expiration
    };
    this.proofStrings.set(key, proofString);
    return proofString;
  }

  getProofStringKey() {
    return `${this.account.address} - ${this.name}`;
  }

  async isProofStringValid(proofString) {
    try {
      const ethAuth = new ETHAuth();
      ethAuth.provider = this.authProvider;
      await ethAuth.decodeProof(proofString);
      return true;
    } catch (_unused3) {
      return false;
    }
  }

  async dump() {
    let jwt;

    if (this._jwt) {
      try {
        const expiration = this._jwt.expiration;
        jwt = {
          token: await this._jwt.token,
          expiration
        };
      } catch (_unused4) {}
    }

    return {
      config: this.config,
      context: this.context,
      metadata: this.metadata,
      jwt
    };
  }

  now() {
    return Math.floor(new Date().getTime() / 1000);
  }

  static async open(args) {
    const {
      sequenceApiUrl,
      sequenceMetadataUrl,
      context,
      networks,
      referenceSigner,
      signers,
      threshold,
      deepSearch,
      knownConfigs,
      noIndex,
      metadata
    } = args;
    const authProvider = getAuthProvider(networks);
    const configFinder = args.configFinder ? args.configFinder : new SequenceUtilsFinder(authProvider);
    const solvedSigners = Promise.all(signers.map(async function (s) {
      return _extends({}, s, {
        address: typeof s.signer === 'string' ? s.signer : await s.signer.getAddress()
      });
    }));
    const fullSigners = signers.filter(s => typeof s.signer !== 'string').map(s => s.signer);
    const existingWallet = (await configFinder.findLastWalletOfInitialSigner({
      signer: referenceSigner,
      context: context,
      provider: authProvider,
      requireIndex: deepSearch ? false : true
    })).wallet;

    if (existingWallet) {
      // existing account
      // Find prev configuration
      const config = (await configFinder.findCurrentConfig({
        address: existingWallet,
        provider: authProvider,
        context: context,
        knownConfigs
      })).config;
      if (!config) throw Error('Wallet config not found'); // Load prev account

      const account = new Account({
        initialConfig: config,
        networks: networks,
        context: context
      }, ...fullSigners);
      const session = new Session(sequenceApiUrl, sequenceMetadataUrl, networks, config, context, account, metadata, authProvider); // Update wallet config on-chain on the authChain

      const [newConfig] = await account.updateConfig(editConfig(config, {
        threshold,
        set: await solvedSigners
      }), noIndex ? false : true); // Session is ready, lets update

      session.setConfig(newConfig);
      session.setAccount(new Account({
        initialConfig: newConfig,
        networks: networks,
        context: context
      }, ...fullSigners));

      if (sequenceApiUrl) {
        // Fire JWT requests after updating config
        session._initialAuthRequest = session.auth();
      } else {
        session._initialAuthRequest = Promise.reject('no sequence api url');
      }

      return session;
    } else {
      // fresh account
      const config = genConfig(threshold, await solvedSigners);
      const account = new Account({
        initialConfig: config,
        networks: networks,
        context: context
      }, ...fullSigners); // send referenceSigner as "requireFreshSigners"
      // this ensures the user doesn't end up with multiple accounts if there is a race condition during login

      await account.publishConfig(noIndex ? false : true, [referenceSigner]);
      const session = new Session(sequenceApiUrl, sequenceMetadataUrl, networks, config, context, account, metadata, authProvider);

      if (sequenceApiUrl) {
        // Fire JWT requests when opening session
        session._initialAuthRequest = session.auth();
      } else {
        session._initialAuthRequest = Promise.reject('no sequence api url');
      }

      return session;
    }
  }

  static load(args) {
    const {
      sequenceApiUrl,
      sequenceMetadataUrl,
      dump,
      signers,
      networks
    } = args;
    return new Session(sequenceApiUrl, sequenceMetadataUrl, networks, dump.config, dump.context, new Account({
      initialConfig: dump.config,
      context: dump.context,
      networks: networks
    }, ...signers), dump.metadata, getAuthProvider(networks), dump.jwt);
  }

}

function getAuthProvider(networks) {
  var _authChain$provider;

  const authChain = getAuthNetwork(networks);
  if (!authChain) throw Error('Auth chain not found');
  return (_authChain$provider = authChain.provider) != null ? _authChain$provider : new ethers.providers.JsonRpcProvider(authChain.rpcUrl);
}

function getJWTExpiration(jwt) {
  return jwtDecodeClaims(jwt).exp;
}

// signAuthorization will perform an EIP712 typed-data message signing of ETHAuth domain via the provided
// Signer and authorization options.
const signAuthorization = async (signer, options) => {
  const chainId = await signer.getChainId();
  const address = ethers.utils.getAddress(await signer.getAddress());

  if (!address || address === '' || address === '0x') {
    throw ErrAccountIsRequired;
  }

  const proof = new Proof();
  proof.address = address;

  if (!options || !options.app || options.app === '') {
    throw new AuthError('authorization options requires app to be set');
  }

  proof.claims.app = options.app;
  proof.claims.ogn = options.origin;
  proof.setExpiryIn(options.expiry ? Math.max(options.expiry, 200) : DEFAULT_SESSION_EXPIRATION);
  const typedData = proof.messageTypedData();
  proof.signature = await signer.signTypedData(typedData.domain, typedData.types, typedData.message, chainId);
  const ethAuth = new ETHAuth();
  const proofString = await ethAuth.encodeProof(proof, true);
  return {
    typedData,
    proofString
  };
}; // TODO: review......

class AuthError extends Error {
  constructor(message) {
    super(message);
    this.name = 'AuthError';
  }

}
const ErrAccountIsRequired = new AuthError('auth error: account address is empty');

const ValidateSequenceDeployedWalletProof = async (provider, chainId, proof) => {
  if (!provider || provider === undefined || chainId === undefined) {
    return {
      isValid: false
    };
  } // Compute eip712 message digest from the proof claims


  const digest = proof.messageDigest(); // Early check to ensure the contract wallet has been deployed

  const walletCode = await provider.getCode(proof.address);

  if (walletCode === '0x' || walletCode.length <= 2) {
    throw new Error('ValidateSequenceDeployedWalletProof failed. unable to fetch wallet contract code');
  } // Call EIP-1271 IsValidSignature(bytes32, bytes) method on the deployed wallet. Note: for undeployed
  // wallets, you will need to implement your own ValidatorFunc with the additional context.


  const abi = ['function isValidSignature(bytes32, bytes) public view returns (bytes4)'];
  const contract = new ethers.Contract(proof.address, abi, provider); // hash the message digest as required by isValidSignature

  const isValidSignature = await contract.isValidSignature(digest, ethers.utils.arrayify(proof.signature));

  if (isValidSignature === IsValidSignatureBytes32MagicValue) {
    return {
      isValid: true
    };
  } else {
    return {
      isValid: false
    };
  }
};
const ValidateSequenceUndeployedWalletProof = context => {
  return async (provider, chainId, proof) => {
    if (!provider || provider === undefined || chainId === undefined) {
      return {
        isValid: false
      };
    } // The contract must not be deployed


    const walletCode = ethers.utils.arrayify(await provider.getCode(proof.address));
    if (walletCode.length !== 0) return {
      isValid: false
    }; // Compute eip712 message digest from the proof claims

    const message = proof.messageDigest(); // hash the message digest as required by isValidSignature

    const digest = ethers.utils.arrayify(ethers.utils.keccak256(message));
    const isValid = await isValidSequenceUndeployedWalletSignature(proof.address, digest, proof.signature, context ? context : sequenceContext, provider, chainId);
    return {
      isValid: !!isValid
    };
  };
};

export { AuthError, DEFAULT_SESSION_EXPIRATION, ErrAccountIsRequired, LONG_SESSION_EXPIRATION, Session, ValidateSequenceDeployedWalletProof, ValidateSequenceUndeployedWalletProof, signAuthorization };
