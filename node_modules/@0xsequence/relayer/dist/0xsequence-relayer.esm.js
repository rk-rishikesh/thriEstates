import { ethers, providers, Signer } from 'ethers';
import { walletContracts } from '@0xsequence/abi';
import { sequenceTxAbiEncode, readSequenceNonce, encodeNonce, computeMetaTxnHash, MetaTransactionsType, appendNonce, decodeNonce } from '@0xsequence/transactions';
import { isBigNumberish, logger } from '@0xsequence/utils';
import { Provider } from '@ethersproject/providers';
import { imageHash, addressOf, encodeSignature, buildStubSignature } from '@0xsequence/config';
import { Interface } from 'ethers/lib/utils';
import fetchPonyfill from 'fetch-ponyfill';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function isBaseRelayerOptions(obj) {
  return obj.bundleCreation !== undefined && typeof obj.bundleCreation === 'boolean' || obj.creationGasLimit !== undefined && isBigNumberish(obj.creationGasLimit) || obj.provider !== undefined && (providers.Provider.isProvider(obj.provider) || typeof obj.provider === 'string');
}
const BaseRelayerDefaults = {
  bundleCreation: true,
  creationGasLimit: ethers.constants.Two.pow(17)
};
class BaseRelayer {
  constructor(options) {
    this.provider = void 0;
    this.bundleCreation = void 0;
    this.creationGasLimit = void 0;

    const opts = _extends({}, BaseRelayerDefaults, options);

    this.bundleCreation = opts.bundleCreation;
    this.provider = opts.provider;
    this.creationGasLimit = ethers.BigNumber.from(opts.creationGasLimit);
  }

  async isWalletDeployed(walletAddress) {
    if (!this.provider) throw new Error('Bundled creation provider not found');
    return (await this.provider.getCode(walletAddress)) !== '0x';
  }

  prepareWalletDeploy(config, context) {
    const factoryInterface = new Interface(walletContracts.factory.abi);
    return {
      to: context.factory,
      data: factoryInterface.encodeFunctionData(factoryInterface.getFunction('deploy'), [context.mainModule, imageHash(config)])
    };
  }

  async prependWalletDeploy(signedTransactions) {
    const {
      config,
      context,
      transactions,
      nonce,
      signature
    } = signedTransactions;
    const walletAddress = addressOf(config, context);
    const walletInterface = new Interface(walletContracts.mainModule.abi);

    const encodedSignature = async function () {
      const sig = await signature;
      if (typeof sig === 'string') return sig;
      return encodeSignature(sig);
    }();

    if (this.bundleCreation && !(await this.isWalletDeployed(walletAddress))) {
      return {
        to: context.guestModule,
        execute: {
          transactions: [_extends({}, this.prepareWalletDeploy(config, context), {
            delegateCall: false,
            revertOnError: false,
            gasLimit: this.creationGasLimit,
            value: ethers.constants.Zero
          }), {
            delegateCall: false,
            revertOnError: true,
            gasLimit: ethers.constants.Zero,
            to: walletAddress,
            value: ethers.constants.Zero,
            data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(transactions), nonce, await encodedSignature])
          }],
          nonce: ethers.constants.Zero,
          signature: '0x'
        }
      };
    } else {
      return {
        to: walletAddress,
        execute: {
          transactions,
          nonce: ethers.BigNumber.from(nonce),
          signature: await encodedSignature
        }
      };
    }
  }

  async prepareTransactions(config, context, signature, ...transactions) {
    //, gasLimit?: ethers.BigNumberish }> {
    const nonce = readSequenceNonce(...transactions);

    if (!nonce) {
      throw new Error('Unable to prepare transactions without a defined nonce');
    }

    const {
      to,
      execute
    } = await this.prependWalletDeploy({
      config,
      context,
      transactions,
      nonce,
      signature
    });
    const walletInterface = new Interface(walletContracts.mainModule.abi);
    return {
      to,
      data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature])
    };
  }

}

const DEFAULT_GAS_LIMIT = ethers.BigNumber.from(800000);
const ProviderRelayerDefaults = {
  waitPollRate: 1000,
  deltaBlocksLog: 12,
  fromBlockLog: -1024
};
function isProviderRelayerOptions(obj) {
  return obj.provider !== undefined && Provider.isProvider(obj.provider);
}
class ProviderRelayer extends BaseRelayer {
  constructor(options) {
    super(options);
    this.provider = void 0;
    this.waitPollRate = void 0;
    this.deltaBlocksLog = void 0;
    this.fromBlockLog = void 0;

    const opts = _extends({}, ProviderRelayerDefaults, options);

    this.provider = opts.provider;
    this.waitPollRate = opts.waitPollRate;
    this.deltaBlocksLog = opts.deltaBlocksLog;
    this.fromBlockLog = opts.fromBlockLog;
  }

  async simulate(wallet, ...transactions) {
    var _this = this;

    return (await Promise.all(transactions.map(async function (tx) {
      // Respect gasLimit request of the transaction (as long as its not 0)
      if (tx.gasLimit && !ethers.BigNumber.from(tx.gasLimit || 0).eq(ethers.constants.Zero)) {
        return tx.gasLimit;
      } // Fee can't be estimated locally for delegateCalls


      if (tx.delegateCall) {
        return DEFAULT_GAS_LIMIT;
      } // Fee can't be estimated for self-called if wallet hasn't been deployed


      if (tx.to === wallet && !(await _this.isWalletDeployed(wallet))) {
        return DEFAULT_GAS_LIMIT;
      }

      if (!_this.provider) {
        throw new Error('signer.provider is not set, but is required');
      } // TODO: If the wallet address has been deployed, gas limits can be
      // estimated with more accurately by using self-calls with the batch transactions one by one


      return _this.provider.estimateGas({
        from: wallet,
        to: tx.to,
        data: tx.data,
        value: tx.value
      });
    }))).map(gasLimit => ({
      executed: true,
      succeeded: true,
      gasLimit: ethers.BigNumber.from(gasLimit).toNumber(),
      gasUsed: ethers.BigNumber.from(gasLimit).toNumber()
    }));
  }

  async estimateGasLimits(config, context, ...transactions) {
    const walletAddr = addressOf(config, context);
    const results = await this.simulate(walletAddr, ...transactions);
    return transactions.map((t, i) => _extends({}, t, {
      gasLimit: results[i].gasLimit
    }));
  }

  async getNonce(config, context, space, blockTag) {
    if (!this.provider) {
      throw new Error('provider is not set');
    }

    const addr = addressOf(config, context);

    if ((await this.provider.getCode(addr)) === '0x') {
      return 0;
    }

    if (space === undefined) {
      space = 0;
    }

    const module = new ethers.Contract(addr, walletContracts.mainModule.abi, this.provider);
    const nonce = await module.readNonce(space, {
      blockTag: blockTag
    });
    return encodeNonce(space, nonce);
  }

  async wait(metaTxnId, timeout) {
    if (typeof metaTxnId !== 'string') {
      logger.info("computing id", metaTxnId.config, metaTxnId.context, metaTxnId.chainId, ...metaTxnId.transactions);
      return this.wait(computeMetaTxnHash(addressOf(metaTxnId.config, metaTxnId.context), metaTxnId.chainId, ...metaTxnId.transactions), timeout);
    } // Transactions can only get executed on nonce change
    // get all nonce changes and look for metaTxnIds in between logs


    const timeoutTime = new Date().getTime() + timeout;
    let lastBlock = this.fromBlockLog;

    if (lastBlock < 0) {
      const block = await this.provider.getBlockNumber();
      lastBlock = block + lastBlock;
    }

    const normalMetaTxnId = metaTxnId.replace('0x', '');

    while (new Date().getTime() < timeoutTime) {
      const block = await this.provider.getBlockNumber();
      const logs = await this.provider.getLogs({
        fromBlock: Math.max(0, lastBlock - this.deltaBlocksLog),
        toBlock: block,
        // Nonce change event topic
        topics: ['0x1f180c27086c7a39ea2a7b25239d1ab92348f07ca7bb59d1438fcf527568f881']
      });
      lastBlock = block; // Get receipts of all transactions

      const txs = await Promise.all(logs.map(l => this.provider.getTransactionReceipt(l.transactionHash))); // Find a transaction with a TxExecuted log

      const found = txs.find(tx => tx.logs.find(l => l.topics.length === 0 && l.data.replace('0x', '') === normalMetaTxnId || l.topics.length === 1 && // TxFailed event topic
      l.topics[0] === "0x3dbd1590ea96dd3253a91f24e64e3a502e1225d602a5731357bc12643070ccd7" && l.data.length >= 64 && l.data.replace('0x', '').startsWith(normalMetaTxnId))); // If found return that

      if (found) {
        return _extends({
          receipt: found
        }, await this.provider.getTransaction(found.transactionHash));
      } // Otherwise wait and try again


      await new Promise(r => setTimeout(r, this.waitPollRate));
    }

    throw new Error(`Timeout waiting for transaction receipt ${metaTxnId}`);
  }

}

function isLocalRelayerOptions(obj) {
  return obj.signer !== undefined && Signer.isSigner(obj.signer);
}
class LocalRelayer extends ProviderRelayer {
  constructor(options) {
    super(Signer.isSigner(options) ? {
      provider: options.provider
    } : _extends({}, options, {
      provider: options.signer.provider
    }));
    this.signer = void 0;
    this.txnOptions = void 0;
    this.signer = Signer.isSigner(options) ? options : options.signer;
    if (!this.signer.provider) throw new Error("Signer must have a provider");
  }

  async deployWallet(config, context) {
    // NOTE: on hardhat some tests fail on HookCallerMock when not passing gasLimit directly as below,
    // and using eth_gasEstimate. Perhaps review HookCallerMock.sol and fix it to avoid what looks
    // like an infinite loop?
    const walletDeployTxn = this.prepareWalletDeploy(config, context); // NOTE: for hardhat to pass, we have to set the gasLimit directly, as its unable to estimate

    return this.signer.sendTransaction(_extends({}, walletDeployTxn, {
      gasLimit: ethers.constants.Two.pow(17)
    }));
  }

  async getFeeOptions(_config, _context, ..._transactions) {
    return {
      options: []
    };
  }

  async gasRefundOptions(config, context, ...transactions) {
    const {
      options
    } = await this.getFeeOptions(config, context, ...transactions);
    return options;
  }

  setTransactionOptions(transactionRequest) {
    this.txnOptions = transactionRequest;
  }

  async relay(signedTxs, quote) {
    if (quote !== undefined) {
      logger.warn(`LocalRelayer doesn't accept fee quotes`);
    }

    if (!signedTxs.context.guestModule || signedTxs.context.guestModule.length !== 42) {
      throw new Error('LocalRelayer requires the context.guestModule address');
    }

    const {
      to,
      execute
    } = await this.prependWalletDeploy(signedTxs);
    const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);
    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]); // TODO: think about computing gas limit individually, summing together and passing across
    // NOTE: we expect that all txns have set their gasLimit ahead of time through proper estimation
    // const gasLimit = signedTxs.transactions.reduce((sum, tx) => sum.add(tx.gasLimit), ethers.BigNumber.from(0))
    // txRequest.gasLimit = gasLimit

    return this.signer.sendTransaction(_extends({
      to,
      data
    }, this.txnOptions));
  }

}

/* eslint-disable */
// sequence-relayer v0.4.0 4dca0b91c1531d1166ae2f7ebd8af571b0c0e43b
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript
// Do not edit by hand. Update your webrpc schema and re-generate.
// WebRPC description and code-gen version
const WebRPCVersion = 'v1'; // Schema version of your RIDL schema

const WebRPCSchemaVersion = 'v0.4.0'; // Schema hash generated from your RIDL schema

const WebRPCSchemaHash = '4dca0b91c1531d1166ae2f7ebd8af571b0c0e43b'; //
// Types
//

let ETHTxnStatus;

(function (ETHTxnStatus) {
  ETHTxnStatus["UNKNOWN"] = "UNKNOWN";
  ETHTxnStatus["DROPPED"] = "DROPPED";
  ETHTxnStatus["QUEUED"] = "QUEUED";
  ETHTxnStatus["SENT"] = "SENT";
  ETHTxnStatus["SUCCEEDED"] = "SUCCEEDED";
  ETHTxnStatus["PARTIALLY_FAILED"] = "PARTIALLY_FAILED";
  ETHTxnStatus["FAILED"] = "FAILED";
})(ETHTxnStatus || (ETHTxnStatus = {}));

let TransferType;

(function (TransferType) {
  TransferType["SEND"] = "SEND";
  TransferType["RECEIVE"] = "RECEIVE";
  TransferType["BRIDGE_DEPOSIT"] = "BRIDGE_DEPOSIT";
  TransferType["BRIDGE_WITHDRAW"] = "BRIDGE_WITHDRAW";
  TransferType["BURN"] = "BURN";
  TransferType["UNKNOWN"] = "UNKNOWN";
})(TransferType || (TransferType = {}));

let FeeTokenType;

(function (FeeTokenType) {
  FeeTokenType["UNKNOWN"] = "UNKNOWN";
  FeeTokenType["ERC20_TOKEN"] = "ERC20_TOKEN";
  FeeTokenType["ERC1155_TOKEN"] = "ERC1155_TOKEN";
})(FeeTokenType || (FeeTokenType = {}));

let SortOrder;

(function (SortOrder) {
  SortOrder["DESC"] = "DESC";
  SortOrder["ASC"] = "ASC";
})(SortOrder || (SortOrder = {}));

//
// Client
//
class Relayer {
  constructor(hostname, fetch) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = '/rpc/Relayer/';

    this.ping = headers => {
      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      });
    };

    this.version = headers => {
      return this.fetch(this.url('Version'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            version: _data.version
          };
        });
      });
    };

    this.runtimeStatus = headers => {
      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      });
    };

    this.getSequenceContext = headers => {
      return this.fetch(this.url('GetSequenceContext'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            data: _data.data
          };
        });
      });
    };

    this.getChainID = headers => {
      return this.fetch(this.url('GetChainID'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            chainID: _data.chainID
          };
        });
      });
    };

    this.sendMetaTxn = (args, headers) => {
      return this.fetch(this.url('SendMetaTxn'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            txnHash: _data.txnHash
          };
        });
      });
    };

    this.getMetaTxnNonce = (args, headers) => {
      return this.fetch(this.url('GetMetaTxnNonce'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            nonce: _data.nonce
          };
        });
      });
    };

    this.getMetaTxnReceipt = (args, headers) => {
      return this.fetch(this.url('GetMetaTxnReceipt'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            receipt: _data.receipt
          };
        });
      });
    };

    this.simulate = (args, headers) => {
      return this.fetch(this.url('Simulate'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            results: _data.results
          };
        });
      });
    };

    this.updateMetaTxnGasLimits = (args, headers) => {
      return this.fetch(this.url('UpdateMetaTxnGasLimits'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            payload: _data.payload
          };
        });
      });
    };

    this.feeTokens = headers => {
      return this.fetch(this.url('FeeTokens'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            isFeeRequired: _data.isFeeRequired,
            tokens: _data.tokens
          };
        });
      });
    };

    this.feeOptions = (args, headers) => {
      return this.fetch(this.url('FeeOptions'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            options: _data.options,
            quote: _data.quote
          };
        });
      });
    };

    this.getMetaTxnNetworkFeeOptions = (args, headers) => {
      return this.fetch(this.url('GetMetaTxnNetworkFeeOptions'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            options: _data.options
          };
        });
      });
    };

    this.sentTransactions = (args, headers) => {
      return this.fetch(this.url('SentTransactions'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            transactions: _data.transactions
          };
        });
      });
    };

    this.pendingTransactions = (args, headers) => {
      return this.fetch(this.url('PendingTransactions'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            transactions: _data.transactions
          };
        });
      });
    };

    this.hostname = hostname;
    this.fetch = fetch;
  }

  url(name) {
    return this.hostname + this.path + name;
  }

}

const createHTTPRequest = (body = {}, headers = {}) => {
  return {
    method: 'POST',
    headers: _extends({}, headers, {
      'Content-Type': 'application/json'
    }),
    body: JSON.stringify(body || {})
  };
};

const buildResponse = res => {
  return res.text().then(text => {
    let data;

    try {
      data = JSON.parse(text);
    } catch (err) {
      throw {
        code: 'unknown',
        msg: `expecting JSON, got: ${text}`,
        status: res.status
      };
    }

    if (!res.ok) {
      throw data; // webrpc error response
    }

    return data;
  });
};

var relayer_gen = /*#__PURE__*/Object.freeze({
  __proto__: null,
  WebRPCVersion: WebRPCVersion,
  WebRPCSchemaVersion: WebRPCSchemaVersion,
  WebRPCSchemaHash: WebRPCSchemaHash,
  get ETHTxnStatus () { return ETHTxnStatus; },
  get TransferType () { return TransferType; },
  get FeeTokenType () { return FeeTokenType; },
  get SortOrder () { return SortOrder; },
  Relayer: Relayer
});

const FAILED_STATUSES = [ETHTxnStatus.FAILED, ETHTxnStatus.PARTIALLY_FAILED, ETHTxnStatus.DROPPED];
function isRpcRelayerOptions(obj) {
  return obj.url !== undefined && typeof obj.url === 'string';
}
class RpcRelayer extends BaseRelayer {
  constructor(options) {
    super(options);
    this.service = void 0;
    this.service = new Relayer(options.url, fetchPonyfill().fetch);
  }

  async waitReceipt(metaTxnHash, wait = 1000) {
    if (typeof metaTxnHash !== 'string') {
      logger.info('computing id', metaTxnHash.config, metaTxnHash.context, metaTxnHash.chainId, ...metaTxnHash.transactions);
      return this.waitReceipt(computeMetaTxnHash(addressOf(metaTxnHash.config, metaTxnHash.context), metaTxnHash.chainId, ...metaTxnHash.transactions));
    }

    logger.info(`[rpc-relayer/waitReceipt] waiting for ${metaTxnHash}`);
    let result = await this.service.getMetaTxnReceipt({
      metaTxID: metaTxnHash
    }); // TODO: remove check for 'UNKNOWN' status when 'QUEUED' status is supported
    // TODO: fix backend to not return literal 'null' txnReceipt

    while (!result.receipt || !result.receipt.txnReceipt || result.receipt.txnReceipt === 'null' || result.receipt.status === 'UNKNOWN' || result.receipt.status === 'QUEUED' || result.receipt.status === 'SENT') {
      await new Promise(r => setTimeout(r, wait));
      result = await this.service.getMetaTxnReceipt({
        metaTxID: metaTxnHash
      });
    }

    return result;
  }

  async simulate(wallet, ...transactions) {
    const coder = ethers.utils.defaultAbiCoder;
    const encoded = coder.encode([MetaTransactionsType], [sequenceTxAbiEncode(transactions)]);
    return (await this.service.simulate({
      wallet,
      transactions: encoded
    })).results;
  }

  async estimateGasLimits(config, context, ...transactions) {
    logger.info(`[rpc-relayer/estimateGasLimits] estimate gas limits request ${JSON.stringify(transactions)}`);

    if (transactions.length == 0) {
      return [];
    }

    const addr = addressOf(config, context);
    const prevNonce = readSequenceNonce(...transactions); // Set temporal nonce to simulate meta-txn

    if (prevNonce === undefined) {
      transactions = appendNonce(transactions, await this.getNonce(config, context));
    }

    const coder = ethers.utils.defaultAbiCoder;
    const encoded = coder.encode([MetaTransactionsType], [sequenceTxAbiEncode(transactions)]);
    const res = await this.service.updateMetaTxnGasLimits({
      walletAddress: addr,
      walletConfig: {
        address: addr,
        signers: config.signers,
        threshold: config.threshold,
        chainId: config.chainId
      },
      payload: encoded
    });
    const decoded = coder.decode([MetaTransactionsType], res.payload)[0];
    const modTxns = transactions.map((t, i) => _extends({}, t, {
      gasLimit: decoded[i].gasLimit
    }));
    logger.info(`[rpc-relayer/estimateGasLimits] got transactions with gas limits ${JSON.stringify(modTxns)}`); // Remove placeholder nonce if previously defined

    return prevNonce === undefined ? modTxns : appendNonce(modTxns, prevNonce);
  }

  async getFeeOptions(config, context, ...transactions) {
    // NOTE/TODO: for a given `service` the feeTokens will not change between execution, so we should memoize this value
    // for a short-period of time, perhaps for 1 day or in memory. Perhaps one day we can make this happen automatically
    // with http cache response for this endpoint and service-worker.. lots of approaches
    const feeTokens = await this.service.feeTokens();

    if (feeTokens.isFeeRequired) {
      const symbols = feeTokens.tokens.map(token => token.symbol).join(', ');
      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are required, accepted tokens are ${symbols}`);
      const wallet = addressOf(config, context);
      let nonce = readSequenceNonce(...transactions);

      if (nonce === undefined) {
        nonce = await this.getNonce(config, context);
      }

      if (!this.provider) {
        logger.warn(`[rpc-relayer/getFeeOptions] provider not set, needed for stub signature`);
        throw new Error('provider is not set');
      }

      const {
        to,
        execute
      } = await this.prependWalletDeploy({
        config,
        context,
        transactions,
        nonce,
        signature: buildStubSignature(this.provider, config)
      });
      const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);
      const data = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]);
      const {
        options,
        quote
      } = await this.service.feeOptions({
        wallet,
        to,
        data
      });
      logger.info(`[rpc-relayer/getFeeOptions] got refund options ${JSON.stringify(options)}`);
      return {
        options,
        quote: {
          _tag: 'FeeQuote',
          _quote: quote
        }
      };
    } else {
      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are not required`);
      return {
        options: []
      };
    }
  }

  async gasRefundOptions(config, context, ...transactions) {
    const {
      options
    } = await this.getFeeOptions(config, context, ...transactions);
    return options;
  }

  async getNonce(config, context, space) {
    const addr = addressOf(config, context);
    logger.info(`[rpc-relayer/getNonce] get nonce for wallet ${addr} space: ${space}`);
    const encodedNonce = space !== undefined ? ethers.BigNumber.from(space).toHexString() : undefined;
    const resp = await this.service.getMetaTxnNonce({
      walletContractAddress: addr,
      space: encodedNonce
    });
    const nonce = ethers.BigNumber.from(resp.nonce);
    const [decodedSpace, decodedNonce] = decodeNonce(nonce);
    logger.info(`[rpc-relayer/getNonce] got next nonce for wallet ${addr} ${decodedNonce} space: ${decodedSpace}`);
    return nonce;
  }

  async relay(signedTxs, quote) {
    logger.info(`[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(signedTxs)} with quote ${JSON.stringify(quote)}`);
    let typecheckedQuote;

    if (quote !== undefined) {
      if (typeof quote._quote === 'string') {
        typecheckedQuote = quote._quote;
      } else {
        logger.warn('[rpc-relayer/relay] ignoring invalid fee quote');
      }
    }

    if (!this.provider) {
      logger.warn(`[rpc-relayer/relay] provider not set, failed relay`);
      throw new Error('provider is not set');
    }

    const {
      to: contract,
      execute
    } = await this.prependWalletDeploy(signedTxs);
    const walletAddress = addressOf(signedTxs.config, signedTxs.context);
    const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);
    const input = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]);
    const metaTxn = await this.service.sendMetaTxn({
      call: {
        walletAddress,
        contract,
        input
      },
      quote: typecheckedQuote
    });
    logger.info(`[rpc-relayer/relay] got relay result ${JSON.stringify(metaTxn)}`);
    return this.wait(metaTxn.txnHash);
  }

  async wait(metaTxnHash, wait = 1000) {
    var _this = this;

    const {
      receipt
    } = await this.waitReceipt(metaTxnHash, wait);

    if (!receipt.txnReceipt || FAILED_STATUSES.includes(receipt.status)) {
      throw new MetaTransactionResponseException(receipt);
    }

    const txReceipt = JSON.parse(receipt.txnReceipt);
    return {
      blockHash: txReceipt.blockHash,
      blockNumber: ethers.BigNumber.from(txReceipt.blockNumber).toNumber(),
      confirmations: 1,
      from: typeof metaTxnHash === 'string' ? undefined : addressOf(metaTxnHash.config, metaTxnHash.context),
      hash: txReceipt.transactionHash,
      raw: receipt.txnReceipt,
      receipt: txReceipt,
      // extended type which is Sequence-specific. Contains the decoded metaTxReceipt
      wait: async function (confirmations) {
        return _this.provider.waitForTransaction(txReceipt.transactionHash, confirmations);
      }
    };
  }

}

class MetaTransactionResponseException {
  constructor(receipt) {
    this.receipt = receipt;
  }

}

function isRelayer(cand) {
  return typeof cand === 'object' && typeof cand.simulate === 'function' && typeof cand.estimateGasLimits === 'function' && typeof cand.getFeeOptions === 'function' && typeof cand.gasRefundOptions === 'function' && typeof cand.getNonce === 'function' && typeof cand.relay === 'function' && typeof cand.wait === 'function';
}

export { BaseRelayer, BaseRelayerDefaults, LocalRelayer, ProviderRelayer, ProviderRelayerDefaults, RpcRelayer, relayer_gen as RpcRelayerProto, isBaseRelayerOptions, isLocalRelayerOptions, isProviderRelayerOptions, isRelayer, isRpcRelayerOptions, relayer_gen as proto };
