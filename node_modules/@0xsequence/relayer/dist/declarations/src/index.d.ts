import { ethers, providers } from 'ethers';
import { SignedTransactions, Transaction, TransactionResponse } from '@0xsequence/transactions';
import { WalletContext } from '@0xsequence/network';
import { WalletConfig } from '@0xsequence/config';
import { proto } from './rpc-relayer';
export interface Relayer {
    simulate(wallet: string, ...transactions: Transaction[]): Promise<SimulateResult[]>;
    estimateGasLimits(config: WalletConfig, context: WalletContext, ...transactions: Transaction[]): Promise<Transaction[]>;
    getFeeOptions(config: WalletConfig, context: WalletContext, ...transactions: Transaction[]): Promise<{
        options: FeeOption[];
        quote?: FeeQuote;
    }>;
    gasRefundOptions(config: WalletConfig, context: WalletContext, ...transactions: Transaction[]): Promise<FeeOption[]>;
    getNonce(config: WalletConfig, context: WalletContext, space?: ethers.BigNumberish, blockTag?: providers.BlockTag): Promise<ethers.BigNumberish>;
    relay(signedTxs: SignedTransactions, quote?: FeeQuote): Promise<TransactionResponse>;
    wait(metaTxnId: string | SignedTransactions, timeout: number): Promise<TransactionResponse>;
}
export * from './local-relayer';
export * from './base-relayer';
export * from './provider-relayer';
export * from './rpc-relayer';
export { proto as RpcRelayerProto } from './rpc-relayer';
export declare type SimulateResult = proto.SimulateResult;
export declare type FeeOption = proto.FeeOption;
export interface FeeQuote {
    _tag: 'FeeQuote';
    _quote: unknown;
}
export declare function isRelayer(cand: any): cand is Relayer;
