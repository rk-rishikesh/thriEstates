import { ethers } from 'ethers';
import { BytesLike, Bytes } from '@ethersproject/bytes';
import { Web3Provider as EthersWeb3Provider, JsonRpcProvider } from '@ethersproject/providers';
import { TypedDataDomain, TypedDataField, TypedDataSigner } from '@ethersproject/abstract-signer';
import { NetworkConfig, WalletContext, ChainIdLike, JsonRpcHandler, JsonRpcFetchFunc, JsonRpcRequest, JsonRpcResponseCallback, JsonRpcSender } from '@0xsequence/network';
import { Signer } from '@0xsequence/wallet';
import { WalletConfig, WalletState } from '@0xsequence/config';
import { Relayer } from '@0xsequence/relayer';
import { Deferrable, Forbid } from '@0xsequence/utils';
import { TransactionRequest, TransactionResponse, SignedTransactions } from '@0xsequence/transactions';
export declare class Web3Provider extends EthersWeb3Provider implements JsonRpcHandler {
    static isSequenceProvider(cand: any): cand is Web3Provider;
    readonly _sender: JsonRpcSender;
    readonly _isSequenceProvider: boolean;
    readonly _defaultChainId?: number;
    constructor(provider: JsonRpcProvider | JsonRpcHandler | JsonRpcFetchFunc, defaultChainId?: ChainIdLike);
    sendAsync(request: JsonRpcRequest, callback: JsonRpcResponseCallback | ((error: any, response: any) => void), chainId?: number): void;
    send(method: string, params: Array<any>, chainId?: number): Promise<any>;
    request(request: {
        method: string;
        params?: Array<any>;
        chainId?: number;
    }): Promise<any>;
    getSigner(): Web3Signer;
    getChainId(): Promise<number>;
}
export declare function isSequenceProvider(provider: any): provider is Web3Provider;
export declare class LocalWeb3Provider extends Web3Provider {
    constructor(signer: Signer, networks?: NetworkConfig[]);
}
export declare class Web3Signer extends Signer implements TypedDataSigner {
    readonly provider: Web3Provider;
    readonly defaultChainId?: number;
    constructor(provider: Web3Provider, defaultChainId?: number);
    _address: string;
    _index: number;
    _context: WalletContext;
    _networks: NetworkConfig[];
    private _providers;
    getAddress(): Promise<string>;
    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;
    connect(provider: ethers.providers.Provider): ethers.providers.JsonRpcSigner;
    getProvider(chainId?: number): Promise<Web3Provider | undefined>;
    getSender(chainId?: number): Promise<Web3Provider | undefined>;
    getRelayer(chainId?: number): Promise<Relayer | undefined>;
    getWalletContext(): Promise<WalletContext>;
    getWalletConfig(chainId?: ChainIdLike): Promise<WalletConfig[]>;
    getWalletState(chainId?: ChainIdLike): Promise<WalletState[]>;
    getNetworks(): Promise<NetworkConfig[]>;
    getSigners(): Promise<string[]>;
    signMessage(message: BytesLike, chainId?: ChainIdLike, allSigners?: boolean): Promise<string>;
    signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, message: Record<string, any>, chainId?: ChainIdLike, allSigners?: boolean): Promise<string>;
    sendTransaction(transaction: Deferrable<TransactionRequest>, chainId?: ChainIdLike, allSigners?: boolean): Promise<TransactionResponse>;
    sendTransactionBatch(transactions: Deferrable<Forbid<TransactionRequest, 'wait'>[]>, chainId?: ChainIdLike, allSigners?: boolean): Promise<TransactionResponse>;
    signTransactions(transaction: Deferrable<TransactionRequest>, chainId?: ChainIdLike, allSigners?: boolean): Promise<SignedTransactions>;
    sendSignedTransactions(signedTxs: SignedTransactions, chainId?: ChainIdLike): Promise<TransactionResponse>;
    updateConfig(newConfig?: WalletConfig): Promise<[WalletConfig, TransactionResponse | undefined]>;
    publishConfig(): Promise<TransactionResponse | undefined>;
    isDeployed(chainId?: ChainIdLike): Promise<boolean>;
    _legacySignMessage(message: Bytes | string, chainId?: ChainIdLike, allSigners?: boolean): Promise<string>;
    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, message: Record<string, any>, chainId?: ChainIdLike, allSigners?: boolean): Promise<string>;
    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>, chainId?: ChainIdLike): Promise<string>;
    connectUnchecked(): ethers.providers.JsonRpcSigner;
    unlock(password: string): Promise<boolean>;
}
