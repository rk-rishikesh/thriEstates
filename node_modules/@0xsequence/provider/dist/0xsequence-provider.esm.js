import { EventEmitter2 } from 'eventemitter2';
import { logger, shallowCopy, resolveProperties, encodeMessageDigest, encodeTypedDataDigest, packMessageData, sanitizeNumberString, sanitizeHost, sanitizeAlphanumeric, base64EncodeObject, base64DecodeObject } from '@0xsequence/utils';
import { ethers, BigNumber } from 'ethers';
import { addressOf, isConfigEqual } from '@0xsequence/config';
import { Web3Provider as Web3Provider$1, JsonRpcProvider } from '@ethersproject/providers';
import { JsonRpcSender, maybeChainId, allowProviderMiddleware, networkProviderMiddleware, CachedProvider, JsonRpcRouter, loggingProviderMiddleware, exceptionProviderMiddleware, findNetworkConfig, EagerProvider, SigningProvider, updateNetworkConfig, ensureValidNetworks } from '@0xsequence/network';
import { Signer, resolveArrayProperties, isValidSignature as isValidSignature$1, recoverConfig } from '@0xsequence/wallet';
import { isSignedTransactions } from '@0xsequence/transactions';
import { signAuthorization } from '@0xsequence/auth';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// ProviderMessageCallback is used to respond to ProviderMessage requests. The error
// argument is for exceptions during the execution, and response is the response payload
// which may contain the result or an error payload from the wallet.
class WindowSessionParams extends URLSearchParams {
  static new(init) {
    return new URLSearchParams(init);
  }

}
let EventType;

(function (EventType) {
  EventType["OPEN"] = "open";
  EventType["CLOSE"] = "close";
  EventType["MESSAGE"] = "message";
  EventType["CONNECT"] = "connect";
  EventType["DISCONNECT"] = "disconnect";
  EventType["ACCOUNTS_CHANGED"] = "accountsChanged";
  EventType["CHAIN_CHANGED"] = "chainChanged";
  EventType["NETWORKS"] = "networks";
  EventType["WALLET_CONTEXT"] = "walletContext";
  EventType["INIT"] = "init";
  EventType["DEBUG"] = "_debug";
})(EventType || (EventType = {}));

let OpenState;

(function (OpenState) {
  OpenState[OpenState["CLOSED"] = 0] = "CLOSED";
  OpenState[OpenState["OPENING"] = 1] = "OPENING";
  OpenState[OpenState["OPENED"] = 2] = "OPENED";
})(OpenState || (OpenState = {}));

let InitState;

(function (InitState) {
  InitState[InitState["NIL"] = 0] = "NIL";
  InitState[InitState["SENT_NONCE"] = 1] = "SENT_NONCE";
  InitState[InitState["OK"] = 2] = "OK";
})(InitState || (InitState = {}));

class ProviderError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ProviderError';
  }

}
const ErrSignedInRequired = new ProviderError('Wallet is not signed in. Connect a wallet and try again.'); // TODO: lets build some nice error handling tools, prob in /utils ...

const PROVIDER_OPEN_TIMEOUT = 30000; // in ms

let _messageIdx = 0;
const nextMessageIdx = () => ++_messageIdx;
class BaseProviderTransport {
  constructor() {
    var _this = this;

    this.pendingMessageRequests = [];
    this.responseCallbacks = new Map();
    this.state = void 0;
    this.confirmationOnly = false;
    this.events = new EventEmitter2();
    this.openPayload = void 0;
    this.connectPayload = void 0;
    this.accountsChangedPayload = void 0;
    this.networksPayload = void 0;
    this.walletContextPayload = void 0;
    this._sessionId = void 0;
    this._init = void 0;
    this._registered = void 0;

    this.sendAsync = async function (request, callback, chainId) {
      // here, we receive the message from the dapp provider call
      if (_this.state === OpenState.CLOSED) {
        // flag the wallet to auto-close once user submits input. ie.
        // prompting to sign a message or transaction
        _this.confirmationOnly = true;
      } // open/focus the wallet.
      // automatically open the wallet when a provider request makes it here.
      //
      // NOTE: if we're not signed in, then the provider will fail, users must first connect+sign in.
      //
      // TODO: how does this behave with a session has expired?


      _this.openWallet(undefined, {
        type: 'jsonRpcRequest',
        method: request.method
      }, chainId); // send message request, await, and then execute callback after receiving the response


      try {
        if (!_this.isOpened()) {
          await _this.waitUntilOpened(); // will throw on timeout
        }

        const response = await _this.sendMessageRequest({
          idx: nextMessageIdx(),
          type: EventType.MESSAGE,
          data: request,
          chainId: chainId
        });
        callback(undefined, response.data);
      } catch (err) {
        callback(err);
      }
    };

    this.sendMessageRequest = async function (message) {
      return new Promise((resolve, reject) => {
        if ((!message.idx || message.idx <= 0) && message.type !== 'init') {
          reject(new Error('message idx not set'));
        }

        const responseCallback = (error, response) => {
          if (error) {
            reject(error);
          } else if (response) {
            resolve(response);
          } else {
            throw new Error('no valid response to return');
          }
        };

        const idx = message.idx;

        if (!_this.responseCallbacks.get(idx)) {
          _this.responseCallbacks.set(idx, responseCallback);
        } else {
          reject(new Error('duplicate message idx, should never happen'));
        }

        if (!_this.isOpened()) {
          logger.debug('pushing to pending requests', message);

          _this.pendingMessageRequests.push(message);
        } else {
          _this.sendMessage(message);
        }
      });
    };

    this.waitUntilOpened = async function (openTimeout = PROVIDER_OPEN_TIMEOUT) {
      let opened = false;
      return Promise.race([new Promise((_, reject) => {
        const timeout = setTimeout(() => {
          clearTimeout(timeout); // only emit close if the timeout wins the race

          if (!opened) {
            _this.state = OpenState.CLOSED;

            _this.events.emit('close', {
              code: 1005,
              message: 'opening wallet timed out'
            });
          }

          reject(new Error('opening wallet timed out'));
        }, openTimeout);
      }), new Promise(resolve => {
        if (_this.isOpened()) {
          var _this$openPayload;

          opened = true;
          resolve((_this$openPayload = _this.openPayload) == null ? void 0 : _this$openPayload.session);
          return;
        }

        _this.events.once('open', openInfo => {
          _this.openPayload = openInfo;
          opened = true;
          resolve(openInfo.session);
        });
      })]);
    };

    this.waitUntilConnected = async function () {
      await _this.waitUntilOpened();
      const connect = new Promise(resolve => {
        if (_this.connectPayload) {
          resolve(_this.connectPayload);
          return;
        }

        _this.events.once('connect', connectDetails => {
          _this.connectPayload = connectDetails;
          resolve(connectDetails);
        });
      });
      const closeWallet = new Promise((_, reject) => {
        _this.events.once('close', error => {
          if (error) {
            reject(new Error(`wallet closed due to ${JSON.stringify(error)}`));
          } else {
            reject(new Error(`user closed the wallet`));
          }
        });
      });
      return Promise.race([connect, closeWallet]);
    };

    this.state = OpenState.CLOSED;
    this._registered = false;
    this._init = InitState.NIL;
  }

  get registered() {
    return this._registered;
  }

  register() {
    throw new Error('abstract method');
  }

  unregister() {
    throw new Error('abstract method');
  }

  openWallet(path, intent, networkId) {
    throw new Error('abstract method');
  }

  closeWallet() {
    throw new Error('abstract method');
  }

  isOpened() {
    return this.registered && this.state === OpenState.OPENED;
  }

  isConnected() {
    var _this$openPayload2;

    // if we're registered, and we have the account details, then we are connected
    const session = (_this$openPayload2 = this.openPayload) == null ? void 0 : _this$openPayload2.session;
    return this.registered && session !== undefined && !!session.accountAddress && session.accountAddress.length === 42 && !!session.networks && session.networks.length > 0;
  }

  // handleMessage will handle message received from the remote wallet
  handleMessage(message) {
    var _this2 = this;

    // init incoming for initial handshake with transport.
    // always respond to INIT messages, e.g. on popup window reload
    if (message.type === EventType.INIT) {
      logger.debug('MessageProvider, received INIT message', message);
      const {
        nonce
      } = message.data;

      if (!nonce || nonce.length == 0) {
        logger.error('invalid init nonce');
        return;
      }

      this._init = InitState.OK;
      this.sendMessage({
        idx: -1,
        type: EventType.INIT,
        data: {
          sessionId: this._sessionId,
          nonce: nonce
        }
      });
    }

    if (this._init !== InitState.OK) {
      // if provider is not init'd, then we drop any received messages. the only
      // message we will process is of event type 'init', as our acknowledgement
      return;
    } // message is either a notification, or its a ProviderMessageResponse


    logger.debug('RECEIVED MESSAGE FROM WALLET', message.idx, message);
    const requestIdx = message.idx;
    const responseCallback = this.responseCallbacks.get(requestIdx);

    if (requestIdx) {
      this.responseCallbacks.delete(requestIdx);
    } // OPEN response
    //
    // Flip opened flag, and flush the pending queue


    if (message.type === EventType.OPEN && !this.isOpened()) {
      var _message$data, _message$data2;

      if (this._sessionId && this._sessionId !== ((_message$data = message.data) == null ? void 0 : _message$data.sessionId)) {
        logger.debug('open event received from wallet, but does not match sessionId', this._sessionId);
        return;
      } // check if open error occured due to invalid defaultNetworkId


      if ((_message$data2 = message.data) != null && _message$data2.error) {
        var _message$data3;

        const err = new Error(`opening wallet failed: received ${(_message$data3 = message.data) == null ? void 0 : _message$data3.error}`);
        logger.error(err);
        this.close();
        throw err;
      } // success!


      this.state = OpenState.OPENED;
      this.openPayload = message.data;
      this.events.emit('open', this.openPayload); // flush pending requests when connected

      if (this.pendingMessageRequests.length !== 0) {
        const pendingMessageRequests = this.pendingMessageRequests.splice(0, this.pendingMessageRequests.length);
        pendingMessageRequests.forEach(async function (pendingMessageRequest) {
          _this2.sendMessage(pendingMessageRequest);
        });
      }

      return;
    } // MESSAGE resposne


    if (message.type === EventType.MESSAGE) {
      // Require user confirmation, bring up wallet to prompt for input then close
      // TODO: perhaps apply technique like in multicall to queue messages within
      // a period of time, then close the window if responseCallbacks is empty, this is better.
      if (this.confirmationOnly) {
        setTimeout(() => {
          if (this.responseCallbacks.size === 0) {
            this.closeWallet();
          }
        }, 500); // TODO: be smarter about timer as we're processing the response callbacks..
      }

      if (!responseCallback) {
        // NOTE: this would occur if 'idx' isn't set, which should never happen
        // or when we register two handler, or duplicate messages with the same idx are sent,
        // all of which should be prevented prior to getting to this point
        throw new Error('impossible state');
      } // Callback to original caller


      if (responseCallback) {
        this.events.emit('message', message);
        responseCallback(message.data.error, message);
        return;
      }
    } // ACCOUNTS_CHANGED -- when a user logs in or out


    if (message.type === EventType.ACCOUNTS_CHANGED) {
      this.accountsChangedPayload = {
        accounts: []
      };

      if (message.data && message.data.length > 0) {
        this.accountsChangedPayload = {
          accounts: [ethers.utils.getAddress(message.data[0])],
          origin: message.origin
        };
        this.events.emit('accountsChanged', this.accountsChangedPayload.accounts, this.accountsChangedPayload.origin);
      } else {
        this.events.emit('accountsChanged', [], message.origin);
      }

      return;
    } // CHAIN_CHANGED -- when a user changes their default chain


    if (message.type === EventType.CHAIN_CHANGED) {
      this.events.emit('chainChanged', message.data);
      return;
    } // NOTIFY NETWORKS -- when a user connects or logs in


    if (message.type === EventType.NETWORKS) {
      this.networksPayload = message.data;
      this.events.emit('networks', this.networksPayload);
      return;
    } // NOTIFY WALLET_CONTEXT -- when a user connects or logs in


    if (message.type === EventType.WALLET_CONTEXT) {
      this.walletContextPayload = message.data;
      this.events.emit('walletContext', this.walletContextPayload);
      return;
    } // NOTIFY CLOSE -- when wallet instructs to close


    if (message.type === EventType.CLOSE) {
      if (this.state !== OpenState.CLOSED) {
        this.close(message.data);
      }
    } // NOTIFY CONNECT -- when wallet instructs we've connected


    if (message.type === EventType.CONNECT) {
      this.connectPayload = message.data;
      this.events.emit('connect', this.connectPayload);
    } // NOTIFY DISCONNECT -- when wallet instructs to disconnect


    if (message.type === EventType.DISCONNECT) {
      if (this.isConnected()) {
        this.events.emit('disconnect', message.data);
        this.close();
      }
    }
  } // sendMessageRequest sends a ProviderMessageRequest over the wire to the wallet


  sendMessage(message) {
    throw new Error('abstract method');
  }

  on(event, fn) {
    this.events.on(event, fn);
  }

  once(event, fn) {
    this.events.once(event, fn);
  }

  emit(event, ...args) {
    return this.events.emit(event, ...args);
  }

  close(error) {
    if (this.state === OpenState.CLOSED) return;
    this.state = OpenState.CLOSED;
    this.confirmationOnly = false;
    this._sessionId = undefined;
    logger.info('closing wallet and flushing!'); // flush pending requests and return error to all callbacks

    this.pendingMessageRequests.length = 0;
    this.responseCallbacks.forEach(responseCallback => {
      responseCallback(_extends({}, new Error('wallet closed'), {
        code: 4001
      }));
    });
    this.responseCallbacks.clear();
    this.connectPayload = undefined;
    this.openPayload = undefined;
    this.accountsChangedPayload = undefined;
    this.networksPayload = undefined;
    this.walletContextPayload = undefined;
    this.events.emit('close', error);
  }

}

const SIGNER_READY_TIMEOUT = 10000;
class WalletRequestHandler {
  // signer interface of the wallet. A null value means there is no signer (ie. user not signed in). An undefined
  // value means the signer state is unknown, usually meaning the wallet app is booting up and initializing. Of course
  // a Signer value is the actually interface to a signed-in account
  constructor(_signer, prompter, mainnetNetworks, testnetNetworks = []) {
    var _this = this;

    this.signer = void 0;
    this.signerReadyCallbacks = [];
    this.prompter = void 0;
    this.mainnetNetworks = void 0;
    this.testnetNetworks = void 0;
    this._openIntent = void 0;
    this._connectOptions = void 0;
    this._defaultNetworkId = void 0;
    this._chainId = void 0;
    this.events = new EventEmitter2();

    this.promptConnect = async function (options) {
      if (!options && !_this._connectOptions) {
        // this is an unexpected state and should not happen
        throw new Error('prompter connect options are empty');
      }

      if (!_this.prompter) {
        // if prompter is null, we'll auto connect
        return _this.connect(options);
      }

      const promptConnectDetails = await _this.prompter.promptConnect(options || _this._connectOptions).catch(_ => {
        return {
          connected: false
        };
      });
      const connectDetails = promptConnectDetails;

      if (connectDetails.connected && !connectDetails.session) {
        connectDetails.session = await _this.walletSession();
      }

      return promptConnectDetails;
    };

    this.sendAsync = async function (request, callback, chainId) {
      const response = {
        jsonrpc: '2.0',
        id: request.id,
        result: null
      };
      await _this.getSigner();

      try {
        // only allow public json rpc method to the provider when user is not logged in, aka signer is not set
        if ((!_this.signer || _this.signer === null) && !permittedJsonRpcMethods.includes(request.method)) {
          // throw new Error(`not logged in. ${request.method} is unavailable`)
          throw ErrSignedInRequired;
        } // wallet signer


        const signer = _this.signer;
        if (!signer) throw new Error('WalletRequestHandler: wallet signer is not configured'); // fetch the provider for the specific chain, or undefined will select defaultChain

        const provider = await signer.getProvider(chainId);
        if (!provider) throw new Error(`WalletRequestHandler: wallet provider is not configured for chainId ${chainId}`);

        switch (request.method) {
          case 'net_version':
            {
              const result = await provider.send('net_version', []);
              response.result = result;
              break;
            }

          case 'eth_chainId':
            {
              const result = await provider.send('eth_chainId', []);
              response.result = result;
              break;
            }

          case 'eth_accounts':
            {
              const walletAddress = await signer.getAddress();
              response.result = [walletAddress];
              break;
            }

          case 'eth_getBalance':
            {
              const [accountAddress, blockTag] = request.params;
              const walletBalance = await provider.getBalance(accountAddress, blockTag);
              response.result = walletBalance.toHexString();
              break;
            }

          case 'personal_sign':
          case 'eth_sign':
            {
              // note: message from json-rpc input is in hex format
              let message; // there is a difference in the order of the params:
              // personal_sign: [data, address]
              // eth_sign: [address, data]

              if (request.method === 'personal_sign') {
                const [data, address] = request.params;
                message = data;
              } else {
                const [address, data] = request.params;
                message = data;
              }

              let sig = ''; // Message must be prefixed with "\x19Ethereum Signed Message:\n"
              // as defined by EIP-191

              message = prefixEIP191Message(message); // TODO:
              // if (process.env.TEST_MODE === 'true' && this.prompter === null) {

              if (_this.prompter === null) {
                // prompter is null, so we'll sign from here
                sig = await signer.signMessage(ethers.utils.arrayify(message), chainId);
              } else {
                const promptResultForDeployment = await _this.handleConfirmWalletDeployPrompt(_this.prompter, signer, chainId);

                if (promptResultForDeployment) {
                  sig = await _this.prompter.promptSignMessage({
                    chainId: chainId,
                    message
                  }, _this.connectOptions);
                }
              }

              if (sig && sig.length > 0) {
                response.result = sig;
              } else {
                // The user has declined the request when value is null
                throw new Error('declined by user');
              }

              break;
            }

          case 'eth_signTypedData':
          case 'eth_signTypedData_v4':
            {
              // note: signingAddress from json-rpc input is in hex format, and typedDataObject
              // should be an object, but in some instances may be double string encoded
              const [signingAddress, typedDataObject] = request.params;
              let typedData = undefined;

              if (typeof typedDataObject === 'string') {
                try {
                  typedData = JSON.parse(typedDataObject);
                } catch (e) {}
              } else {
                typedData = typedDataObject;
              }

              if (!typedData || !typedData.domain || !typedData.types || !typedData.message) {
                throw new Error('invalid typedData object');
              }

              let sig = '';

              if (_this.prompter === null) {
                // prompter is null, so we'll sign from here
                sig = await signer.signTypedData(typedData.domain, typedData.types, typedData.message, chainId);
              } else {
                const promptResultForDeployment = await _this.handleConfirmWalletDeployPrompt(_this.prompter, signer, chainId);

                if (promptResultForDeployment) {
                  sig = await _this.prompter.promptSignMessage({
                    chainId: chainId,
                    typedData: typedData
                  }, _this.connectOptions);
                }
              }

              if (sig && sig.length > 0) {
                response.result = sig;
              } else {
                // The user has declined the request when value is null
                throw new Error('declined by user');
              }

              break;
            }

          case 'eth_sendTransaction':
            {
              // https://eth.wiki/json-rpc/API#eth_sendtransaction
              const [transactionParams] = request.params;
              let txnHash = '';

              if (_this.prompter === null) {
                // prompter is null, so we'll send from here
                const txnResponse = await signer.sendTransaction(transactionParams, chainId);
                txnHash = txnResponse.hash;
              } else {
                // prompt user to provide the response
                txnHash = await _this.prompter.promptSendTransaction(transactionParams, chainId, _this.connectOptions);
              }

              if (txnHash) {
                response.result = txnHash;
              } else {
                // The user has declined the request when value is null
                throw new Error('declined by user');
              }

              break;
            }

          case 'eth_signTransaction':
            {
              // https://eth.wiki/json-rpc/API#eth_signTransaction
              const [transaction] = request.params;
              const sender = ethers.utils.getAddress(transaction.from);

              if (sender !== (await signer.getAddress())) {
                throw new Error('sender address does not match wallet');
              }

              if (_this.prompter === null) {
                // The eth_signTransaction method expects a `string` return value we instead return a `SignedTransactions` object,
                // this can only be broadcasted using an RPC provider with support for signed Sequence transactions, like this one.
                //
                // TODO: verify serializing / transporting the SignedTransaction object works as expected, most likely however
                // we will want to resolveProperties the bignumber values to hex strings
                response.result = await signer.signTransactions(transaction, chainId);
              } else {
                response.result = await _this.prompter.promptSignTransaction(transaction, chainId, _this.connectOptions);
              }

              break;
            }

          case 'eth_sendRawTransaction':
            {
              // NOTE: we're not using a prompter here as the transaction is already signed
              // and would have prompted the user upon signing.
              // https://eth.wiki/json-rpc/API#eth_sendRawTransaction
              if (isSignedTransactions(request.params[0])) {
                const txChainId = BigNumber.from(request.params[0].chainId).toNumber();
                const tx = await (await signer.getRelayer(txChainId)).relay(request.params[0]);
                response.result = (await tx).hash;
              } else {
                const tx = await provider.sendTransaction(request.params[0]);
                response.result = tx.hash;
              }

              break;
            }

          case 'eth_getTransactionCount':
            {
              const address = ethers.utils.getAddress(request.params[0]);
              const tag = request.params[1];
              const walletAddress = ethers.utils.getAddress(await signer.getAddress());

              if (address === walletAddress) {
                const count = await signer.getTransactionCount(tag);
                response.result = ethers.BigNumber.from(count).toHexString();
              } else {
                const count = await provider.getTransactionCount(address, tag);
                response.result = ethers.BigNumber.from(count).toHexString();
              }

              break;
            }

          case 'eth_blockNumber':
            {
              response.result = await provider.getBlockNumber();
              break;
            }

          case 'eth_getBlockByNumber':
            {
              response.result = await provider.getBlock(request.params[0]
              /* , jsonRpcRequest.params[1] */
              );
              break;
            }

          case 'eth_getBlockByHash':
            {
              response.result = await provider.getBlock(request.params[0]
              /* , jsonRpcRequest.params[1] */
              );
              break;
            }

          case 'eth_getTransactionByHash':
            {
              response.result = await provider.getTransaction(request.params[0]);
              break;
            }

          case 'eth_call':
            {
              const [transactionObject, blockTag] = request.params;
              response.result = await provider.call(transactionObject, blockTag);
              break;
            }

          case 'eth_getCode':
            {
              const [contractAddress, blockTag] = request.params;
              response.result = await provider.getCode(contractAddress, blockTag);
              break;
            }

          case 'eth_estimateGas':
            {
              const [transactionObject] = request.params;
              response.result = await provider.estimateGas(transactionObject);
              break;
            }

          case 'eth_gasPrice':
            {
              const gasPrice = await provider.getGasPrice();
              response.result = gasPrice.toHexString();
              break;
            }

          case 'wallet_switchEthereumChain':
            {
              const [switchParams] = request.params;

              if (!switchParams.chainId || switchParams.chainId.length === 0) {
                throw new Error('invalid chainId');
              }

              const _chainId = ethers.BigNumber.from(switchParams.chainId);

              const ok = await _this.setDefaultNetwork(_chainId.toString(), true);

              if (!ok) {
                throw new Error(`unable to set chainId ${_chainId}`);
              }

              response.result = null; // success

              break;
            }
          // smart wallet method

          case 'sequence_getWalletContext':
            {
              response.result = await signer.getWalletContext();
              break;
            }
          // smart wallet method

          case 'sequence_getWalletConfig':
            {
              const [_chainId2] = request.params;
              response.result = await signer.getWalletConfig(_chainId2);
              break;
            }
          // smart wallet method

          case 'sequence_getWalletState':
            {
              const [_chainId3] = request.params;
              response.result = await signer.getWalletState(_chainId3);
              break;
            }
          // smart wallet method

          case 'sequence_getNetworks':
            {
              // NOTE: must ensure that the response result below returns clean serialized data, which is to omit
              // the provider and relayer objects and only return the urls so can be reinstantiated on dapp side.
              // This is handled by this.getNetworks() but noted here for future readers.
              response.result = await _this.getNetworks(true);
              break;
            }
          // smart wallet method

          case 'sequence_updateConfig':
            {
              throw new Error('sequence_updateConfig method is not allowed from a dapp'); // NOTE: method is disabled as we don't need a dapp to request to update a config.
              // However, if we ever want this, we can enable it but must also use the prompter
              // for confirmation.
              //
              // const [newConfig] = request.params
              // response.result = await signer.updateConfig(newConfig)

              break;
            }
          // smart wallet method

          case 'sequence_publishConfig':
            {
              throw new Error('sequence_publishConfig method is not allowed from a dapp');
              break;
            }
          // relayer method

          case 'sequence_estimateGasLimits':
            {
              // TODO
              break;
            }
          // relayer method

          case 'sequence_gasRefundOptions':
            {
              // TODO
              break;
            }
          // relayer method

          case 'sequence_getNonce':
            {
              // TODO
              break;
            }
          // relayer method

          case 'sequence_relay':
            {
              // TODO
              break;
            }
          // set default network of wallet

          case 'sequence_setDefaultNetwork':
            {
              const [defaultNetworkId] = request.params;

              if (!defaultNetworkId) {
                throw new Error('invalid request, method argument defaultNetworkId cannot be empty');
              }

              const ok = await _this.setDefaultNetwork(defaultNetworkId);

              if (!ok) {
                throw new Error(`unable to set default network ${defaultNetworkId}`);
              }

              response.result = await _this.getNetworks(true);
              break;
            }

          default:
            {
              // NOTE: provider here will be chain-bound if chainId is provided
              const providerResponse = await provider.send(request.method, request.params);
              response.result = providerResponse;
            }
        }
      } catch (err) {
        logger.error(err); // See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md#rpc-errors

        response.result = null;
        response.error = _extends({}, new Error(err), {
          code: 4001
        });
      }

      callback(undefined, response);
    };

    this.isSignedIn = async function () {
      await _this.signerReady();
      return !!_this.signer;
    };

    this.getSigner = async function () {
      await _this.signerReady();

      if (_this.signer === undefined) {
        throw new Error('signerReady failed resolve');
      }

      return _this.signer;
    };

    this.signer = _signer;
    this.prompter = prompter;
    this.mainnetNetworks = mainnetNetworks;
    this.testnetNetworks = testnetNetworks;
  }

  async signIn(signer, options = {}) {
    this.setSigner(signer);
    const {
      connect,
      mainnetNetworks,
      testnetNetworks,
      defaultNetworkId
    } = options;

    if (mainnetNetworks && mainnetNetworks.length > 0) {
      this.mainnetNetworks = mainnetNetworks;
    }

    if (testnetNetworks && testnetNetworks.length > 0) {
      this.testnetNetworks = testnetNetworks;
    }

    if ((!this.mainnetNetworks || this.mainnetNetworks.length === 0) && (!this.testnetNetworks || this.testnetNetworks.length === 0)) {
      throw new Error('signIn failed as network configuration is empty');
    }

    const networkId = defaultNetworkId || this._defaultNetworkId;

    if (networkId) {
      if (!(await this.setDefaultNetwork(networkId, false))) {
        throw new Error(`WalletRequestHandler setup unable to set defaultNetworkId ${networkId}`);
      }
    } // Optionally, connect the dapp and wallet. In case connectOptions are provided, we will perform
    // necessary auth request, and then notify the dapp of the 'connect' details.
    //
    // NOTE: if a user is signing into a dapp from a fresh state, and and auth request is made
    // we don't trigger the promptConnect flow, as we consider the user just authenticated
    // for this dapp, so its safe to authorize in the connect() method without the prompt.
    //
    // NOTE: signIn can optionally connect and notify dapp at this time for new signIn flows


    if (connect) {
      const connectOptions = this._connectOptions;
      const connectDetails = await this.connect(connectOptions);
      this.notifyConnect(connectDetails);

      if (!connectOptions || connectOptions.keepWalletOpened !== true) {
        this.notifyClose();
      }
    }
  }

  signOut() {
    // signed out state
    this.setSigner(null);
  }

  signerReset() {
    // resetting signer puts the wallet in an uninitialized state, which requires the app to
    // re-initiatize and set the signer either as "null" (ie. no signer) or "Signer" (ie. signed in).
    this.signer = undefined;
  }

  signerReady(timeout = SIGNER_READY_TIMEOUT) {
    return new Promise((resolve, reject) => {
      if (this.signer !== undefined) {
        resolve();
      } else {
        setTimeout(() => {
          if (this.signer === undefined) {
            this.signerReadyCallbacks = [];
            reject(`signerReady timed out`);
          }
        }, timeout);
        this.signerReadyCallbacks.push(resolve);
      }
    });
  }

  async connect(options) {
    if (!this.signer) {
      return {
        connected: false,
        chainId: '0x0',
        error: 'unable to connect without signed in account'
      };
    }

    const connectDetails = {
      connected: true,
      chainId: ethers.utils.hexlify(await this.getChainId())
    };

    if (options && options.authorize) {
      // Perform ethauth eip712 request and construct the ConnectDetails response
      // including the auth proof
      const authOptions = {
        app: options.app,
        origin: options.origin,
        expiry: options.expiry
      }; // if (typeof(options.authorize) === 'object') {
      //   authOptions = { ...authOptions, ...options.authorize }
      // }

      try {
        connectDetails.proof = await signAuthorization(this.signer, authOptions);
      } catch (err) {
        logger.warn(`connect, signAuthorization failed for options: ${JSON.stringify(options)}, due to: ${err.message}`);
        return {
          connected: false,
          chainId: '0x0',
          error: `signAuthorization failed: ${err.message}`
        };
      }
    } // Build session response for connect details


    connectDetails.session = await this.walletSession();
    return connectDetails;
  }

  // sendMessageRequest will unwrap the ProviderMessageRequest and send it to the JsonRpcHandler
  // (aka, the signer in this instance) and then responds with a wrapped response of
  // ProviderMessageResponse to be sent over the transport
  sendMessageRequest(message) {
    return new Promise(resolve => {
      this.sendAsync(message.data, (error, response) => {
        // TODO: if response includes data.error, why do we need a separate error argument here?
        const responseMessage = _extends({}, message, {
          data: response
        }); // NOTE: we always resolve here, are the sendAsync call will wrap any exceptions
        // in the error field of the response to ensure we send back to the user


        resolve(responseMessage);
      }, message.chainId);
    });
  } // sendAsync implements the JsonRpcHandler interface for sending JsonRpcRequests to the wallet


  on(event, fn) {
    this.events.on(event, fn);
  }

  once(event, fn) {
    this.events.once(event, fn);
  }

  async getAddress() {
    if (!this.signer) {
      return '';
    } else {
      return this.signer.getAddress();
    }
  }

  async getChainId() {
    if (!this.signer) {
      return 0;
    } else {
      if (this._chainId) return this._chainId; // memoized

      this._chainId = await this.signer.getChainId();
      return this._chainId;
    }
  }

  get openIntent() {
    return this._openIntent;
  }

  setOpenIntent(intent) {
    this._openIntent = intent;
  }

  get connectOptions() {
    return this._connectOptions;
  }

  setConnectOptions(options) {
    this._connectOptions = options;
  }

  get defaultNetworkId() {
    return this._defaultNetworkId;
  }

  async setDefaultNetwork(chainId, notifyNetworks = true) {
    if (!chainId) return undefined;
    this._defaultNetworkId = chainId;
    this._chainId = undefined;

    if (this.signer && this.signer.setNetworks) {
      const defaultChainId = this.signer.setNetworks(this.mainnetNetworks, this.testnetNetworks, chainId);

      if (defaultChainId && notifyNetworks) {
        await this.notifyNetworks();
      }

      return defaultChainId;
    } else {
      return undefined;
    }
  }

  async getNetworks(jsonRpcResponse) {
    if (!this.signer) {
      logger.warn('signer not set: getNetworks is returning an empty list');
      return [];
    }

    const networks = await this.signer.getNetworks();

    if (jsonRpcResponse) {
      // omit provider and relayer objects as they are not serializable
      return networks.map(n => {
        const network = _extends({}, n);

        network.provider = undefined;
        network.relayer = undefined;
        return network;
      });
    } else {
      return networks;
    }
  }

  async walletSession() {
    return !this.signer ? undefined : {
      walletContext: await this.signer.getWalletContext(),
      accountAddress: await this.signer.getAddress(),
      networks: await this.getNetworks(true)
    };
  }

  notifyConnect(connectDetails, origin) {
    var _connectDetails$sessi;

    this.events.emit('connect', connectDetails);

    if ((_connectDetails$sessi = connectDetails.session) != null && _connectDetails$sessi.accountAddress) {
      var _connectDetails$sessi2;

      this.events.emit('accountsChanged', [(_connectDetails$sessi2 = connectDetails.session) == null ? void 0 : _connectDetails$sessi2.accountAddress], origin);
    }
  }

  notifyDisconnect(origin) {
    this.events.emit('accountsChanged', [], origin);
    this.events.emit('disconnect');
  }

  async notifyNetworks(networks) {
    const n = networks || (await this.getNetworks(true));
    this.events.emit('networks', n);

    if (n.length > 0) {
      const defaultNetwork = n.find(network => network.isDefaultChain);

      if (defaultNetwork) {
        this.events.emit('chainChanged', ethers.utils.hexlify(defaultNetwork.chainId));
      }
    } else {
      this.events.emit('chainChanged', '0x0');
    }
  }

  async notifyWalletContext() {
    if (!this.signer) {
      logger.warn('signer not set: skipping to notify wallet context');
      return;
    }

    const walletContext = await this.signer.getWalletContext();
    this.events.emit('walletContext', walletContext);
  }

  notifyClose(error) {
    this.events.emit('close', error);
  }

  setSigner(signer) {
    this.signer = signer;

    if (signer !== undefined) {
      for (let i = 0; i < this.signerReadyCallbacks.length; i++) {
        this.signerReadyCallbacks[i]();
      }

      this.signerReadyCallbacks = [];
    }
  }

  async handleConfirmWalletDeployPrompt(prompter, signer, chainId) {
    // check if wallet is deployed and up to date, if not, prompt user to deploy
    // if no chainId is provided, we'll assume the wallet is auth chain wallet and is up to date
    if (!chainId) {
      return true;
    }

    const isUpToDate = await isWalletUpToDate(signer, chainId);

    if (isUpToDate) {
      return true;
    }

    const promptResult = await prompter.promptConfirmWalletDeploy(chainId, this.connectOptions); // if client returned true, check again to make sure wallet is deployed and up to date

    if (promptResult) {
      const isPromptResultCorrect = await isWalletUpToDate(signer, chainId);

      if (!isPromptResultCorrect) {
        logger.error('WalletRequestHandler: result for promptConfirmWalletDeploy is not correct');
        return false;
      } else {
        return true;
      }
    }

    return false;
  }

}
const permittedJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_getBalance', 'eth_getTransactionCount', 'eth_blockNumber', 'eth_getBlockByNumber', 'eth_getBlockByHash', 'eth_getTransactionByHash', 'eth_getCode', 'eth_estimateGas', 'eth_gasPrice', 'sequence_getWalletContext', 'sequence_getNetworks', 'sequence_setDefaultNetwork'];

class Web3Provider extends Web3Provider$1 {
  static isSequenceProvider(cand) {
    return isSequenceProvider(cand);
  }

  constructor(provider, defaultChainId) {
    const sender = new JsonRpcSender(provider, maybeChainId(defaultChainId));
    provider = sender;
    super(provider, 'any');
    this._sender = void 0;
    this._isSequenceProvider = void 0;
    this._defaultChainId = void 0;
    this._sender = sender;
    this._isSequenceProvider = true;
    this._defaultChainId = maybeChainId(defaultChainId);
  }

  sendAsync(request, callback, chainId) {
    this._sender.sendAsync(request, callback, chainId);
  }

  send(method, params, chainId) {
    return this._sender.send(method, params, chainId);
  }

  request(request) {
    return this.send(request.method, request.params || [], request.chainId);
  }

  getSigner() {
    return new Web3Signer(this, this._defaultChainId);
  }

  async getChainId() {
    // TODO: is it safe to memoize this?
    const result = await this.send('eth_chainId', []);
    const chainId = ethers.BigNumber.from(result).toNumber();

    if (this._defaultChainId && this._defaultChainId !== chainId) {
      throw new Error(`provider chainId (${chainId}) does not match provider-bound chainId ${this._defaultChainId}`);
    }

    return chainId;
  }

}
function isSequenceProvider(provider) {
  const cand = provider;
  return cand && cand.send !== undefined && cand._isSequenceProvider === true;
}
class LocalWeb3Provider extends Web3Provider {
  constructor(signer, networks) {
    const walletRequestHandler = new WalletRequestHandler(signer, null, networks || []);
    super(walletRequestHandler);
  }

}
class Web3Signer extends Signer {
  constructor(provider, defaultChainId) {
    super();
    this.provider = void 0;
    this.defaultChainId = void 0;
    this._address = void 0;
    this._index = void 0;
    this._context = void 0;
    this._networks = void 0;
    this._providers = {};
    this.provider = provider;
    this.defaultChainId = defaultChainId;
  } // memoized


  //
  // ethers AbstractSigner methods
  //
  async getAddress() {
    if (this._address) return this._address;
    const accounts = await this.provider.send('eth_accounts', []);
    this._address = accounts[0];
    this._index = 0;
    return ethers.utils.getAddress(this._address);
  }

  signTransaction(transaction) {
    // TODO .. since ethers isn't using this method, perhaps we will?
    throw new Error('signTransaction is unsupported, use signTransactions instead');
  }

  connect(provider) {
    throw new Error('unsupported: cannot alter JSON-RPC Signer connection');
  } //
  // Sequence Signer methods
  //
  // getProvider returns a Web3Provider instance for the current chain. Note that this method
  // and signer is bound to a particular chain to prevent misuse. If you'd like a provider
  // for a specific chain, try getSender(chainId), or wallet.getProvider(chainId).


  async getProvider(chainId) {
    if (chainId) {
      const currentChainId = await this.getChainId();

      if (currentChainId !== chainId) {
        throw new Error(`signer is attempting to access chain ${chainId}, but is already bound to chain ${currentChainId}`);
      }
    }

    return this.provider;
  } // getSender returns a Web3Provider instance via the signer transport. Note: for our case
  // the of sequence wallet, this will bring up the wallet window whenever using it, as the json-rpc
  // requests are sent to the window transport. Therefore, for anything non-signing related
  // you can write a higher-order JsonRpcRouter sender to route to the public provider endpoints
  // as we do in the WalletProvider.
  //
  // This method is primarily utilized internally when routing requests to a particular chainId.


  async getSender(chainId) {
    if (!chainId || chainId && chainId === this.defaultChainId) {
      return this.provider;
    }

    if (!this._providers[chainId]) {
      this._providers[chainId] = new Web3Provider(new JsonRpcSender(this.provider, chainId), chainId);
    }

    return this._providers[chainId];
  }

  getRelayer(chainId) {
    // TODO: JsonRpcRelayer ......? or, Web3Relayer.. or SequenceRelayer?
    // sequence_estimateGasLimits
    // sequence_gasRefundOptions
    // sequence_getNonce
    // sequence_relay
    throw new Error('TODO');
  }

  async getWalletContext() {
    if (!this._context) {
      this._context = await this.provider.send('sequence_getWalletContext', []);
    }

    return this._context;
  }

  async getWalletConfig(chainId) {
    return await this.provider.send('sequence_getWalletConfig', [maybeChainId(chainId)], maybeChainId(chainId) || this.defaultChainId);
  }

  async getWalletState(chainId) {
    return await this.provider.send('sequence_getWalletState', [maybeChainId(chainId)], maybeChainId(chainId) || this.defaultChainId);
  }

  async getNetworks() {
    if (!this._networks) {
      this._networks = await this.provider.send('sequence_getNetworks', []);
    }

    return this._networks;
  }

  async getSigners() {
    const networks = await this.getNetworks();
    const authChainId = networks.find(n => n.isAuthChain);

    if (!authChainId) {
      throw new Error('authChainId could not be determined from network list');
    }

    const walletConfig = await this.getWalletConfig(authChainId);

    if (!walletConfig || walletConfig.length === 0) {
      throw new Error(`walletConfig returned zero results for authChainId {authChainId}`);
    }

    return walletConfig[0].signers.map(s => s.address);
  } // signMessage matches implementation from ethers JsonRpcSigner for compatibility, but with
  // multi-chain support.


  async signMessage(message, chainId, allSigners) {
    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);
    const data = typeof message === 'string' ? ethers.utils.toUtf8Bytes(message) : message;
    const address = await this.getAddress(); // NOTE: as of ethers v5.5, it switched to using personal_sign, see
    // https://github.com/ethers-io/ethers.js/pull/1542 and see
    // https://github.com/WalletConnect/walletconnect-docs/issues/32 for additional info.

    return await provider.send('personal_sign', [ethers.utils.hexlify(data), address]);
  } // signTypedData matches implementation from ethers JsonRpcSigner for compatibility, but with
  // multi-chain support.


  async signTypedData(domain, types, message, chainId, allSigners) {
    // Populate any ENS names (in-place)
    // const populated = await ethers.utils._TypedDataEncoder.resolveNames(domain, types, message, (name: string) => {
    //   return this.provider.resolveName(name)
    // })
    return await this.provider.send('eth_signTypedData_v4', [await this.getAddress(), ethers.utils._TypedDataEncoder.getPayload(domain, types, message)], maybeChainId(chainId) || this.defaultChainId);
  } // sendTransaction matches implementation from ethers JsonRpcSigner for compatibility, but with
  // multi-chain support.


  async sendTransaction(transaction, chainId, allSigners) {
    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);
    const tx = this.sendUncheckedTransaction(transaction, chainId).then(hash => {
      return ethers.utils.poll(() => {
        return provider.getTransaction(hash).then(tx => {
          if (tx === null) {
            return undefined;
          }

          return provider._wrapTransaction(tx, hash);
        });
      }, {
        onceBlock: this.provider
      }).catch(error => {
        error.transactionHash = hash;
        throw error;
      });
    }); // @ts-ignore

    return tx;
  } // sendTransactionBatch is a convenience method to call sendTransaction in a batch format, allowing you to
  // send multiple transaction as a single payload and just one on-chain transaction.


  async sendTransactionBatch(transactions, chainId, allSigners) {
    const batch = await resolveArrayProperties(transactions);

    if (!batch || batch.length === 0) {
      throw new Error('cannot send empty batch');
    } // sendTransactionBatch only accepts TransactionRequest, not TransactionResponses


    if (batch.find(v => v.wait !== undefined && v.wait !== null)) {
      throw new Error('transaction request expected for sendTransactionBatch, transaction response found');
    }

    const tx = _extends({}, batch[0]);

    if (batch.length > 1) {
      tx.auxiliary = batch.splice(1);
    }

    return this.sendTransaction(tx, chainId, allSigners);
  }

  signTransactions(transaction, chainId, allSigners) {
    transaction = shallowCopy(transaction); // TODO: transaction argument..? make sure to resolve any properties and serialize property before sending over
    // the wire.. see sendUncheckedTransaction and resolveProperties

    return this.provider.send('eth_signTransaction', [transaction], maybeChainId(chainId) || this.defaultChainId);
  }

  sendSignedTransactions(signedTxs, chainId) {
    // sequence_relay
    throw new Error('TODO');
  } // updateConfig..
  // NOTE: this is not supported by the remote wallet by default.


  async updateConfig(newConfig) {
    // sequence_updateConfig
    const [config, tx] = await this.provider.send('sequence_updateConfig', [newConfig], this.defaultChainId);

    if (tx === null) {
      return [config, undefined];
    }

    const provider = await this.getSender(this.defaultChainId);
    return [config, provider._wrapTransaction(tx, tx.hash)];
  } // publishConfig..
  // NOTE: this is not supported by the remote wallet by default.


  async publishConfig() {
    const provider = await this.getSender(this.defaultChainId);
    const tx = await provider.send('sequence_publishConfig', []);

    if (tx === null) {
      return undefined;
    }

    return provider._wrapTransaction(tx, tx.hash);
  }

  async isDeployed(chainId) {
    const provider = await this.getSender(maybeChainId(chainId));
    const walletCode = await provider.getCode(await this.getAddress());
    return !!walletCode && walletCode !== '0x';
  } //
  // ethers JsonRpcSigner methods
  //


  async _legacySignMessage(message, chainId, allSigners) {
    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);
    const data = typeof message === 'string' ? ethers.utils.toUtf8Bytes(message) : message;
    const address = await this.getAddress(); // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
    // NOTE: ethers since 5.5 has switched to using personal_sign, we should review, etc.

    return await provider.send('eth_sign', [address, ethers.utils.hexlify(data)]);
  }

  async _signTypedData(domain, types, message, chainId, allSigners) {
    return this.signTypedData(domain, types, message, chainId, allSigners);
  }

  async sendUncheckedTransaction(transaction, chainId) {
    transaction = shallowCopy(transaction);
    const fromAddress = this.getAddress(); // NOTE: we do not use provider estimation, and instead rely on our relayer to determine the gasLimit and gasPrice
    //
    // TODO: alternatively/one day, we could write a provider middleware to eth_estimateGas
    // and send it to our relayer url instead for estimation..
    //
    // if (!transaction.gasLimit) {
    //   const estimate = shallowCopy(transaction)
    //   estimate.from = fromAddress
    //   transaction.gasLimit = this.provider.estimateGas(estimate)
    // }

    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: await fromAddress
    }).then(({
      tx,
      sender
    }) => {
      if (tx.from != null) {
        if (ethers.utils.getAddress(tx.from) !== sender) {
          // logger.throwArgumentError("from address mismatch", "transaction", transaction)
          throw new Error(`from address mismatch for transaction ${transaction}`);
        }
      } else {
        tx.from = sender;
      }

      const hexTx = hexlifyTransaction(tx);
      return provider.send('eth_sendTransaction', [hexTx]).then(hash => {
        return hash;
      }, error => {
        // return checkError("sendTransaction", error, hexTx)
        throw new Error(`sendTransaction ${error}`);
      });
    });
  }

  connectUnchecked() {
    throw new Error('connectUnchecked is unsupported');
  }

  async unlock(password) {
    const address = await this.getAddress();
    return this.provider.send('personal_unlockAccount', [address, password, null]);
  }

} // NOTE: method has been copied + modified from ethers.js JsonRpcProvider
// Convert an ethers.js transaction into a JSON-RPC transaction

const allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  from: true,
  auxiliary: true,
  expiration: true,
  afterNonce: true,
  delegateCall: true,
  revertOnError: true
};

const hexlifyTransaction = (transaction, allowExtra) => {
  // Check only allowed properties are given
  const allowed = shallowCopy(allowedTransactionKeys);

  if (allowExtra) {
    for (const key in allowExtra) {
      if (allowExtra[key]) {
        allowed[key] = true;
      }
    }
  }

  ethers.utils.checkProperties(transaction, allowed);
  const result = {} // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.
  ;
  ['gasLimit', 'gasPrice', 'nonce', 'value'].forEach(key => {
    if (!transaction[key]) {
      return;
    }

    const value = ethers.utils.hexValue(transaction[key]);

    if (key === 'gasLimit') {
      key = 'gas';
    }

    result[key] = value;
  });
  ['from', 'to', 'data'].forEach(key => {
    if (!transaction[key]) {
      return;
    }

    result[key] = ethers.utils.hexlify(transaction[key]);
  });
  const auxiliary = transaction['auxiliary'];

  if (auxiliary && auxiliary.length > 0) {
    result['auxiliary'] = [];
    auxiliary.forEach(a => {
      result['auxiliary'].push(hexlifyTransaction(a));
    });
  }

  return result;
};

const eip191prefix = ethers.utils.toUtf8Bytes('\x19Ethereum Signed Message:\n');
const messageToBytes = message => {
  if (ethers.utils.isBytes(message) || ethers.utils.isHexString(message)) {
    return ethers.utils.arrayify(message);
  }

  return ethers.utils.toUtf8Bytes(message);
};
const prefixEIP191Message = message => {
  const messageBytes = messageToBytes(message);
  return ethers.utils.concat([eip191prefix, ethers.utils.toUtf8Bytes(String(messageBytes.length)), messageBytes]);
};
const isValidSignature = async (address, digest, sig, provider, chainId, walletContext) => {
  if (!chainId) {
    var _await$provider$getNe;

    chainId = (_await$provider$getNe = await provider.getNetwork()) == null ? void 0 : _await$provider$getNe.chainId;
  }

  if (!walletContext && Web3Provider.isSequenceProvider(provider)) {
    walletContext = await provider.getSigner().getWalletContext();
  }

  return isValidSignature$1(address, digest, sig, provider, walletContext, chainId);
};
const isValidMessageSignature = async (address, message, signature, provider, chainId, walletContext) => {
  const prefixed = prefixEIP191Message(message);
  const digest = encodeMessageDigest(prefixed);
  return isValidSignature(address, digest, signature, provider, chainId, walletContext);
};
const isValidTypedDataSignature = (address, typedData, signature, provider, chainId, walletContext) => {
  return isValidSignature(address, encodeTypedDataDigest(typedData), signature, provider, chainId, walletContext);
};
const recoverWalletConfig = async (address, digest, signature, chainId, walletContext) => {
  const subDigest = packMessageData(address, chainId, digest);
  const config = await recoverConfig(subDigest, signature);

  if (walletContext) {
    const recoveredWalletAddress = addressOf(config, walletContext);

    if (config.address && config.address !== recoveredWalletAddress) {
      throw new Error('recovered address does not match the WalletConfig address, check the WalletContext');
    } else {
      config.address = recoveredWalletAddress;
    }
  }

  return config;
};
const isBrowserExtension = () => window.location.protocol === 'chrome-extension:' || window.location.protocol === 'moz-extension:';
/**
 * Returns the status of a signer's wallet on given chain by checking wallet deployment and config status
 *
 * @param {Signer} signer
 * @param {number} chainId
 * @return {Promise<boolean>} Promise that returns true if the wallet is up to date, false otherwise
 */

const isWalletUpToDate = async (signer, chainId) => {
  var _walletState$find;

  const walletState = await signer.getWalletState();
  const networks = await signer.getNetworks();
  const walletStateForRequiredChain = walletState.find(state => state.chainId === chainId);

  if (!walletStateForRequiredChain) {
    throw new Error(`WalletRequestHandler: could not find wallet state for chainId ${chainId}`);
  }

  const isDeployed = walletStateForRequiredChain.deployed;

  if (!networks) {
    throw new Error(`isWalletUpToDate util: could not get networks from signer`);
  }

  const authChain = networks.find(network => network.isAuthChain);

  if (!authChain) {
    throw new Error(`isWalletUpToDate util: could not get auth chain network information`);
  }

  const authChainId = authChain.chainId;
  const authChainConfig = (_walletState$find = walletState.find(state => state.chainId === authChainId)) == null ? void 0 : _walletState$find.config;

  if (!authChainConfig) {
    throw new Error(`isWalletUpToDate util: could not get auth chain config`);
  }

  const requiredChainConfig = walletStateForRequiredChain.config;

  if (!requiredChainConfig) {
    throw new Error(`isWalletUpToDate util: could not get config for chainId ${chainId}`);
  }

  const isUpToDate = isConfigEqual(authChainConfig, requiredChainConfig);
  return isDeployed && isUpToDate;
};
class LocalStorage {
  constructor() {}

  static getInstance() {
    if (!LocalStorage._instance) {
      LocalStorage._instance = {
        getItem: key => Promise.resolve(window.localStorage.getItem(key)),
        setItem: (key, value) => Promise.resolve(window.localStorage.setItem(key, value)),
        removeItem: key => Promise.resolve(window.localStorage.removeItem(key))
      };
    }

    return this._instance;
  }

  static use(instance) {
    LocalStorage._instance = instance;
  }

} // window.localstorage helper

LocalStorage._instance = void 0;
class LocalStore {
  constructor(key, def) {
    this.def = def;
    this.key = void 0;
    this.key = key;
  }

  async get() {
    const val = await LocalStorage.getInstance().getItem(this.key);

    if (val === null) {
      return this.def;
    }

    try {
      return JSON.parse(val);
    } catch (err) {
      console.error(err);
    }

    return;
  }

  set(val) {
    val ? LocalStorage.getInstance().setItem(this.key, JSON.stringify(val)) : LocalStorage.getInstance().removeItem(this.key);
  }

  del() {
    LocalStorage.getInstance().removeItem(this.key);
  }

}

const TRANSPORT_SESSION_LS_KEY = '@sequence.transportSession';
class BaseWalletTransport {
  // appOrigin identifies the dapp's origin which opened the app. A transport
  // will auto-detect and set this value if it can. This is determined
  // as the parent app/window which opened the wallet.
  constructor(walletRequestHandler) {
    var _this = this;

    this.walletRequestHandler = void 0;
    this._sessionId = void 0;
    this._registered = void 0;
    this._init = void 0;
    this._initNonce = void 0;
    this._initCallback = void 0;
    this.appOrigin = void 0;

    this.sendAsync = async function (request, callback, chainId) {
      throw new Error('abstract method');
    };

    this.handleMessage = async function (message) {
      const request = message; // ensure initial handshake is complete before accepting
      // other kinds of messages.

      if (_this._init !== InitState.OK) {
        if (request.type === EventType.INIT) {
          if (_this.isValidInitAck(message)) {
            // successful init
            if (_this._initCallback) _this._initCallback();
          } else {
            // failed init
            if (_this._initCallback) _this._initCallback('invalid init');
            return;
          }
        }

        return;
      } // ensure signer is ready to handle requests
      // if (this.walletRequestHandler.getSigner() === undefined) {
      //   await this.walletRequestHandler.signerReady()
      // }
      // handle request


      switch (request.type) {
        case EventType.OPEN:
          {
            if (_this._init !== InitState.OK) return;
            const session = {
              sessionId: request.data.sessionId,
              intent: request.data.intent,
              networkId: request.data.networkId
            };
            await _this.open(session);
            return;
          }

        case EventType.CLOSE:
          {
            if (_this._init !== InitState.OK) return; // noop. just here to capture the message so event emitters may be notified

            return;
          }

        case EventType.MESSAGE:
          {
            const response = await _this.walletRequestHandler.sendMessageRequest(request);

            _this.sendMessage(response);

            if (response.data.error) ;

            return;
          }

        default:
          {
            logger.error(`unexpected payload type ${request.type}`);
          }
      }
    };

    this.sendMessageRequest = async function (message) {
      return _this.walletRequestHandler.sendMessageRequest(message);
    };

    this.open = async function ({
      sessionId,
      intent,
      networkId
    }) {
      if (sessionId) {
        _this._sessionId = sanitizeNumberString(sessionId); // persist transport session in localstorage for restoring after redirect/reload

        _this.saveTransportSession({
          sessionId,
          intent,
          networkId
        });
      }

      _this.walletRequestHandler.setOpenIntent(intent); // init handshake for certain transports, before we can open the communication.
      //
      // for example, with the window-transport, we have to exchange messages to determine the
      // origin host of the dapp.


      await _this.init(); // Prepare connect options from intent

      if (intent && intent.type === 'connect' && intent.options) {
        const connectOptions = intent.options;
        const authorizeOptions = connectOptions; // overlapping types
        // Sanity/integrity check the intent payload, and set authorization origin
        // if its been determined as part of the init handshake from earlier.

        if (_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {
          if (!isBrowserExtension()) {
            if (authorizeOptions.origin !== _this.appOrigin) {
              throw new Error('origin is invalid');
            }
          }
        } else if (!_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {
          // ie. when we can't determine the origin in our transport, but dapp provides it to us.
          // we just sanitize the origin host.
          connectOptions.origin = sanitizeHost(authorizeOptions.origin);
        } else if (_this.appOrigin) {
          // ie. when we auto-determine the origin such as in window-transport
          connectOptions.origin = _this.appOrigin;
        }

        if (connectOptions.app) {
          connectOptions.app = sanitizeAlphanumeric(connectOptions.app);
        } // Set connect options on the walletRequestHandler as our primary
        // wallet controller


        _this.walletRequestHandler.setConnectOptions(connectOptions);

        if (connectOptions.networkId) {
          networkId = connectOptions.networkId;
        }
      } else {
        _this.walletRequestHandler.setConnectOptions(undefined);
      } // ensure signer is ready


      await _this.walletRequestHandler.getSigner(); // Notify open and proceed to prompt for connection if intended

      if (!(await _this.walletRequestHandler.isSignedIn())) {
        // open wallet without a specific connected chainId, as the user is not signed in
        _this.notifyOpen({
          sessionId: _this._sessionId
        });

        return true;
      } else {
        // Set default network, in case of error chainId will be undefined or 0
        let chainId = undefined;

        try {
          if (networkId) {
            chainId = await _this.walletRequestHandler.setDefaultNetwork(networkId, false);
          } else {
            chainId = await _this.walletRequestHandler.getChainId();
          }
        } catch (err) {
          console.error(err);
        } // Failed to set default network on open -- quit + close


        if (!chainId || chainId <= 0) {
          _this.notifyOpen({
            sessionId: _this._sessionId,
            error: `failed to open wallet on network ${networkId}`
          });

          return false;
        } // prompt user with a connect request. the options will be used as previously set above.
        // upon success, the walletRequestHandler will notify the dapp with the ConnectDetails.
        // upon cancellation by user, the walletRequestHandler will throw an error


        if (intent && intent.type === 'connect') {
          // notify wallet is opened, without session details
          _this.notifyOpen({
            sessionId: _this._sessionId
          });

          try {
            const connectDetails = await _this.walletRequestHandler.promptConnect(intent.options);

            if (connectDetails.connected) {
              _this.walletRequestHandler.notifyConnect(connectDetails);
            }
          } catch (err) {
            logger.warn('promptConnect not connected:', err);
          } finally {
            // auto-close by default, unless intent is to keep open
            if (!intent.options || intent.options.keepWalletOpened !== true) {
              _this.notifyClose();
            }
          }
        } else {
          // user is already connected, notify session details.
          // TODO: in future, keep list if 'connected' dapps / sessions in the session
          // controller, and only sync with allowed apps
          _this.notifyOpen({
            sessionId: _this._sessionId,
            chainId: `${chainId}`,
            session: await _this.walletRequestHandler.walletSession()
          });
        }
      }

      return true;
    };

    this.saveTransportSession = session => {
      LocalStorage.getInstance().setItem(TRANSPORT_SESSION_LS_KEY, JSON.stringify(session));
    };

    this.getCachedTransportSession = async function () {
      const session = await LocalStorage.getInstance().getItem(TRANSPORT_SESSION_LS_KEY);

      try {
        return session ? JSON.parse(session) : null;
      } catch (err) {
        console.error(`unable to parse transport session: ${session}`);
        return null;
      }
    };

    this.walletRequestHandler = walletRequestHandler;
    this._init = InitState.NIL;
    this.walletRequestHandler.on('connect', connectDetails => {
      if (!this.registered) return; // means user has logged in and wallet is connected to the app

      this.notifyConnect(connectDetails);
    });
    this.walletRequestHandler.on('disconnect', error => {
      if (!this.registered) return; // means user has logged out the app / disconnected wallet from the app

      this.notifyDisconnect(error);
    });
    this.walletRequestHandler.on('accountsChanged', (accounts, origin) => {
      if (!this.registered) return;
      this.notifyAccountsChanged(accounts, origin);
    });
    this.walletRequestHandler.on('networks', networks => {
      if (!this.registered) return;
      this.notifyNetworks(networks);

      if (!networks || networks.length === 0) {
        this.notifyChainChanged('0x0');
      } else {
        this.notifyChainChanged(ethers.utils.hexlify(networks.find(network => network.isDefaultChain).chainId));
      }
    });
    this.walletRequestHandler.on('walletContext', walletContext => {
      if (!this.registered || !walletContext) return;
      this.notifyWalletContext(walletContext);
    });
    this.walletRequestHandler.on('close', error => {
      if (!this.registered) return;
      this.notifyClose(error);
    });
  }

  get registered() {
    return this._registered;
  }

  register() {
    throw new Error('abstract method');
  }

  unregister() {
    throw new Error('abstract method');
  }

  sendMessage(message) {
    throw new Error('abstract method');
  }

  notifyOpen(openInfo) {
    const {
      chainId,
      sessionId,
      session,
      error
    } = openInfo;
    this.sendMessage({
      idx: -1,
      type: EventType.OPEN,
      data: {
        chainId,
        sessionId,
        session,
        error
      }
    });
  }

  notifyClose(error) {
    this.sendMessage({
      idx: -1,
      type: EventType.CLOSE,
      data: error ? {
        error
      } : null
    });
  }

  notifyConnect(connectDetails) {
    this.sendMessage({
      idx: -1,
      type: EventType.CONNECT,
      data: connectDetails
    });
  }

  notifyDisconnect(error) {
    this.sendMessage({
      idx: -1,
      type: EventType.DISCONNECT,
      data: error ? {
        error
      } : null
    });
  }

  notifyAccountsChanged(accounts, origin) {
    this.sendMessage({
      idx: -1,
      type: EventType.ACCOUNTS_CHANGED,
      data: accounts,
      origin: origin
    });
  }

  notifyChainChanged(chainIdHex) {
    this.sendMessage({
      idx: -1,
      type: EventType.CHAIN_CHANGED,
      data: chainIdHex
    });
  }

  notifyNetworks(networks) {
    this.sendMessage({
      idx: -1,
      type: EventType.NETWORKS,
      data: networks
    });
  }

  notifyWalletContext(walletContext) {
    this.sendMessage({
      idx: -1,
      type: EventType.WALLET_CONTEXT,
      data: walletContext
    });
  }

  isValidInitAck(message) {
    if (this._init === InitState.OK) {
      // we're already in init state, we shouldn't handle this message
      logger.warn("isValidInitAck, already in init'd state, so inquiry is invalid.");
      return false;
    }

    if (message.type !== EventType.INIT) {
      logger.warn('isValidInitAck, invalid message type, expecting init');
      return false;
    }

    const {
      sessionId,
      nonce
    } = message.data;

    if (!sessionId || sessionId.length === 0 || !nonce || nonce.length === 0) {
      logger.error('invalid init ack');
      return false;
    }

    if (sessionId !== this._sessionId || nonce !== this._initNonce) {
      logger.error('invalid init ack match');
      return false;
    } // all checks pass, its true


    return true;
  }

  init() {
    return new Promise((resolve, reject) => {
      // avoid re-init`ing, or if there is a transport which doesn't require
      // it, then it may set this._init to OK in its constructor.
      if (this._init === InitState.OK) {
        resolve();
        return;
      }

      if (this._init !== InitState.NIL || this._initCallback) {
        reject('transport init is in progress');
        return;
      } // start init timeout, if we don't receive confirmation
      // from provider within this amount of time, then we timeout


      const initTimeout = setTimeout(() => {
        logger.warn('transport init timed out');

        if (this._initCallback) {
          this._initCallback('transport init timed out');
        }
      }, PROVIDER_OPEN_TIMEOUT / 2); // setup callback as we receive the init message async in the handleMessage function

      this._initCallback = error => {
        this._initCallback = undefined; // reset

        clearTimeout(initTimeout);

        if (error) {
          reject(error);
        } else {
          this._init = InitState.OK;
          resolve();
        }
      }; // send init request with random nonce to the provider, where we expect
      // for the provider to echo it back to us as complete handshake


      this._initNonce = `${performance.now()}`;
      this.sendMessage({
        idx: -1,
        type: EventType.INIT,
        data: {
          nonce: this._initNonce
        }
      });
      this._init = InitState.SENT_NONCE; // NOTE: the promise will resolve in the _initCallback method
      // which will be called from either handleMessage or the initTimeout
    });
  }

}

class ProxyMessageChannel {
  constructor() {
    this.app = void 0;
    this.wallet = void 0;
    const port1 = new ProxyMessageChannelPort();
    const port2 = new ProxyMessageChannelPort();
    port1.conn = port2;
    port2.conn = port1;
    this.app = port1;
    this.wallet = port2;
  }

}
class ProxyMessageChannelPort {
  constructor() {
    this.conn = void 0;
    this.events = new EventEmitter2();

    this.handleMessage = message => {
      throw new Error('ProxyMessageChannelPort is not registered');
    };

    this.sendMessage = message => {
      this.conn.handleMessage(message); // trigger events

      if (message.type === 'open') {
        this.events.emit('open', message);
      }

      if (message.type === 'close') {
        this.events.emit('close', message);
      }

      if (message.type === 'connect') {
        this.events.emit('connect', message);
      }

      if (message.type === 'disconnect') {
        this.events.emit('disconnect', message);
      }
    };
  }

  on(event, fn) {
    this.events.on(event, fn);
  }

  once(event, fn) {
    this.events.once(event, fn);
  }

}

class ProxyMessageProvider extends BaseProviderTransport {
  constructor(port) {
    super();
    this.port = void 0;

    this.register = () => {
      this.port.handleMessage = message => {
        this.handleMessage(message);
      };

      this.on('open', (...args) => {
        this.port.events.emit('open', ...args);
      });
      this.on('close', (...args) => {
        this.port.events.emit('close', ...args);
      });
      this.on('connect', (...args) => {
        this.port.events.emit('connect', ...args);
      });
      this.on('disconnect', (...args) => {
        this.port.events.emit('disconnect', ...args);
      });
      this._registered = true;
    };

    this.unregister = () => {
      this._registered = false;
      this.closeWallet();
      this.events.removeAllListeners(); // @ts-ignore

      this.port.handleMessage = undefined;
    };

    this.openWallet = (path, intent, networkId) => {
      if (this.state === OpenState.CLOSED) {
        this.state = OpenState.OPENING;
        const sessionId = `${performance.now()}`;
        this._sessionId = sessionId;
        this.sendMessage({
          idx: -1,
          type: EventType.OPEN,
          data: {
            path,
            intent,
            networkId,
            sessionId
          }
        });
      }
    };

    this.state = OpenState.CLOSED;
    this.port = port;

    if (!port) {
      throw new Error('port argument cannot be empty');
    } // disable init handshake for proxy-transport, we set it to OK, to
    // consider it in completed state.


    this._init = InitState.OK;
  }

  closeWallet() {
    this.sendMessage({
      idx: -1,
      type: EventType.CLOSE,
      data: null
    });
    this.close();
  }

  sendMessage(message) {
    if (!message.idx) {
      throw new Error('message idx is empty');
    }

    this.port.sendMessage(message);
  }

}

class ProxyMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler, port) {
    super(walletRequestHandler);
    this.port = void 0;
    this.port = port;
    this._init = InitState.OK;
  }

  register() {
    this.port.handleMessage = message => {
      this.handleMessage(message);
    };

    this._registered = true;
  } // note: we can't decide whether to restore the session within register(), because session info is
  // received asyncronously via EventType.OPEN after register() is executed.
  // And in the case of a redirect/reload, EventType.OPEN is not sent at all,
  // because the wallet is already open.
  //
  // call this method from wallet redirect hander when a session restore is needed


  async restoreSession() {
    const cachedSession = await this.getCachedTransportSession();

    if (cachedSession) {
      this.open(cachedSession);
    }
  }

  unregister() {
    // @ts-ignore
    this.port.handleMessage = undefined;
    this._registered = false;
  }

  sendMessage(message) {
    this.port.sendMessage(message);
  }

}

class MuxMessageProvider {
  constructor(...messageProviders) {
    var _this = this;

    this.messageProviders = void 0;
    this.provider = void 0;

    this.register = () => {
      if (this.messageProviders.length === 1) {
        this.provider = this.messageProviders[0];
        this.provider.register();
        return;
      } // REVIEW/NOTE: ........ this method does not work for the chrome-extension. The issue becomes
      // when the browser quits or restarts, the "open" event is never triggered. Perhaps the code here is fine,
      // or maybe its not. What should happen is when a dapp makes a request, it will call openWallet
      // below, in which case one of the events will register. So perhaps this is fine.


      this.messageProviders.forEach(m => {
        m.register();
        m.once('open', () => {
          // the first one to open is the winner, and others will be unregistered
          if (!this.provider) {
            this.provider = m; // unregister other providers

            this.messageProviders.forEach(m => {
              if (this.provider !== m) {
                m.unregister();
              }
            });
          }
        });
      });
    };

    this.unregister = () => {
      this.messageProviders.forEach(m => m.unregister());
      this.provider = undefined;
    };

    this.openWallet = (path, intent, networkId) => {
      if (this.provider) {
        this.provider.openWallet(path, intent, networkId);
        return;
      }

      this.messageProviders.forEach(m => m.openWallet(path, intent, networkId));
    };

    this.sendAsync = async function (request, callback, chainId) {
      if (_this.provider) {
        _this.provider.sendAsync(request, callback, chainId);

        return;
      }

      throw new Error('impossible state, wallet must be opened first');
    };

    this.sendMessageRequest = async function (message) {
      if (_this.provider) {
        return _this.provider.sendMessageRequest(message);
      }

      throw new Error('impossible state, wallet must be opened first');
    };

    this.waitUntilOpened = async function () {
      if (_this.provider) {
        return _this.provider.waitUntilOpened();
      }

      return Promise.race(_this.messageProviders.map(p => p.waitUntilOpened()));
    };

    this.waitUntilConnected = async function () {
      if (_this.provider) {
        return _this.provider.waitUntilConnected();
      }

      throw new Error('impossible state, wallet must be opened first');
    };

    this.messageProviders = messageProviders;
    this.provider = undefined;
  }

  add(...messageProviders) {
    this.messageProviders.push(...messageProviders);
  }

  closeWallet() {
    if (this.provider) {
      this.provider.closeWallet();
    }
  }

  isOpened() {
    if (this.provider) {
      return this.provider.isOpened();
    }

    return false;
  }

  isConnected() {
    if (this.provider) {
      return this.provider.isConnected();
    }

    return false;
  }

  on(event, fn) {
    if (this.provider) {
      this.provider.on(event, fn);
      return;
    }

    this.messageProviders.forEach(m => {
      m.on(event, fn);
    });
  }

  once(event, fn) {
    if (this.provider) {
      this.provider.once(event, fn);
      return;
    }

    this.messageProviders.forEach(m => {
      m.once(event, fn);
    });
  }

  emit(event, ...args) {
    if (this.provider) {
      return this.provider.emit(event, ...args);
    }

    for (let i = 0; i < this.messageProviders.length; i++) {
      this.messageProviders[i].emit(event, ...args);
    }

    return true;
  }

  sendMessage(message) {
    if (!message.idx || message.idx <= 0) {
      throw new Error('message idx is empty');
    }

    if (this.provider) {
      this.provider.sendMessage(message);
    } else {
      throw new Error('impossible state, wallet must be opened first');
    }
  }

  handleMessage(message) {
    if (this.provider) {
      this.provider.handleMessage(message);
      return;
    }

    throw new Error('impossible state, wallet must be opened first');
  }

}

let registeredWindowMessageProvider;
class WindowMessageProvider extends BaseProviderTransport {
  constructor(walletAppURL) {
    super();
    this.walletURL = void 0;
    this.walletWindow = void 0;

    this.register = () => {
      if (registeredWindowMessageProvider) {
        // overriding the registered message provider
        registeredWindowMessageProvider.unregister();
        registeredWindowMessageProvider = this;
      } // listen for incoming messages from wallet


      window.addEventListener('message', this.onWindowEvent);
      registeredWindowMessageProvider = this; // open heartbeat

      this.on('open', () => {
        // Heartbeat to track if window closed
        const popup = this.walletWindow;
        const interval = setInterval(() => {
          if (popup && popup.closed) {
            clearInterval(interval);
            this.close();
          }
        }, 500);
      }); // close clean up

      this.on('close', () => {
        if (this.walletWindow) {
          this.walletWindow.close();
          this.walletWindow = null;
        }
      });
      this._registered = true;
    };

    this.unregister = () => {
      this._registered = false;
      this.closeWallet(); // disable message listener

      if (registeredWindowMessageProvider === this) {
        registeredWindowMessageProvider = undefined;
      }

      window.removeEventListener('message', this.onWindowEvent); // clear event listeners

      this.events.removeAllListeners();
    };

    this.openWallet = (path, intent, networkId) => {
      if (this.walletWindow && this.isOpened()) {
        // TODO: update the location of window to path
        this.walletWindow.focus();
        return;
      } // Instantiate new walletURL for this call


      const walletURL = new URL(this.walletURL.href);
      const windowSessionParams = new WindowSessionParams();

      if (path && path !== '') {
        walletURL.pathname = path.toLowerCase();
      } // Set session, intent and network id on walletURL


      this._init = InitState.NIL;
      this._sessionId = `${performance.now()}`;
      windowSessionParams.set('sid', this._sessionId);

      if (intent) {
        // for the window-transport, we eagerly/optimistically set the origin host
        // when connecting to the wallet, however, this will be verified and enforced
        // on the wallet-side, so if a dapp provides the wrong origin, it will be dropped.
        if (intent.type === 'connect') {
          if (!intent.options) intent.options = {}; // skip setting origin host if we're in an browser extension execution context
          // allow origin that is passed in

          if (!isBrowserExtension()) {
            intent.options.origin = window.location.origin;
          }
        } // encode intent as base64 url-encoded param


        windowSessionParams.set('intent', base64EncodeObject(intent));
      }

      if (networkId) {
        windowSessionParams.set('net', `${networkId}`);
      } // Open popup window on center of the app window


      let windowSize;
      let windowPos;

      if (isBrowserExtension()) {
        windowSize = [450, 750];
        windowPos = [Math.abs(window.screen.width / 2 - windowSize[0] / 2), Math.abs(window.screen.height / 2 - windowSize[1] / 2)];
      } else {
        windowSize = [450, 750];
        windowPos = [Math.abs(window.screenX + window.innerWidth / 2 - windowSize[0] / 2), Math.abs(window.screenY + window.innerHeight / 2 - windowSize[1] / 2)];
      }

      const windowFeatures = `toolbar=0,location=0,menubar=0,scrollbars=yes,status=yes` + `,width=${windowSize[0]},height=${windowSize[1]}` + `,left=${windowPos[0]},top=${windowPos[1]}`; // serialize params

      walletURL.search = windowSessionParams.toString();
      this.walletWindow = window.open(walletURL.href, 'sequence.app', windowFeatures); // TODO: move this somewhere else
      // TODO: perhaps we trigger a .on('openTimeout') event..? maybe.. could help.
      // Popup blocking detection and notice
      // let warned = false
      // const warnPopupBlocked = () => {
      //   if (warned) return
      //   warned = true
      //   // alert('popup is blocked! hey yo') // NOTE: for debug purposes only
      //   throw new Error('popup is blocked')
      // }
      // const popupCheck = setTimeout(() => {
      //   if (!popup || popup.closed || typeof popup.closed === 'undefined') {
      //     // popup is definitely blocked if we reach here.
      //     warnPopupBlocked()
      //   }
      // }, 1000)
      // const popupBlocked = popup === null || popup === undefined
      // if (popupBlocked) {
      //   warnPopupBlocked()
      //   return
      // }
    };

    this.onWindowEvent = event => {
      // Security check, ensure message is coming from wallet origin url
      if (event.origin !== this.walletURL.origin) {
        // Safetly can skip events not from the wallet
        return;
      }

      let message;

      try {
        message = JSON.parse(event.data);
      } catch (err) {
        // event is not a ProviderMessage JSON object, skip
        return;
      }

      if (!message) {
        throw new Error('ProviderMessage object is empty');
      } // handle message with base message provider


      this.handleMessage(message);
    };

    this.walletURL = new URL(walletAppURL);
  }

  closeWallet() {
    var _this$walletWindow;

    this.close();
    (_this$walletWindow = this.walletWindow) == null ? void 0 : _this$walletWindow.close();
  } // onmessage, receives ProviderMessageResponse from the wallet post-message transport


  sendMessage(message) {
    if (!this.walletWindow) {
      logger.warn('WindowMessageProvider: sendMessage failed as walletWindow is unavailable');
      return;
    }

    const postedMessage = typeof message !== 'string' ? JSON.stringify(message) : message;
    this.walletWindow.postMessage(postedMessage, this.walletURL.origin);
  }

}

class WindowMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler) {
    var _this;

    super(walletRequestHandler);
    _this = this;
    this.parentWindow = void 0;
    this._isPopup = false;

    this.onWindowEvent = async function (event) {
      if (!event.origin || event.origin === '') {
        // skip same-origin or when event.origin is empty/undefined
        return;
      }

      if (_this.appOrigin && event.origin !== _this.appOrigin) {
        // skip message as not from expected app origin
        return;
      } // Wallet always expects json-rpc request messages from a dapp


      let request;

      try {
        request = JSON.parse(event.data);
      } catch (err) {
        // event is not a ProviderMessage JSON object, skip
        return;
      }

      logger.debug('RECEIVED MESSAGE', request); // Record event origin for valid init ack

      if (_this._init !== InitState.OK && _this.isValidInitAck(request)) {
        _this.appOrigin = event.origin;
      }

      if (_this._init === InitState.OK && (!_this.appOrigin || _this.appOrigin.length < 8)) {
        // impossible state
        logger.error('impossible state, init.OK and appOrigin required');
        return;
      } // Handle message via the base transport


      _this.handleMessage(request);
    };

    this.getWindowTransportSession = windowParams => {
      const params = new WindowSessionParams(windowParams);
      return {
        sessionId: params.get('sid'),
        networkId: params.get('net'),
        intent: base64DecodeObject(params.get('intent'))
      };
    };

    this._init = InitState.NIL;
  }

  async register(windowHref) {
    const isPopup = parent.window.opener !== null;
    this._isPopup = isPopup;

    if (isPopup !== true) {
      return;
    } // record open details (sessionId + default network) from the window url


    const {
      pathname,
      search: rawParams
    } = new URL(windowHref || window.location.href);
    let session = this.getWindowTransportSession(rawParams); // provider should always include sid when opening a new window

    const isNewWindowSession = !!session.sessionId; // attempt to restore previous session in the case of a redirect or window reload

    if (!isNewWindowSession) {
      session = await this.getCachedTransportSession();
    }

    if (!session) {
      logger.error('window session is undefined');
      return;
    } // record parent window instance for communication


    this.parentWindow = parent.window.opener; // listen for window-transport requests

    window.addEventListener('message', this.onWindowEvent, false);
    this._registered = true; // send open event to the app which opened us

    this.open(session).then(opened => {
      if (!opened) {
        var _session;

        const err = `failed to open to network ${(_session = session) == null ? void 0 : _session.networkId}`;
        logger.error(err);
        this.notifyClose({
          message: err
        });
        window.close();
      }
    }).catch(e => {
      var _session2;

      const err = `failed to open to network ${(_session2 = session) == null ? void 0 : _session2.networkId}, due to: ${e}`;
      logger.error(err);
      this.notifyClose({
        message: err
      });
      window.close();
    });
  }

  unregister() {
    window.removeEventListener('message', this.onWindowEvent);
    this._registered = false;
  } // onmessage is called when (the wallet) receives request messages from the dapp
  // over the window post-messaging transport


  // postMessage sends message to the dapp window
  sendMessage(message) {
    // prepare payload
    const payload = JSON.stringify(message); // post-message to app.
    // only for init requests, we send to '*' origin

    if (message.type === EventType.INIT) {
      this.postMessage(payload, true);
    } else {
      this.postMessage(payload);
    }
  }

  get isPopup() {
    return this._isPopup;
  }

  postMessage(message, init = false) {
    if (init !== true && this._init !== InitState.OK) {
      logger.error('impossible state, should not be calling postMessage until inited');
      return;
    }

    if (init) {
      // init message transmission to global target -- for 'init' payloads only
      this.parentWindow.postMessage(message, '*');
    } else {
      // open message transmission
      if (this.appOrigin && this.appOrigin.length > 4) {
        // just above '.com'
        this.parentWindow.postMessage(message, this.appOrigin);
      } else {
        logger.error('unable to postMessage as parentOrigin is invalid');
      }
    }
  }

}

const CHANNEL_ID = 'sequence-extension-message-handler';
class ExtensionMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler, runtime) {
    super(walletRequestHandler);
    this.runtime = runtime;
    this.port = void 0;
    this._init = InitState.OK;
  }

  register() {
    this._registered = true;
    this.port = this.runtime.connect({
      name: CHANNEL_ID
    });
  }

  sendMessage(message) {
    logger.info('[ExtensionMessageHandler send]', message);
    this.port.postMessage(message);
  }

}

class ExtensionMessageProvider extends BaseProviderTransport {
  constructor(runtime) {
    super();

    this.register = () => {
      this._registered = true;
    };

    runtime.onConnect.addListener(port => {
      if (port.name === CHANNEL_ID) {
        this._init = InitState.OK;
        port.onMessage.addListener(message => {
          this.handleMessage(message);
        });
      }
    });
  }

  sendMessage(message) {//noop
  }

  unregister() {//noop
  }

  openWallet(path, intent, networkId) {//noop
  }

  closeWallet() {//noop
  }

}

// to be used on injected window.ethereum EIP1193 proxy
class BaseInjectedTransport extends EventEmitter2 {
  constructor(stream) {
    var _this;

    super();
    _this = this;
    this.stream = stream;
    this.responseCallbacks = new Map();
    this._messageIdx = 0;

    this.nextMessageIdx = () => ++this._messageIdx;

    this.handleMessage = message => {
      if (!message.type || !message.data) {
        return;
      }

      logger.info('[received message]', message);
      const requestIdx = message.idx;
      const responseCallback = this.responseCallbacks.get(requestIdx);

      if (requestIdx) {
        this.responseCallbacks.delete(requestIdx);
      }

      switch (message.type) {
        case EventType.MESSAGE:
          if (responseCallback) {
            this.emit(EventType.MESSAGE, message);
            responseCallback(message.data.error, message);
          } else {
            // NOTE: this would occur if 'idx' isn't set, which should never happen
            // or when we register two handler, or duplicate messages with the same idx are sent,
            // all of which should be prevented prior to getting to this point
            throw new Error('impossible state');
          }

          break;

        case EventType.DISCONNECT:
        case EventType.ACCOUNTS_CHANGED:
        case EventType.CHAIN_CHANGED:
          this.emit(message.type, message.data);
          break;

        default:
          console.error('unknown message type', message);
          break;
      }
    };

    this.sendMessageRequest = async function (message) {
      return new Promise((resolve, reject) => {
        if (!message.idx || message.idx <= 0) {
          reject(new Error('message idx not set'));
        }

        const responseCallback = (error, response) => {
          if (error) {
            reject(error);
          } else if (response) {
            resolve(response);
          } else {
            throw new Error('no valid response to return');
          }
        };

        const {
          idx
        } = message;

        if (!_this.responseCallbacks.get(idx)) {
          _this.responseCallbacks.set(idx, responseCallback);
        } else {
          reject(new Error('duplicate message idx, should never happen'));
        }

        _this.sendMessage(message);
      });
    };

    this.stream.on('data', this.handleMessage);
  }

  sendMessage(message) {
    if (!this.stream.writable) {
      console.error('window post message stream is not writable');
    }

    this.stream.write(message);
  }

}

class WalletUtils {
  constructor(walletProvider) {
    var _this = this;

    this.wallet = void 0;

    this.recoverWalletConfig = async function (address, digest, signature, chainId, walletContext) {
      walletContext = walletContext || (await _this.wallet.getWalletContext());
      return recoverWalletConfig(address, digest, signature, chainId, walletContext);
    };

    this.recoverWalletConfigFromMessage = async function (address, message, signature, chainId, walletContext) {
      walletContext = walletContext || (await _this.wallet.getWalletContext());
      return recoverWalletConfig(address, encodeMessageDigest(prefixEIP191Message(message)), signature, chainId, walletContext);
    };

    this.recoverWalletConfigFromTypedData = async function (address, typedData, signature, chainId, walletContext) {
      walletContext = walletContext || (await _this.wallet.getWalletContext());
      return recoverWalletConfig(address, encodeTypedDataDigest(typedData), signature, chainId, walletContext);
    };

    this.wallet = walletProvider;
  } // Sign message on a specified chain, or DefaultChain by default


  signMessage(message, chainId, allSigners) {
    const signer = this.wallet.getSigner();
    if (!signer) throw new Error('unable to get signer');
    return signer.signMessage(message, chainId, allSigners);
  } // Sign message on the AuthChain


  async signAuthMessage(message, allSigners) {
    const signer = await this.wallet.getAuthSigner();
    if (!signer) throw new Error('unable to get AuthChain signer');
    return signer.signMessage(message, await signer.getChainId(), allSigners);
  } // Sign EIP-712 TypedData on a specified chain, or DefaultChain by default


  signTypedData(domain, types, message, chainId, allSigners) {
    const signer = this.wallet.getSigner();
    if (!signer) throw new Error('unable to get signer');
    return signer.signTypedData(domain, types, message, chainId, allSigners);
  } // Sign EIP-712 TypedData on the AuthChain


  async signAuthTypedData(domain, types, message, allSigners) {
    const signer = await this.wallet.getAuthSigner();
    if (!signer) throw new Error('unable to get AuthChain signer');
    return signer.signTypedData(domain, types, message, await signer.getChainId(), allSigners);
  } // Verify signature of a digest, one of a message, typedData or other


  async isValidSignature(address, digest, signature, chainId, walletContext) {
    const provider = this.wallet.getProvider(chainId);
    if (!provider) throw new Error(`unable to get provider for chainId ${chainId}`);
    return isValidSignature(address, digest, signature, provider, chainId, walletContext);
  } // Verify message signature


  async isValidMessageSignature(address, message, signature, chainId, walletContext) {
    const provider = this.wallet.getProvider(chainId);
    if (!provider) throw new Error(`unable to get provider for chainId ${chainId}`);
    const prefixed = prefixEIP191Message(message);
    const digest = encodeMessageDigest(prefixed);
    return isValidSignature(address, digest, signature, provider, chainId, walletContext);
  } // Verify typedData signature


  isValidTypedDataSignature(address, typedData, signature, chainId, walletContext) {
    return this.isValidSignature(address, encodeTypedDataDigest(typedData), signature, chainId, walletContext);
  } // Recover the WalletConfig from a signature + digest combo
  // sendTransaction()
  // sendTransactions()
  // sendETH()
  // sendToken()
  // sendCoin() -- sugar for sendToken()
  // sendCollectible() -- sugar for sendToken()
  // callContract()
  // transactionHistory()
  // getReceipt()
  // getLogs()
  // // ..
  // isWalletDeployed()
  // deployWallet()
  // validateSignature()
  // recoverWalletConfig()
  // recoverAddress()


}

class Wallet {
  constructor(_network, config) {
    var _this = this;

    this.utils = void 0;
    this.config = void 0;
    this.session = void 0;
    this.connectedSites = void 0;
    this.transport = void 0;
    this.networks = void 0;
    this.providers = void 0;

    this.init = () => {
      var _this$config$transpor, _this$config$transpor2, _this$config$transpor3, _this$config$transpor4, _this$config$transpor5, _this$config$transpor6;

      if (this.transport.provider) {
        // init must have already been called
        return;
      } // Setup provider


      this.transport.messageProvider = new MuxMessageProvider(); // multiple message provider setup, first one to connect will be the main transport

      if ((_this$config$transpor = this.config.transports) != null && (_this$config$transpor2 = _this$config$transpor.windowTransport) != null && _this$config$transpor2.enabled) {
        this.transport.windowMessageProvider = new WindowMessageProvider(this.config.walletAppURL);
        this.transport.messageProvider.add(this.transport.windowMessageProvider);
      }

      if ((_this$config$transpor3 = this.config.transports) != null && (_this$config$transpor4 = _this$config$transpor3.proxyTransport) != null && _this$config$transpor4.enabled) {
        this.transport.proxyMessageProvider = new ProxyMessageProvider(this.config.transports.proxyTransport.appPort);
        this.transport.messageProvider.add(this.transport.proxyMessageProvider);
      }

      if ((_this$config$transpor5 = this.config.transports) != null && (_this$config$transpor6 = _this$config$transpor5.extensionTransport) != null && _this$config$transpor6.enabled) {
        this.transport.extensionMessageProvider = new ExtensionMessageProvider(this.config.transports.extensionTransport.runtime); // this.transport.extensionMessageProvider.register()

        this.transport.messageProvider.add(this.transport.extensionMessageProvider); // NOTE/REVIEW: see note in mux-message-provider
        //
        // We don't add the extensionMessageProvider here because we don't send requests to it anyways, we seem to
        // send all requests to the WindowMessageProvider anyways. By allowing it, if browser restarts, it will break
        // the entire extension because messageProvider.provider will be undefined. So this is a hack to fix it.
        //
        // this.transport.messageProvider.add(this.transport.extensionMessageProvider)
      }

      this.transport.messageProvider.register(); // .....

      this.transport.allowProvider = allowProviderMiddleware(request => {
        if (request.method === 'sequence_setDefaultNetwork') return true;
        const isConnected = this.isConnected();

        if (!isConnected) {
          throw new Error('Sequence: wallet not connected');
        }

        return isConnected;
      }); // ...

      this.transport.networkProvider = networkProviderMiddleware(request => {
        // return stub chainId of 0 when not connected to any
        if (!this.networks || this.networks.length === 0) return 0; // return the default chainId as we're connected

        return this.networks.find(network => network.isDefaultChain).chainId;
      }); // Provider proxy to support middleware stack of logging, caching and read-only rpc calls

      this.transport.cachedProvider = new CachedProvider();
      this.transport.cachedProvider.onUpdate(() => {
        if (!this.session) this.session = {
          providerCache: {}
        };
        this.session.providerCache = this.transport.cachedProvider.getCache();
        this.saveSession(this.session);
      }); // ..

      this.transport.router = new JsonRpcRouter([loggingProviderMiddleware, this.transport.networkProvider, this.transport.allowProvider, exceptionProviderMiddleware, this.transport.cachedProvider], this.transport.messageProvider);
      this.transport.provider = new Web3Provider(this.transport.router); // NOTE: we don't listen on 'connect' even here as we handle it within connect() method
      // in more synchronous flow.
      // below will update the wallet session object and persist it. In case the session
      // is undefined, we consider the session to have been removed by the user, so we clear it.

      this.transport.messageProvider.on('open', openInfo => {
        const {
          session
        } = openInfo;

        if (!session) {
          if (this.session && this.session.accountAddress) {
            // emit disconnect even if previously we had a session, and now we don't.
            this.transport.messageProvider.emit('disconnect');
          }

          this.clearSession();
        } else {
          this.useSession(session, true);
        }
      }); // below will update the account upon wallet connect/disconnect - aka, login/logout.
      // if an origin is provided, this operation should be performed only on that origin
      // and shouldn't affect the session of the wallet.

      this.transport.messageProvider.on('accountsChanged', (accounts, origin) => {
        if (origin) {
          if (accounts.length > 0) {
            this.useSession({
              accountAddress: accounts[0]
            }, true);
          }

          return;
        }

        if (!accounts || accounts.length === 0 || accounts[0] === '') {
          this.clearSession();
        } else {
          this.useSession({
            accountAddress: accounts[0]
          }, true);
        }
      }); // below will update the networks automatically when the wallet networks change

      this.transport.messageProvider.on('networks', networks => {
        this.useSession({
          networks: networks
        }, true);
      }); // below will update the wallet context automatically

      this.transport.messageProvider.on('walletContext', walletContext => {
        this.useSession({
          walletContext: walletContext
        }, true);
      });
    };

    this.loadSession = async function () {
      const data = await LocalStorage.getInstance().getItem('@sequence.session');

      if (!data || data === '') {
        return undefined;
      }

      try {
        const session = JSON.parse(data);

        if (session) {
          _this.useSession(session, false);
        }

        return session;
      } catch (err) {
        logger.warn('loadSession failed, unable to parse session payload from storage.');
        return undefined;
      }
    };

    this.connect = async function (options) {
      if ((options == null ? void 0 : options.refresh) === true) {
        _this.disconnect();
      }

      if (_this.isConnected() && (await _this.isSiteConnected(options == null ? void 0 : options.origin)) && !!_this.session && !(options != null && options.authorize) && !(options != null && options.askForEmail)) {
        return {
          connected: true,
          session: _this.session,
          chainId: ethers.utils.hexlify(await _this.getChainId())
        };
      }

      if (options) {
        if (options.authorize && (!options.app || options.app === '')) {
          throw new Error(`connecting with 'authorize' option also requires 'app' to be set`);
        }
      }

      await _this.openWallet(undefined, {
        type: 'connect',
        options
      });
      const connectDetails = await _this.transport.messageProvider.waitUntilConnected().catch(_ => {
        return {
          connected: false
        };
      });

      if (connectDetails.connected) {
        if (!!connectDetails.session) {
          _this.useSession(connectDetails.session, true);

          _this.addConnectedSite(options == null ? void 0 : options.origin);
        } else {
          throw new Error('impossible state, connect response is missing session');
        }
      }

      return connectDetails;
    };

    this.authorize = async function (options) {
      return _this.connect(_extends({}, options, {
        authorize: true
      }));
    };

    this.getSession = () => {
      if (!this.isConnected()) {
        return undefined;
      }

      return this.session;
    };

    this.getAddress = async function () {
      if (!_this.isConnected()) {
        throw new Error('connect first');
      }

      const session = _this.getSession();

      return session.accountAddress;
    };

    this.getNetworks = async function (chainId) {
      if (!_this.isConnected() || !_this.networks) {
        throw new Error('connect first');
      }

      if (chainId) {
        // filter list to just the specific chain requested
        const network = findNetworkConfig(_this.networks, chainId);
        return network ? [network] : [];
      }

      return _this.networks;
    };

    this.getChainId = async function () {
      if (!_this.networks || _this.networks.length < 1) {
        throw new Error('networks have not been set by session. connect first.');
      }

      const network = _this.networks.find(network => network.isDefaultChain);

      if (!network) {
        throw new Error('networks must have a default chain specified');
      }

      return network.chainId;
    };

    this.getAuthChainId = async function () {
      if (!_this.networks || _this.networks.length < 1) {
        throw new Error('networks have not been set by session. connect first.');
      }

      const network = _this.networks.find(network => network.isAuthChain);

      if (!network) {
        throw new Error('networks must have an auth chain specified');
      }

      return network.chainId;
    };

    this.openWallet = async function (path, intent, networkId) {
      if ((intent == null ? void 0 : intent.type) !== 'connect' && !_this.isConnected()) {
        throw new Error('connect first');
      }

      let currentNetworkId;

      if (!_this.networks || _this.networks.length < 1) {
        currentNetworkId = _this.config.defaultNetworkId;
      } else {
        currentNetworkId = await _this.getChainId();
      }

      _this.transport.messageProvider.openWallet(path, intent, networkId || currentNetworkId);

      await _this.transport.messageProvider.waitUntilOpened();
      return true;
    };

    this.closeWallet = () => {
      this.transport.messageProvider.closeWallet();
    };

    this.saveSession = async function (session) {
      logger.debug('wallet provider: saving session');
      const data = JSON.stringify(session);
      await LocalStorage.getInstance().setItem('@sequence.session', data);
    };

    this.useSession = async function (session, autoSave = true) {
      if (!_this.session) _this.session = {}; // setup wallet context

      if (_this.config.walletContext) {
        _this.session.walletContext = _this.config.walletContext;
      } else if (session.walletContext) {
        _this.session.walletContext = session.walletContext;
      } // setup account


      if (session.accountAddress) {
        _this.useAccountAddress(session.accountAddress);
      } // setup networks


      if (session.networks) {
        _this.useNetworks(session.networks);
      } // setup provider cache


      if (session.providerCache) {
        _this.transport.cachedProvider.setCache(session.providerCache);
      } // persist


      if (autoSave) {
        _this.saveSession(_this.session);
      }
    };

    // config is a Partial, so that we may intersect it with the DefaultProviderConfig,
    // which allows easy overriding and control of the config.
    this.config = _extends({}, DefaultProviderConfig);

    if (config) {
      this.config = _extends({}, this.config, config);
    }

    if (_network) {
      this.config.defaultNetworkId = _network;
    } else if (!this.config.defaultNetworkId) {
      this.config.defaultNetworkId = 'mainnet';
    }

    if (config != null && config.localStorage) {
      LocalStorage.use(config.localStorage);
    }

    this.transport = {};
    this.networks = [];
    this.providers = {};
    this.connectedSites = new LocalStore('@sequence.connectedSites', []);
    this.utils = new WalletUtils(this);
    this.init();
  }

  async addConnectedSite(origin) {
    origin = origin || window.location.origin;
    const connectedSites = await this.connectedSites.get();

    if (connectedSites) {
      if (connectedSites.includes(origin)) {
        return;
      }

      this.connectedSites.set([...connectedSites, origin]);
    } else {
      this.connectedSites.set([origin]);
    }
  }

  async removeConnectedSite(origin) {
    const authorized = await this.connectedSites.get();

    if (authorized) {
      this.connectedSites.set(authorized.filter(domain => domain !== origin));
    }
  }

  getConnectedSites() {
    return this.connectedSites.get();
  }

  async isSiteConnected(origin) {
    const authorized = await this.connectedSites.get();
    return !!authorized && authorized.includes(origin || window.location.origin);
  }

  disconnect() {
    if (this.isOpened()) {
      this.closeWallet();
    }

    this.clearSession();
  } // TODO: add switchNetwork(network: string | number) which will call wallet_switchEthereumChain
  // and on successful response, will update the provider info here, etc.


  getProviderConfig() {
    return this.config;
  }

  isOpened() {
    return this.transport.messageProvider.isOpened();
  }

  isConnected() {
    return this.session !== undefined && this.session.networks !== undefined && this.session.networks.length > 0 && this.networks !== undefined && this.networks.length > 0 && !!this.session.accountAddress && this.session.accountAddress.startsWith('0x');
  }

  getProvider(chainId) {
    // return the top-level provider message transport when chainId is unspecified
    // and user has not logged in
    if (!this.isConnected()) {
      if (chainId) {
        throw new Error(`session is empty. connect and try again.`);
      } else {
        return this.transport.provider;
      }
    }

    let network = this.networks.find(network => network.isDefaultChain);

    if (chainId) {
      network = findNetworkConfig(this.networks, chainId);

      if (!network) {
        throw new Error(`network ${chainId} is not in the network list`);
      }
    } // return memoized network provider


    if (this.providers[network.chainId]) {
      return this.providers[network.chainId];
    } // builder web3 provider stack


    let provider; // network.provider may be set by the ProviderConfig override

    const rpcProvider = network.provider ? network.provider : new JsonRpcProvider(network.rpcUrl, network.chainId);

    if (network.isDefaultChain) {
      // communicating with defaultChain will prioritize the wallet message transport
      const router = new JsonRpcRouter([loggingProviderMiddleware, exceptionProviderMiddleware, new EagerProvider({
        accountAddress: this.session.accountAddress,
        walletContext: this.session.walletContext
      }), new SigningProvider(this.transport.provider), this.transport.cachedProvider], new JsonRpcSender(rpcProvider));
      provider = new Web3Provider(router, network.chainId);
    } else {
      // communicating with another chain will bind to that network, but will forward
      // any signing-related requests to the wallet message transport
      const router = new JsonRpcRouter([loggingProviderMiddleware, exceptionProviderMiddleware, new EagerProvider({
        accountAddress: this.session.accountAddress,
        walletContext: this.session.walletContext,
        chainId: network.chainId
      }), new SigningProvider(this.transport.provider), new CachedProvider(network.chainId)], new JsonRpcSender(rpcProvider));
      provider = new Web3Provider(router, network.chainId);
    }

    this.providers[network.chainId] = provider;
    return provider;
  }

  async getAuthProvider() {
    return this.getProvider((await this.getAuthNetwork()).chainId);
  }

  async getAuthNetwork() {
    return (await this.getNetworks()).find(n => n.isAuthChain);
  }

  getAllProviders() {
    return this.providers;
  }

  getSigner(chainId) {
    return this.getProvider(chainId).getSigner();
  }

  async getAuthSigner() {
    return (await this.getAuthProvider()).getSigner();
  }

  getWalletConfig(chainId) {
    return this.getSigner().getWalletConfig(chainId);
  }

  getWalletState(chainId) {
    return this.getSigner().getWalletState(chainId);
  }

  getWalletContext() {
    return this.getSigner().getWalletContext();
  }

  isDeployed(chainId) {
    return this.getSigner(chainId).isDeployed();
  }

  on(event, fn) {
    this.transport.messageProvider.on(event, fn);
  }

  once(event, fn) {
    this.transport.messageProvider.once(event, fn);
  }

  useAccountAddress(accountAddress) {
    if (!this.session) this.session = {};
    this.session.accountAddress = ethers.utils.getAddress(accountAddress);
  }

  useNetworks(networks) {
    // set networks in the session
    if (!this.session) this.session = {}; // set networks on session object

    this.session.networks = networks; // short-circuit if setting empty network list (aka logged out state)

    if (!this.session.networks || this.session.networks.length === 0) {
      return;
    } // check if any custom network settings, otherwise return early


    if (!this.config.networks && !this.config.networkRpcUrl) {
      this.networks = networks;
      return;
    } // init networks


    this.networks = networks; // combine custom network config with networks in the session

    if (this.config.networks) {
      this.networks = networks.map(n => _extends({}, n)); // copy

      this.config.networks.forEach(n => {
        const network = findNetworkConfig(this.networks, n.chainId || n.name);
        if (!network) return;
        updateNetworkConfig(n, network);
      });
      ensureValidNetworks(this.networks, true);
    } // an extra override for convenience


    if (this.config.networkRpcUrl) {
      const network = this.networks.find(network => network.isDefaultChain);

      if (network) {
        network.rpcUrl = this.config.networkRpcUrl;
      }
    }
  }

  clearSession() {
    var _this$transport$cache;

    logger.debug('wallet provider: clearing session');
    LocalStorage.getInstance().removeItem('@sequence.session');
    this.session = undefined;
    this.networks = [];
    this.providers = {};
    (_this$transport$cache = this.transport.cachedProvider) == null ? void 0 : _this$transport$cache.clearCache();
  }

}
const DefaultProviderConfig = {
  walletAppURL: 'https://sequence.app',
  // walletSessionURL: 'https://session.sequence.app',
  transports: {
    windowTransport: {
      enabled: true
    },
    proxyTransport: {
      enabled: false
    }
  }
};
let walletInstance;
const initWallet = async (network, config) => {
  if (walletInstance && walletInstance.isOpened()) {
    walletInstance.closeWallet();
  }

  walletInstance = new Wallet(network, config);
  await walletInstance.loadSession();
  return walletInstance;
};
const getWallet = () => {
  if (!walletInstance) {
    throw new Error('Wallet has not been initialized, call sequence.initWallet(network, config) first.');
  }

  return walletInstance;
};

export { BaseInjectedTransport, BaseProviderTransport, BaseWalletTransport, CHANNEL_ID, DefaultProviderConfig, ErrSignedInRequired, EventType, ExtensionMessageHandler, ExtensionMessageProvider, InitState, LocalStorage, LocalStore, LocalWeb3Provider, MuxMessageProvider, OpenState, PROVIDER_OPEN_TIMEOUT, ProviderError, ProxyMessageChannel, ProxyMessageChannelPort, ProxyMessageHandler, ProxyMessageProvider, Wallet, WalletRequestHandler, Web3Provider, Web3Signer, WindowMessageHandler, WindowMessageProvider, WindowSessionParams, getWallet, initWallet, isBrowserExtension, isSequenceProvider, isValidMessageSignature, isValidSignature, isValidTypedDataSignature, isWalletUpToDate, messageToBytes, nextMessageIdx, prefixEIP191Message, recoverWalletConfig };
