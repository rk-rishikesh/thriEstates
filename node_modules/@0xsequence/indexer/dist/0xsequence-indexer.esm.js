import fetch from 'cross-fetch';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/* eslint-disable */
// sequence-indexer v0.4.0 6071879702f8258e8912ca95cf2d9c1459ca991d
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript
// Do not edit by hand. Update your webrpc schema and re-generate.
// WebRPC description and code-gen version
const WebRPCVersion = "v1"; // Schema version of your RIDL schema

const WebRPCSchemaVersion = "v0.4.0"; // Schema hash generated from your RIDL schema

const WebRPCSchemaHash = "6071879702f8258e8912ca95cf2d9c1459ca991d"; //
// Types
//

let ContractType;

(function (ContractType) {
  ContractType["UNKNOWN"] = "UNKNOWN";
  ContractType["ERC20"] = "ERC20";
  ContractType["ERC721"] = "ERC721";
  ContractType["ERC1155"] = "ERC1155";
  ContractType["SEQUENCE_WALLET"] = "SEQUENCE_WALLET";
  ContractType["ERC20_BRIDGE"] = "ERC20_BRIDGE";
  ContractType["ERC721_BRIDGE"] = "ERC721_BRIDGE";
  ContractType["ERC1155_BRIDGE"] = "ERC1155_BRIDGE";
})(ContractType || (ContractType = {}));

let EventLogType;

(function (EventLogType) {
  EventLogType["UNKNOWN"] = "UNKNOWN";
  EventLogType["BLOCK_ADDED"] = "BLOCK_ADDED";
  EventLogType["BLOCK_REMOVED"] = "BLOCK_REMOVED";
})(EventLogType || (EventLogType = {}));

let EventLogDataType;

(function (EventLogDataType) {
  EventLogDataType["UNKNOWN"] = "UNKNOWN";
  EventLogDataType["TOKEN_TRANSFER"] = "TOKEN_TRANSFER";
  EventLogDataType["SEQUENCE_TXN"] = "SEQUENCE_TXN";
})(EventLogDataType || (EventLogDataType = {}));

let TxnTransferType;

(function (TxnTransferType) {
  TxnTransferType["UNKNOWN"] = "UNKNOWN";
  TxnTransferType["SEND"] = "SEND";
  TxnTransferType["RECEIVE"] = "RECEIVE";
})(TxnTransferType || (TxnTransferType = {}));

let SortOrder;

(function (SortOrder) {
  SortOrder["DESC"] = "DESC";
  SortOrder["ASC"] = "ASC";
})(SortOrder || (SortOrder = {}));

//
// Client
//
class Indexer {
  constructor(hostname, fetch) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = '/rpc/Indexer/';

    this.ping = headers => {
      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      });
    };

    this.version = headers => {
      return this.fetch(this.url('Version'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            version: _data.version
          };
        });
      });
    };

    this.runtimeStatus = headers => {
      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      });
    };

    this.getChainID = headers => {
      return this.fetch(this.url('GetChainID'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            chainID: _data.chainID
          };
        });
      });
    };

    this.getEtherBalance = (args, headers) => {
      return this.fetch(this.url('GetEtherBalance'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            balance: _data.balance
          };
        });
      });
    };

    this.getTokenBalances = (args, headers) => {
      return this.fetch(this.url('GetTokenBalances'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            balances: _data.balances
          };
        });
      });
    };

    this.getTokenSupplies = (args, headers) => {
      return this.fetch(this.url('GetTokenSupplies'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            contractType: _data.contractType,
            tokenIDs: _data.tokenIDs
          };
        });
      });
    };

    this.getTokenSuppliesMap = (args, headers) => {
      return this.fetch(this.url('GetTokenSuppliesMap'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            supplies: _data.supplies
          };
        });
      });
    };

    this.getBalanceUpdates = (args, headers) => {
      return this.fetch(this.url('GetBalanceUpdates'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            balances: _data.balances
          };
        });
      });
    };

    this.getTransactionHistory = (args, headers) => {
      return this.fetch(this.url('GetTransactionHistory'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            transactions: _data.transactions
          };
        });
      });
    };

    this.syncBalance = (args, headers) => {
      return this.fetch(this.url('SyncBalance'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {};
        });
      });
    };

    this.hostname = hostname;
    this.fetch = fetch;
  }

  url(name) {
    return this.hostname + this.path + name;
  }

}

const createHTTPRequest = (body = {}, headers = {}) => {
  return {
    method: 'POST',
    headers: _extends({}, headers, {
      'Content-Type': 'application/json'
    }),
    body: JSON.stringify(body || {})
  };
};

const buildResponse = res => {
  return res.text().then(text => {
    let data;

    try {
      data = JSON.parse(text);
    } catch (err) {
      throw {
        code: 'unknown',
        msg: `expecting JSON, got: ${text}`,
        status: res.status
      };
    }

    if (!res.ok) {
      throw data; // webrpc error response
    }

    return data;
  });
};

let SequenceIndexerServices;

(function (SequenceIndexerServices) {
  SequenceIndexerServices["MAINNET"] = "https://mainnet-indexer.sequence.app";
  SequenceIndexerServices["POLYGON"] = "https://polygon-indexer.sequence.app";
  SequenceIndexerServices["RINKEBY"] = "https://rinkeby-indexer.sequence.app";
  SequenceIndexerServices["POLYGON_MUMBAI"] = "https://mumbai-indexer.sequence.app";
})(SequenceIndexerServices || (SequenceIndexerServices = {}));

class SequenceIndexerClient extends Indexer {
  constructor(hostname, jwtAuth) {
    super(hostname.endsWith('/') ? hostname.slice(0, -1) : hostname, fetch);
    this.jwtAuth = jwtAuth;

    this._fetch = (input, init) => {
      // automatically include jwt auth header to requests
      // if its been set on the api client
      const headers = {};

      if (this.jwtAuth && this.jwtAuth.length > 0) {
        headers['Authorization'] = `BEARER ${this.jwtAuth}`;
      } // before the request is made


      init.headers = _extends({}, init.headers, headers);
      return fetch(input, init);
    };

    this.fetch = this._fetch;
  }

}

export { ContractType, EventLogDataType, EventLogType, Indexer, SequenceIndexerClient, SequenceIndexerServices, SortOrder, TxnTransferType, WebRPCSchemaHash, WebRPCSchemaVersion, WebRPCVersion };
